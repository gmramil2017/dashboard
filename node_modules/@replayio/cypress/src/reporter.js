"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isStepEvent = exports.getMetadataFilePath = void 0;
/// <reference types="cypress" />
const test_utils_1 = require("@replayio/test-utils");
const error_1 = require("./error");
const fixture_1 = require("./fixture");
const mode_1 = require("./mode");
const steps_1 = require("./steps");
function isStepEvent(value) {
    if (value &&
        typeof value === "object" &&
        "event" in value &&
        typeof value.event === "string" &&
        ["step:enqueue", "step:start", "step:end", "test:start", "test:end"].includes(value.event)) {
        return true;
    }
    return false;
}
exports.isStepEvent = isStepEvent;
class CypressReporter {
    constructor(config, debug) {
        Object.defineProperty(this, "reporter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "debug", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "startTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "steps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "selectedBrowser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "diagnosticConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        (0, fixture_1.initFixtureFile)();
        this.config = config;
        this.reporter = new test_utils_1.ReplayReporter({
            name: "cypress",
            version: config.version,
            plugin: require("../package.json").version,
        }, "2.1.0");
        this.debug = debug.extend("reporter");
        this.diagnosticConfig = (0, mode_1.getDiagnosticConfig)(config);
        // Mix diagnostic env into process env so it can be picked up by test
        // metrics and reported to telemetry
        Object.keys(this.diagnosticConfig.env).forEach(k => {
            process.env[k] = this.diagnosticConfig.env[k];
        });
        this.reporter.setDiagnosticMetadata(this.diagnosticConfig.env);
    }
    onLaunchBrowser(browser) {
        this.setSelectedBrowser(browser);
        this.reporter.onTestSuiteBegin(undefined, "CYPRESS_REPLAY_METADATA");
        // Cypress around 10.9 launches the browser before `before:spec` is called
        // causing us to fail to create the metadata file and link the replay to the
        // current test
        const metadataPath = getMetadataFilePath();
        this.reporter.onTestBegin(undefined, metadataPath);
    }
    onBeforeSpec(spec) {
        const startTime = Date.now();
        (0, fixture_1.appendToFixtureFile)("spec:start", { spec, startTime });
        this.clearSteps();
        this.reporter.onTestBegin(undefined, getMetadataFilePath());
    }
    onAfterSpec(spec, result) {
        (0, fixture_1.appendToFixtureFile)("spec:end", { spec, result });
        const tests = this.getTestResults(spec, result);
        return this.reporter.onTestEnd({ tests, replayTitle: spec.relative, specFile: spec.relative });
    }
    getDiagnosticConfig() {
        return this.diagnosticConfig;
    }
    setSelectedBrowser(browser) {
        this.selectedBrowser = browser;
    }
    clearSteps() {
        this.steps = [];
    }
    addStep(step) {
        (0, fixture_1.appendToFixtureFile)("task", step);
        this.steps.push(step);
    }
    getTestResults(spec, result) {
        const placeholderTest = {
            id: 0,
            approximateDuration: 0,
            source: {
                title: spec.relative,
                scope: [],
            },
            result: "unknown",
            attempt: 1,
            events: {
                afterAll: [],
                afterEach: [],
                beforeAll: [],
                beforeEach: [],
                main: [],
            },
            error: null,
        };
        if (
        // If the browser crashes, no tests are run and tests will be null
        !result.tests ||
            // If the spec doesn't have any tests, we should bail
            result.tests.length === 0) {
            const msg = "No test results found for spec " + spec.relative;
            this.debug(msg);
            this.reporter.addError(new test_utils_1.ReporterError(error_1.Errors.NoTestResults, msg, spec.relative));
            return [
                // return an placeholder test because cypress will still launch a
                // browser for a file that matches the spec format but doesn't contain
                // any tests.
                placeholderTest,
            ];
        }
        let testsWithoutSteps = (0, steps_1.getTestsFromResults)(result.tests);
        let testsWithSteps = [];
        try {
            const sortedSteps = (0, steps_1.sortSteps)(this.steps);
            testsWithSteps = (0, steps_1.groupStepsByTest)(testsWithoutSteps, sortedSteps);
        }
        catch (e) {
            console.warn("Failed to build test step metadata for this replay");
            console.warn(e);
            this.reporter.addError(e);
        }
        return testsWithSteps;
    }
}
function getMetadataFilePath(workerIndex = 0) {
    return (0, test_utils_1.getMetadataFilePath)("CYPRESS", workerIndex);
}
exports.getMetadataFilePath = getMetadataFilePath;
exports.default = CypressReporter;
//# sourceMappingURL=reporter.js.map