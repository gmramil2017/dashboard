"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
let gLastTest;
// order is dropped on test retries so we cache the last value so we can restore
// it for retries
let gLastOrder;
// This lists cypress commands for which we don't need to track in metadata nor
// create annotations because they are "internal plumbing" commands that aren't
// user-facing
const COMMAND_IGNORE_LIST = ["within-restore", "end-logGroup"];
function shouldIgnoreCommand(cmd) {
    if (isCommandQueue(cmd)) {
        cmd = cmd.toJSON();
    }
    return COMMAND_IGNORE_LIST.includes(cmd.name);
}
function simplifyCommand(cmd) {
    if (!cmd) {
        return cmd;
    }
    let args = cmd.args || [];
    try {
        // simplify the command to omit complex objects that may exist in `args`
        args = JSON.parse(JSON.stringify(args, (key, value) => {
            var _a;
            if (key === "") {
                return value;
            }
            const t = typeof value;
            switch (t) {
                case "boolean":
                case "number":
                case "string":
                    return value;
                case "object":
                    const constructorName = (_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.name;
                    if (constructorName === "jQuery") {
                        return `[object ${value.length === 1 ? "Node" : "NodeList"}]`;
                    }
                    else if (constructorName !== "Object") {
                        return `[object ${constructorName}]`;
                    }
                    else {
                        return value;
                    }
                default:
                    return undefined;
            }
        }));
    }
    catch (e) {
        console.error("Replay: Failed to serialize Cypress command");
        console.error(e);
        args = [];
    }
    return Object.assign(Object.assign({}, cmd), { args });
}
function getCurrentTestScope() {
    var _a, _b;
    const mochaTest = cy.state("test");
    const mochaOrder = mochaTest === null || mochaTest === void 0 ? void 0 : mochaTest.order;
    let order = 0;
    if (mochaOrder != null && (gLastOrder == null || mochaOrder - 1 >= gLastOrder)) {
        gLastOrder = order = mochaOrder - 1;
    }
    else if (gLastOrder != null) {
        order = gLastOrder;
    }
    const attempt = ((_a = mochaTest === null || mochaTest === void 0 ? void 0 : mochaTest._currentRetry) !== null && _a !== void 0 ? _a : 0) + 1;
    const hook = getCurrentTestHook();
    if (hook === "beforeAll" || hook === "afterAll") {
        const runnable = Cypress.mocha.getRunner().currentRunnable;
        const test = getHookPath(runnable);
        return {
            test,
            attempt: 1,
            testId: -1,
        };
    }
    if (Cypress.currentTest) {
        return {
            test: Cypress.currentTest.titlePath,
            attempt,
            testId: order,
        };
    }
    // Cypress < 8 logic
    const mochaRunner = (_b = Cypress.mocha) === null || _b === void 0 ? void 0 : _b.getRunner();
    if (!mochaRunner) {
        throw new Error(`Cypress version ${Cypress.version || "(unknown)"} is not supported`);
    }
    let currentTest = (gLastTest = mochaRunner.test || gLastTest);
    const titlePath = [];
    while (currentTest === null || currentTest === void 0 ? void 0 : currentTest.title) {
        titlePath.unshift(currentTest.title);
        currentTest = currentTest.parent;
    }
    return { test: titlePath, testId: order, attempt };
}
const makeEvent = (testScope, event, category, cmd, error) => (Object.assign({ event, file: Cypress.spec.relative, testId: testScope.testId, test: testScope.test, attempt: testScope.attempt, timestamp: new Date().toISOString(), command: simplifyCommand(cmd), category, hook: getCurrentTestHook() }, (error
    ? {
        error,
    }
    : null)));
let eventBuffer = [];
const handleCypressEvent = (testScope, event, category, cmd, error) => {
    var _a;
    if (((_a = cmd === null || cmd === void 0 ? void 0 : cmd.args) === null || _a === void 0 ? void 0 : _a[0]) === constants_1.TASK_NAME)
        return;
    const arg = makeEvent(testScope, event, category, cmd, error);
    eventBuffer.push(arg);
};
const idMap = {};
let gReplayIndex = 1;
const getReplayId = (cypressId) => {
    return (idMap[cypressId] = idMap[cypressId] || String(gReplayIndex++));
};
const getHookPath = (parent) => {
    const path = [];
    while (parent) {
        if (parent.title) {
            path.unshift(parent.title);
            parent = parent.parent;
        }
        else {
            break;
        }
    }
    return path;
};
const getCurrentTestHook = () => {
    try {
        const { type, hookName } = Cypress.mocha.getRunner().currentRunnable;
        if (type === "hook") {
            switch (hookName) {
                case "before all":
                    return "beforeAll";
                case "before each":
                    return "beforeEach";
                case "after each":
                    return "afterEach";
                case "after all":
                    return "afterAll";
            }
        }
    }
    catch (_a) {
        return;
    }
};
function getCypressId(cmd) {
    // Cypress 8 doesn't include an `id` on the command so we fall back to
    // userInvocationStack as a means to uniquely identify a command
    return cmd.get("id") || cmd.get("userInvocationStack");
}
function toCommandJSON(cmd) {
    return {
        name: cmd.get("name"),
        id: getReplayId(getCypressId(cmd)),
        groupId: getReplayId(cmd.get("chainerId")),
        args: cmd.get("args"),
    };
}
function addAnnotation(testScope, event, data) {
    var _a;
    const payload = JSON.stringify(Object.assign(Object.assign(Object.assign({}, data), testScope), { event }));
    if (!((_a = window.top) === null || _a === void 0 ? void 0 : _a.__RECORD_REPLAY_ANNOTATION_HOOK__)) {
        return;
    }
    window.top.__RECORD_REPLAY_ANNOTATION_HOOK__("replay-cypress", JSON.stringify(payload));
}
function isCommandQueue(cmd) {
    return typeof cmd.toJSON === "function";
}
function register() {
    let lastCommand;
    let lastAssertionCommand;
    let currentTestScope;
    Cypress.on("command:enqueued", cmd => {
        try {
            if (shouldIgnoreCommand(cmd)) {
                return;
            }
            // in cypress open, beforeEach isn't called so fetch the current test here
            // as a fallback
            currentTestScope = getCurrentTestScope();
            // Sometimes, cmd is an instance of Cypress.CommandQueue but we can loosely
            // covert it using its toJSON method (which is typed wrong so we have to
            // cast it to any first)
            if (isCommandQueue(cmd)) {
                cmd = cmd.toJSON();
            }
            const id = getReplayId(cmd.id || cmd.userInvocationStack || [cmd.name, ...cmd.args].toString());
            addAnnotation(currentTestScope, "step:enqueue", { commandVariable: "cmd", id });
            handleCypressEvent(currentTestScope, "step:enqueue", "other", {
                id,
                groupId: getReplayId(cmd.chainerId),
                name: cmd.name,
                args: cmd.args,
            });
        }
        catch (e) {
            console.error("Replay: Failed to handle command:enqueue event");
            console.error(e);
        }
    });
    Cypress.on("command:start", cmd => {
        try {
            if (shouldIgnoreCommand(cmd)) {
                return;
            }
            lastCommand = cmd;
            lastAssertionCommand = undefined;
            addAnnotation(currentTestScope, "step:start", {
                commandVariable: "cmd",
                id: getReplayId(getCypressId(cmd)),
            });
            return handleCypressEvent(currentTestScope, "step:start", "command", toCommandJSON(cmd));
        }
        catch (e) {
            console.error("Replay: Failed to handle command:start event");
            console.error(e);
        }
    });
    Cypress.on("command:end", cmd => {
        var _a;
        try {
            if (shouldIgnoreCommand(cmd)) {
                return;
            }
            const log = (_a = cmd
                .get("logs")
                .find((l) => l.get("name") === cmd.get("name"))) === null || _a === void 0 ? void 0 : _a.toJSON();
            addAnnotation(currentTestScope, "step:end", {
                commandVariable: "cmd",
                logVariable: log ? "log" : undefined,
                id: getReplayId(getCypressId(cmd)),
            });
            handleCypressEvent(currentTestScope, "step:end", "command", toCommandJSON(cmd));
        }
        catch (e) {
            console.error("Replay: Failed to handle command:end event");
            console.error(e);
        }
    });
    Cypress.on("log:added", log => {
        const assertionCurrentTest = currentTestScope || getCurrentTestScope();
        try {
            if (log.name === "new url") {
                addAnnotation(assertionCurrentTest, "event:navigation", {
                    logVariable: "log",
                    url: log.url,
                    id: getReplayId(log.id),
                });
                return;
            }
            else if (log.name !== "assert") {
                return;
            }
            let maybeCurrentAssertion = lastAssertionCommand
                ? lastAssertionCommand.get("next")
                : lastCommand === null || lastCommand === void 0 ? void 0 : lastCommand.get("next");
            // if we failed to find an assertion command but this log is for an
            // assert, it's a chai assertion so we'll emit the command:start now
            if (!maybeCurrentAssertion && log.name === "assert") {
                // TODO [ryanjduffy]: This is making a log look like a command. This
                // works in this very narrow case but we should fix this acknowledge
                // that this is a chai assertion which is special and shouldn't
                // masquerade as a command
                maybeCurrentAssertion = {
                    logs: () => [],
                    add: () => { },
                    get: (key) => (!key ? log : log[key]),
                    toJSON: () => log,
                    create: () => ({}),
                };
            }
            else if ((maybeCurrentAssertion === null || maybeCurrentAssertion === void 0 ? void 0 : maybeCurrentAssertion.get("type")) !== "assertion") {
                // debug("Received an assertion log without a prior assertion or command: %o", {
                //   lastAssertionCommandId: lastAssertionCommand && getCypressId(lastAssertionCommand),
                //   lastCommandId: lastCommand && getCypressId(lastCommand),
                //   currentAssertion: maybeCurrentAssertion && maybeCurrentAssertion.toJSON(),
                // });
                return;
            }
            if (shouldIgnoreCommand(maybeCurrentAssertion)) {
                return;
            }
            const assertionId = getReplayId(getCypressId(maybeCurrentAssertion));
            // store the current assertion as the last assertion so we can identify the
            // enqueued command for chained assertions
            lastAssertionCommand = maybeCurrentAssertion;
            const cmd = {
                name: log.name,
                id: assertionId,
                groupId: log.chainerId && getReplayId(log.chainerId),
                args: [log.consoleProps.Message],
                category: "assertion",
                commandId: lastCommand ? getReplayId(getCypressId(lastCommand)) : undefined,
            };
            addAnnotation(assertionCurrentTest, "step:start", {
                commandVariable: "lastCommand",
                logVariable: "log",
                id: cmd.id,
            });
            handleCypressEvent(assertionCurrentTest, "step:start", "assertion", cmd);
            const logChanged = (changedLog) => {
                var _a, _b, _c;
                try {
                    // This callback may be invoked multiple times for an assertion if Cypress
                    // retries the evaluation. There doesn't appear to be an indication when
                    // it's done retrying and it doesn't report `command:end` for failed
                    // events so we're stuck capturing all of these and then ignoring the
                    // intermediate events.
                    if (changedLog.id !== log.id || !["passed", "failed"].includes(changedLog.state))
                        return;
                    // We only care about asserts
                    const changedCmd = Object.assign(Object.assign({}, cmd), { 
                        // Update args which can be updated when an assert resolves
                        args: [changedLog.consoleProps.Message] });
                    const error = changedLog.err
                        ? {
                            name: changedLog.err.name,
                            message: changedLog.err.message,
                            line: (_a = changedLog.err.codeFrame) === null || _a === void 0 ? void 0 : _a.line,
                            column: (_b = changedLog.err.codeFrame) === null || _b === void 0 ? void 0 : _b.column,
                        }
                        : undefined;
                    if (error && lastCommand) {
                        const failedCommandLog = (_c = lastCommand
                            .get("logs")) === null || _c === void 0 ? void 0 : _c.find((l) => l.get("id") === changedLog.id);
                        // if an assertion fails, emit step:end for the failed command
                        addAnnotation(assertionCurrentTest, "step:end", {
                            commandVariable: "lastCommand",
                            logVariable: failedCommandLog ? "failedCommandLog" : undefined,
                            id: getReplayId(getCypressId(lastCommand)),
                        });
                        handleCypressEvent(assertionCurrentTest, "step:end", "command", toCommandJSON(lastCommand));
                    }
                    addAnnotation(assertionCurrentTest, "step:end", {
                        commandVariable: maybeCurrentAssertion ? "maybeCurrentAssertion" : undefined,
                        logVariable: "changedLog",
                        id: changedCmd.id,
                    });
                    handleCypressEvent(assertionCurrentTest, "step:end", "assertion", changedCmd, error);
                }
                catch (e) {
                    console.error("Replay: Failed to handle log:changed event");
                    console.error(e);
                }
            };
            Cypress.on("log:changed", logChanged);
        }
        catch (e) {
            console.error("Replay: Failed to handle log:added event");
            console.error(e);
        }
    });
    beforeEach(() => {
        try {
            currentTestScope = getCurrentTestScope();
            if (currentTestScope) {
                handleCypressEvent(currentTestScope, "test:start");
                addAnnotation(currentTestScope, "test:start");
            }
        }
        catch (e) {
            console.error("Replay: Failed to handle test:start event");
            console.error(e);
        }
    });
    afterEach(() => {
        try {
            if (currentTestScope) {
                addAnnotation(currentTestScope, "test:end");
                handleCypressEvent(currentTestScope, "test:end");
                cy.task(constants_1.TASK_NAME, eventBuffer, { log: false });
                eventBuffer = [];
            }
        }
        catch (e) {
            console.error("Replay: Failed to handle test:end event");
            console.error(e);
        }
    });
}
exports.default = register;
//# sourceMappingURL=support.js.map