"use strict";
/// <reference types="cypress" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortSteps = exports.getTestsFromResults = exports.groupStepsByTest = exports.mapStateToResult = void 0;
const test_utils_1 = require("@replayio/test-utils");
const debug_1 = __importDefault(require("debug"));
const constants_1 = require("./constants");
const error_1 = require("./error");
const debug = (0, debug_1.default)("replay:cypress:plugin:reporter:steps");
function mapStateToResult(state) {
    switch (state) {
        case "failed":
        case "passed":
            return state;
        case "pending":
            return "skipped";
    }
    return "unknown";
}
exports.mapStateToResult = mapStateToResult;
function toEventOrder(event) {
    return ["test:start", "step:enqueue", "step:start", "step:end", "test:end"].indexOf(event.event);
}
function shouldSkipStep(step, skippedSteps) {
    var _a, _b, _c, _d, _e;
    const skipDebug = debug.extend("skip");
    const lastArg = (_b = (_a = step.command) === null || _a === void 0 ? void 0 : _a.args) === null || _b === void 0 ? void 0 : _b[step.command.args.length - 1];
    let reason;
    if (lastArg != null && typeof lastArg === "object" && lastArg.log === false) {
        reason = "Command logging disabled";
    }
    else if (skippedSteps.includes((_c = step.command) === null || _c === void 0 ? void 0 : _c.id)) {
        reason = "Prior step event already skipped";
    }
    else if (skippedSteps.includes((_d = step.command) === null || _d === void 0 ? void 0 : _d.groupId)) {
        reason = "Parent skipped";
    }
    if (reason) {
        skipDebug("Test step %s skipped: %s", ((_e = step.command) === null || _e === void 0 ? void 0 : _e.id) || "", reason);
        return true;
    }
    return false;
}
function simplifyArgs(args) {
    return (args === null || args === void 0 ? void 0 : args.map(a => String(a && typeof a === "object" ? {} : a))) || [];
}
function getTestsFromResults(resultTests) {
    const tests = resultTests.flatMap((result, id) => {
        const scope = [...result.title];
        const title = scope.pop();
        return result.attempts.map((a, attemptIndex) => ({
            id,
            // Cypress 10.9 types are wrong here ... duration doesn't exist but wallClockDuration does
            approximateDuration: a.duration || a.wallClockDuration || 0,
            attempt: attemptIndex + 1,
            source: {
                title,
                scope,
            },
            result: mapStateToResult(a.state),
            events: {
                beforeAll: [],
                afterAll: [],
                beforeEach: [],
                afterEach: [],
                main: [],
            },
            error: result.displayError
                ? {
                    name: "DisplayError",
                    message: result.displayError.substring(0, result.displayError.indexOf("\n")),
                }
                : null,
        }));
    });
    debug("Found %d tests", tests.length);
    debug("%O", tests.map(t => t.source.title));
    return tests;
}
exports.getTestsFromResults = getTestsFromResults;
function sortSteps(steps) {
    // The steps can come in out of order but are sortable by timestamp
    const sortedSteps = [...steps].sort((a, b) => {
        const tsCompare = a.timestamp.localeCompare(b.timestamp);
        if (tsCompare === 0) {
            return toEventOrder(a) - toEventOrder(b);
        }
        return tsCompare;
    });
    return sortedSteps;
}
exports.sortSteps = sortSteps;
function groupStepsByTest(tests, steps) {
    var _a, _b, _c, _d, _e, _f;
    const hooks = {
        afterAll: [],
        beforeAll: [],
    };
    const stepStack = [];
    const skippedStepIds = [];
    // steps are grouped by `chainerId` and then assigned a parent here by
    // tracking the most recent groupId
    let activeGroup;
    let currentTest;
    for (let i = 0; i < steps.length; i++) {
        const step = steps[i];
        const testForStep = tests.find(t => t.id === step.testId && t.attempt === step.attempt);
        if (currentTest !== testForStep) {
            activeGroup = undefined;
        }
        currentTest = testForStep;
        debug("Processing %s event: %o", step.event, step);
        try {
            switch (step.event) {
                case "step:enqueue":
                    // ignore for now ...
                    break;
                case "step:start":
                    let parentId;
                    if (shouldSkipStep(step, skippedStepIds)) {
                        if ((_a = step.command) === null || _a === void 0 ? void 0 : _a.id) {
                            skippedStepIds.push(step.command.id);
                        }
                        if ((_b = step.command) === null || _b === void 0 ? void 0 : _b.groupId) {
                            skippedStepIds.push(step.command.groupId);
                        }
                        break;
                    }
                    if (activeGroup && activeGroup.groupId === ((_c = step.command) === null || _c === void 0 ? void 0 : _c.groupId)) {
                        parentId = activeGroup.parentId;
                    }
                    else if ((_d = step.command) === null || _d === void 0 ? void 0 : _d.groupId) {
                        activeGroup = { groupId: step.command.groupId, parentId: step.command.id };
                    }
                    // Simplify args to avoid sending large objects in metadata that we
                    // won't render in the UI anyway
                    const args = simplifyArgs((_e = step.command) === null || _e === void 0 ? void 0 : _e.args);
                    const testStep = {
                        data: {
                            id: step.command.id,
                            parentId: parentId || null,
                            category: step.category || "other",
                            command: {
                                name: step.command.name,
                                arguments: args,
                            },
                            scope: step.test.slice(0, -1),
                            error: null,
                        },
                    };
                    stepStack.push({ event: step, step: testStep });
                    // accumulate beforeAll/afterAll commands so they can be distributed
                    // to all tests later
                    if (step.hook && (step.hook === "beforeAll" || step.hook === "afterAll")) {
                        hooks[step.hook].push(testStep);
                        continue;
                    }
                    (0, error_1.assertCurrentTest)(currentTest, step);
                    currentTest.events.main.push(testStep);
                    break;
                case "step:end":
                    const isAssert = step.command.name === "assert";
                    const lastStep = stepStack.find(a => a.step.data.id === step.command.id &&
                        a.event.test.toString() === step.test.toString());
                    if (!lastStep && skippedStepIds.includes((_f = step.command) === null || _f === void 0 ? void 0 : _f.id)) {
                        // ignore step:ends for skipped steps
                        break;
                    }
                    // TODO [ryanjduffy]: Skipping handling after each events for now
                    if (step.test[0] === constants_1.AFTER_EACH_HOOK) {
                        debug("After each hooks are not currently supported");
                        continue;
                    }
                    (0, error_1.assertMatchingStep)(step, lastStep === null || lastStep === void 0 ? void 0 : lastStep.event);
                    // asserts can change the args if the message changes
                    if (isAssert && step.command) {
                        lastStep.step.data.command.arguments = simplifyArgs(step.command.args);
                    }
                    // Always set the error so that a successful retry will clear a previous error
                    const currentTestStep = lastStep.step;
                    currentTestStep.data.error = step.error || null;
                    break;
                case "test:end":
                    (0, error_1.assertCurrentTest)(currentTest, step);
                    break;
            }
        }
        catch (e) {
            if ((0, error_1.isStepAssertionError)(e)) {
                throw new test_utils_1.ReporterError(e.code, e.message, e.step);
            }
            else {
                throw new test_utils_1.ReporterError(error_1.Errors.UnexpectedError, "Unexpected step processing error", e);
            }
        }
    }
    // Distribute beforeAll/afterAll hook commands to each test
    const hookNames = Object.keys(hooks);
    hookNames.forEach(hookName => {
        const hookActions = hooks[hookName];
        hookActions.forEach(action => {
            tests.forEach(test => {
                if (action.data.scope.every((scope, i) => scope === test.source.scope[i])) {
                    test.events[hookName].push(action);
                }
            });
        });
    });
    return tests;
}
exports.groupStepsByTest = groupStepsByTest;
//# sourceMappingURL=steps.js.map