"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReporterError = void 0;
const replay_1 = require("@replayio/replay");
const metadata_1 = require("@replayio/replay/metadata");
const fs_1 = require("fs");
const debug_1 = __importDefault(require("debug"));
const uuid = require("uuid");
const metadata_2 = require("./metadata");
const metrics_1 = require("./metrics");
const debug = (0, debug_1.default)("replay:test-utils:reporter");
function parseRuntime(runtime) {
    return ["chromium", "gecko", "node"].find(r => runtime === null || runtime === void 0 ? void 0 : runtime.includes(r));
}
class ReporterError extends Error {
    constructor(code, message, detail = null) {
        super();
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "detail", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = "ReporterError";
        this.code = code;
        this.message = message;
        this.detail = !detail || typeof detail === "string" ? detail : JSON.stringify(detail);
    }
    valueOf() {
        return {
            code: this.code,
            name: this.name,
            message: this.message,
            detail: this.detail,
        };
    }
}
exports.ReporterError = ReporterError;
class ReplayReporter {
    constructor(runner, schemaVersion) {
        Object.defineProperty(this, "baseId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: uuid.validate(process.env.RECORD_REPLAY_METADATA_TEST_RUN_ID || process.env.RECORD_REPLAY_TEST_RUN_ID || "")
                ? process.env.RECORD_REPLAY_METADATA_TEST_RUN_ID || process.env.RECORD_REPLAY_TEST_RUN_ID
                : uuid.v4()
        });
        Object.defineProperty(this, "baseMetadata", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        Object.defineProperty(this, "schemaVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "runTitle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "runner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.runner = runner;
        this.schemaVersion = schemaVersion;
    }
    getResultFromResultCounts(resultCounts) {
        const { failed, passed, skipped, timedOut } = resultCounts;
        if (failed > 0) {
            return "failed";
        }
        else if (timedOut > 0) {
            return "timedOut";
        }
        else if (passed > 0) {
            return "passed";
        }
        else if (skipped > 0) {
            return "skipped";
        }
        else {
            return "unknown";
        }
    }
    summarizeResults(tests) {
        let approximateDuration = 0;
        let resultCounts = {
            failed: 0,
            passed: 0,
            skipped: 0,
            timedOut: 0,
            unknown: 0,
        };
        const testsById = {};
        tests.forEach(test => {
            if (!testsById[test.id] || test.attempt > testsById[test.id].attempt) {
                testsById[test.id] = test;
            }
        });
        Object.values(testsById).forEach(t => {
            approximateDuration += t.approximateDuration || 0;
            switch (t.result) {
                case "failed":
                    resultCounts.failed++;
                    break;
                case "passed":
                    resultCounts.passed++;
                    break;
                case "skipped":
                    resultCounts.skipped++;
                    break;
                case "timedOut":
                    resultCounts.timedOut++;
                    break;
                default:
                    resultCounts.unknown++;
            }
        });
        return { approximateDuration, resultCounts };
    }
    getTestId(source) {
        if (!source) {
            return this.baseId;
        }
        return `${this.baseId}-${[...source.scope, source.title].join("-")}`;
    }
    parseConfig(config = {}, metadataKey) {
        // always favor environment variables over config so the config can be
        // overwritten at runtime
        this.runTitle = process.env.RECORD_REPLAY_TEST_RUN_TITLE || config.runTitle;
        // RECORD_REPLAY_METADATA is our "standard" metadata environment variable.
        // We suppress it for the browser process so we can use
        // RECORD_REPLAY_METADATA_FILE but can still use the metadata here which
        // runs in the test runner process. However, test runners may have a
        // convention for reporter-specific environment configuration which should
        // supersede this.
        if (metadataKey && process.env[metadataKey] && process.env.RECORD_REPLAY_METADATA) {
            console.warn(`Cannot set metadata via both RECORD_REPLAY_METADATA and ${metadataKey}. Using ${metadataKey}.`);
        }
        const baseMetadata = (metadataKey && process.env[metadataKey]) ||
            process.env.RECORD_REPLAY_METADATA ||
            config.metadata ||
            null;
        if (baseMetadata) {
            // Since we support either a string in an environment variable or an
            // object in the cfg, we need to parse out the string value. Technically,
            // you could use a string in the config file too but that'd be unexpected.
            // Nonetheless, it'll be handled correctly here if you're into that sort
            // of thing.
            if (typeof baseMetadata === "string") {
                try {
                    this.baseMetadata = JSON.parse(baseMetadata);
                }
                catch (_a) {
                    console.warn("Failed to parse Replay metadata");
                }
            }
            else {
                this.baseMetadata = baseMetadata;
            }
        }
    }
    addError(err) {
        if (err.name === "ReporterError") {
            this.errors.push(err);
        }
        else {
            this.errors.push(new ReporterError(-1, "Unexpected error", err));
        }
    }
    setDiagnosticMetadata(metadata) {
        this.baseMetadata = Object.assign(Object.assign({}, this.baseMetadata), { "x-replay-diagnostics": metadata });
    }
    onTestSuiteBegin(config, metadataKey) {
        this.parseConfig(config, metadataKey);
        debug("onTestSuiteBegin: Reporter Configuration: %o", {
            baseId: this.baseId,
            runTitle: this.runTitle,
            runner: this.runner,
            baseMetadata: this.baseMetadata,
        });
    }
    onTestBegin(source, metadataFilePath = (0, metadata_2.getMetadataFilePath)("REPLAY_TEST", 0)) {
        const id = this.getTestId(source);
        this.errors = [];
        const metadata = Object.assign(Object.assign({}, (this.baseMetadata || {})), { "x-replay-test": {
                id,
            } });
        debug("onTestBegin: Writing metadata to %s: %o", metadataFilePath, metadata);
        (0, fs_1.writeFileSync)(metadataFilePath, JSON.stringify(metadata, undefined, 2), {});
    }
    onTestEnd({ tests, specFile, replayTitle, extraMetadata, }) {
        // if we bailed building test metadata because of a crash or because no
        // tests ran, we can bail here too
        if (tests.length === 0) {
            debug("onTestEnd: No tests found");
            return;
        }
        const filter = `function($v) { $v.metadata.\`x-replay-test\`.id in ${JSON.stringify([
            ...tests.map(test => this.getTestId(test.source)),
            this.getTestId(),
        ])} and $not($exists($v.metadata.test)) }`;
        const recs = (0, replay_1.listAllRecordings)({
            filter,
        });
        debug("onTestEnd: Found %d recs with filter %s", recs.length, filter);
        const test = tests[0];
        const { approximateDuration, resultCounts } = this.summarizeResults(tests);
        const result = this.getResultFromResultCounts(resultCounts);
        const source = {
            path: specFile,
            title: replayTitle || test.source.title,
        };
        const metadata = {
            approximateDuration,
            source,
            result,
            resultCounts,
            run: {
                id: this.baseId,
                title: this.runTitle,
            },
            tests,
            environment: {
                errors: this.errors.map(e => e.valueOf()),
                pluginVersion: this.runner.plugin,
                testRunner: {
                    name: this.runner.name,
                    version: this.runner.version,
                },
            },
            schemaVersion: this.schemaVersion,
        };
        let recordingId;
        let runtime;
        let validatedTestMetadata;
        if (recs.length > 0) {
            recordingId = recs[0].id;
            runtime = recs[0].runtime;
            debug("onTestEnd: Adding test metadata to %s", recordingId);
            debug("onTestEnd: Includes %s errors", this.errors.length);
            validatedTestMetadata = metadata_1.test.init(metadata);
            recs.forEach(rec => (0, metadata_1.add)(rec.id, Object.assign(Object.assign({ title: replayTitle || test.source.title }, extraMetadata), validatedTestMetadata)));
        }
        (0, metrics_1.pingTestMetrics)(recordingId, this.baseId, {
            id: source.path + "#" + source.title,
            source,
            approximateDuration,
            recorded: !!recordingId,
            runtime: parseRuntime(runtime),
            runner: this.runner.name,
            result: result,
        });
        return validatedTestMetadata;
    }
}
exports.default = ReplayReporter;
//# sourceMappingURL=reporter.js.map