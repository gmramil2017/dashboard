"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = exports.validate = void 0;
const superstruct_1 = require("superstruct");
const v1_1 = __importDefault(require("./v1"));
const v2_1 = __importDefault(require("./v2"));
const VERSION = "2.1.0";
const versions = Object.assign(Object.assign({}, v1_1.default), v2_1.default);
function validate(metadata) {
    if (!metadata || !metadata.test) {
        throw new Error("Test metadata does not exist");
    }
    return init(metadata.test);
}
exports.validate = validate;
function getVersion(k) {
    const v = versions[k];
    if (!v) {
        console.warn(`Unable to validate unknown version of test metadata:${k} `);
        return (0, superstruct_1.any)();
    }
    return v;
}
function init(data = {}) {
    let version = VERSION;
    if ("version" in data && typeof data.version === "number") {
        // explicitly adapt the pre-semver scheme
        version = "1.0.0";
    }
    else if ("schemaVersion" in data && typeof data.schemaVersion === "string") {
        version = data.schemaVersion;
    }
    let schema;
    try {
        schema = getVersion(version);
    }
    catch (_a) {
        console.warn(`Unable to validate unknown version of test metadata: ${version || "Unspecified"}`);
        return {
            test: data,
        };
    }
    try {
        return {
            test: (0, superstruct_1.create)(data, schema),
        };
    }
    catch (e) {
        console.error(e);
        console.error("Metadata:");
        console.error(JSON.stringify(data, undefined, 2));
        return {};
    }
}
exports.init = init;
//# sourceMappingURL=index.js.map