"use strict";
// Manage installation of browsers for other NPM packages.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateBrowsers = exports.getPuppeteerBrowserPath = exports.getPlaywrightBrowserPath = exports.ensurePuppeteerBrowsersInstalled = exports.ensurePlaywrightBrowsersInstalled = void 0;
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const https_1 = __importDefault(require("https"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("./utils");
const debug = (0, debug_1.default)("replay:cli:install");
const EXECUTABLE_PATHS = {
    "darwin:firefox": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
    "darwin:chromium": ["Replay-Chromium.app", "Contents", "MacOS", "Chromium"],
    "linux:chromium": ["chrome-linux", "chrome"],
    "linux:firefox": ["firefox", "firefox"],
};
function getBrowserDownloadFileName(key) {
    switch (key) {
        case "darwin:firefox":
            return process.env.RECORD_REPLAY_FIREFOX_DOWNLOAD_FILE || "macOS-replay-playwright.tar.xz";
        case "darwin:chromium":
            return process.env.RECORD_REPLAY_CHROMIUM_DOWNLOAD_FILE || process.arch.startsWith("arm")
                ? "macOS-replay-chromium-arm.tar.xz"
                : "macOS-replay-chromium.tar.xz";
        case "linux:chromium":
            return process.env.RECORD_REPLAY_CHROMIUM_DOWNLOAD_FILE || "linux-replay-chromium.tar.xz";
        case "linux:firefox":
            return process.env.RECORD_REPLAY_FIREFOX_DOWNLOAD_FILE || "linux-replay-playwright.tar.xz";
    }
    throw new Error("Unexpected platform");
}
function ensureBrowsersInstalled(kind, force, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, utils_1.maybeLog)(opts.verbose, `Installing ${kind === "all" ? "browsers" : kind} for ${process.platform}`);
        if (kind !== "all" && !getPlatformKey(kind)) {
            console.log(`${kind} browser for Replay is not supported on ${process.platform}`);
            return;
        }
        switch (process.platform) {
            case "darwin":
                if (["all", "firefox"].includes(kind)) {
                    yield installReplayBrowser(getBrowserDownloadFileName("darwin:firefox"), "firefox", "firefox", force, opts);
                }
                if (["all", "chromium"].includes(kind)) {
                    yield installReplayBrowser(getBrowserDownloadFileName("darwin:chromium"), process.arch.startsWith("arm") ? "Replay-Chromium-ARM.app" : "Replay-Chromium.app", "Replay-Chromium.app", force, opts);
                }
                break;
            case "linux":
                if (["all", "firefox"].includes(kind)) {
                    yield installReplayBrowser(getBrowserDownloadFileName("linux:firefox"), "firefox", "firefox", force, opts);
                }
                if (["all", "chromium"].includes(kind)) {
                    yield installReplayBrowser(getBrowserDownloadFileName("linux:chromium"), "replay-chromium", "chrome-linux", force, opts);
                }
                break;
        }
    });
}
/**
 * Installs the Replay-enabled playwright browsers for the current platform is
 * not already installed
 */
function ensurePlaywrightBrowsersInstalled(kind = "all", opts = {}) {
    return ensureBrowsersInstalled(kind, false, opts);
}
exports.ensurePlaywrightBrowsersInstalled = ensurePlaywrightBrowsersInstalled;
/**
 * Installs the Replay-enabled puppeteer browsers for the current platform is
 * not already installed
 */
function ensurePuppeteerBrowsersInstalled(kind = "all", opts = {}) {
    return ensureBrowsersInstalled("chromium", false, opts);
}
exports.ensurePuppeteerBrowsersInstalled = ensurePuppeteerBrowsersInstalled;
function updateBrowsers(opts) {
    return ensureBrowsersInstalled("all", true, opts);
}
exports.updateBrowsers = updateBrowsers;
function getPlatformKey(browserName) {
    const key = `${process.platform}:${browserName}`;
    switch (key) {
        case "darwin:firefox":
        case "linux:firefox":
        case "darwin:chromium":
        case "linux:chromium":
            return key;
    }
    return undefined;
}
function getExecutablePath(browserName) {
    const overridePathKey = `REPLAY_${browserName.toUpperCase()}_EXECUTABLE_PATH`;
    const overridePath = process.env[overridePathKey];
    if (overridePath) {
        debug(`Using executable override for ${browserName}: ${overridePath}`);
        return overridePath;
    }
    const key = getPlatformKey(browserName);
    if (!key) {
        return null;
    }
    return path_1.default.join(getRuntimesDirectory(), ...EXECUTABLE_PATHS[key]);
}
/**
 * Returns the path to playwright for the current platform
 */
function getPlaywrightBrowserPath(kind) {
    return getExecutablePath(kind);
}
exports.getPlaywrightBrowserPath = getPlaywrightBrowserPath;
/**
 * Returns the path to puppeteer for the current platform
 */
function getPuppeteerBrowserPath(kind) {
    return getExecutablePath(kind);
}
exports.getPuppeteerBrowserPath = getPuppeteerBrowserPath;
function extractBrowserArchive(browserDir, name) {
    const fullName = path_1.default.join(browserDir, name);
    const tarResult = (0, child_process_1.spawnSync)("tar", ["xf", name], { cwd: browserDir });
    if (tarResult.status !== 0) {
        console.error("Failed to extract", fullName);
        console.error(String(tarResult.stderr));
        throw new Error("Unable to extract browser archive");
    }
    fs_1.default.unlinkSync(fullName);
}
function getRuntimesDirectory(opts) {
    const replayDir = (0, utils_1.getDirectory)(opts);
    return path_1.default.join(replayDir, "runtimes");
}
// Installs a browser if it isn't already installed.
function installReplayBrowser(name, srcName, dstName, force = false, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const replayDir = (0, utils_1.getDirectory)();
        const browserDir = getRuntimesDirectory(opts);
        const dstDir = path_1.default.join(browserDir, dstName);
        const dstExists = fs_1.default.existsSync(dstDir);
        if (dstExists) {
            if (force) {
                debug("Removing %s from %s before updating", name, dstDir);
                // Remove the browser so installReplayBrowser will reinstall it. We don't have a way
                // to see that the current browser is up to date.
                fs_1.default.rmSync(dstDir, { force: true, recursive: true });
            }
            else {
                (0, utils_1.maybeLog)(opts.verbose, `Skipping ${dstName}. Already exists in ${browserDir}`);
                return;
            }
        }
        debug("Installing %s from %s to %s", name, srcName, path_1.default.join(browserDir, name));
        const contents = yield downloadReplayFile(name, opts);
        for (const dir of [replayDir, browserDir]) {
            if (!fs_1.default.existsSync(dir)) {
                fs_1.default.mkdirSync(dir);
            }
        }
        (0, utils_1.maybeLog)(opts.verbose, `Saving ${dstName} to ${browserDir}`);
        fs_1.default.writeFileSync(path_1.default.join(browserDir, name), contents);
        extractBrowserArchive(browserDir, name);
        if (srcName != dstName) {
            fs_1.default.renameSync(path_1.default.join(browserDir, srcName), path_1.default.join(browserDir, dstName));
        }
    });
}
function downloadReplayFile(downloadFile, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = {
            host: "static.replay.io",
            port: 443,
            path: `/downloads/${downloadFile}`,
        };
        for (let i = 0; i < 5; i++) {
            const waiter = (0, utils_1.defer)();
            (0, utils_1.maybeLog)(opts.verbose, `Downloading ${downloadFile} from replay.io (Attempt ${i + 1} / 5)`);
            debug("Downloading %o", options);
            const request = https_1.default.get(options, response => {
                if (response.statusCode != 200) {
                    console.log(`Download received status code ${response.statusCode}, retrying...`);
                    request.destroy();
                    waiter.resolve(null);
                    return;
                }
                const buffers = [];
                response.on("data", data => buffers.push(data));
                response.on("end", () => waiter.resolve(buffers));
            });
            request.on("error", err => {
                console.log(`Download error ${err}, retrying...`);
                request.destroy();
                waiter.resolve(null);
            });
            const buffers = yield waiter.promise;
            if (buffers) {
                return Buffer.concat(buffers);
            }
            (0, utils_1.maybeLog)(opts.verbose, `Download of ${downloadFile} complete`);
        }
        throw new Error("Download failed, giving up");
    });
}
//# sourceMappingURL=install.js.map