"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplayClient = void 0;
const fs_1 = __importDefault(require("fs"));
const crypto_1 = __importDefault(require("crypto"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const client_1 = __importDefault(require("./client"));
const utils_1 = require("./utils");
const metadata_1 = require("../metadata");
function sha256(text) {
    return crypto_1.default.createHash("sha256").update(text).digest("hex");
}
class ReplayClient {
    constructor() {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "clientReady", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, utils_1.defer)()
        });
    }
    initConnection(server, accessToken, verbose, agent) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client) {
                let { resolve } = this.clientReady;
                this.client = new client_1.default(server, {
                    onOpen: () => __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.client.setAccessToken(accessToken);
                            resolve(true);
                        }
                        catch (err) {
                            (0, utils_1.maybeLog)(verbose, `Error authenticating with server: ${err}`);
                            resolve(false);
                        }
                    }),
                    onClose() {
                        resolve(false);
                    },
                    onError(e) {
                        (0, utils_1.maybeLog)(verbose, `Error connecting to server: ${e}`);
                        resolve(false);
                    },
                }, {
                    agent,
                });
            }
            return this.clientReady.promise;
        });
    }
    connectionBeginRecordingUpload(id, buildId, size) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const { recordingId, uploadLink } = yield this.client.sendCommand("Internal.beginRecordingUpload", {
                buildId,
                // 3/22/2022: Older builds use integers instead of UUIDs for the recording
                // IDs written to disk. These are not valid to use as recording IDs when
                // uploading recordings to the backend.
                recordingId: (0, utils_1.isValidUUID)(id) ? id : undefined,
                recordingSize: size,
            });
            return { recordingId, uploadLink };
        });
    }
    buildRecordingMetadata(metadata, _opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // extract the "standard" metadata and route the `rest` through the sanitizer
            const { duration, url, uri, title, operations } = metadata, rest = __rest(metadata, ["duration", "url", "uri", "title", "operations"]);
            const metadataUrl = url || uri;
            return {
                recordingData: {
                    duration: typeof duration === "number" ? duration : 0,
                    url: typeof metadataUrl === "string" ? metadataUrl : "",
                    title: typeof title === "string" ? title : "",
                    operations: operations && typeof operations === "object"
                        ? operations
                        : {
                            scriptDomains: [],
                        },
                    lastScreenData: "",
                    lastScreenMimeType: "",
                },
                metadata: yield (0, metadata_1.sanitize)(rest),
            };
        });
    }
    setRecordingMetadata(id, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            metadata.recordingData.id = id;
            yield this.client.sendCommand("Internal.setRecordingMetadata", metadata);
        });
    }
    connectionProcessRecording(recordingId) {
        if (!this.client)
            throw new Error("Protocol client is not initialized");
        this.client.sendCommand("Recording.processRecording", { recordingId });
    }
    connectionWaitForProcessed(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const { sessionId } = yield this.client.sendCommand("Recording.createSession", {
                recordingId,
            });
            const waiter = (0, utils_1.defer)();
            this.client.setEventListener("Recording.sessionError", ({ message }) => waiter.resolve(`session error ${sessionId}: ${message}`));
            this.client.setEventListener("Session.unprocessedRegions", () => { });
            this.client
                .sendCommand("Session.ensureProcessed", { level: "basic" }, null, sessionId)
                .then(() => waiter.resolve(null));
            const error = yield waiter.promise;
            return error;
        });
    }
    connectionReportCrash(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            yield this.client.sendCommand("Internal.reportCrash", { data });
        });
    }
    uploadRecording(path, uploadLink, size) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = fs_1.default.createReadStream(path);
            yield (0, node_fetch_1.default)(uploadLink, {
                method: "PUT",
                headers: { "Content-Length": size.toString() },
                body: file,
            });
        });
    }
    connectionEndRecordingUpload(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            yield this.client.sendCommand("Internal.endRecordingUpload", {
                recordingId,
            });
        });
    }
    connectionUploadSourcemap(recordingId, metadata, content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const resource = yield this.createResource(content);
            const { baseURL, targetContentHash, targetURLHash, targetMapURLHash } = metadata;
            const result = yield this.client.sendCommand("Recording.addSourceMap", {
                recordingId,
                resource,
                baseURL,
                targetContentHash,
                targetURLHash,
                targetMapURLHash,
            });
            return result.id;
        });
    }
    connectionUploadOriginalSource(recordingId, parentId, metadata, content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const resource = yield this.createResource(content);
            const { parentOffset } = metadata;
            yield this.client.sendCommand("Recording.addOriginalSource", {
                recordingId,
                resource,
                parentId,
                parentOffset,
            });
        });
    }
    createResource(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.client)
                throw new Error("Protocol client is not initialized");
            const hash = "sha256:" + sha256(content);
            const { token } = yield this.client.sendCommand("Resource.token", { hash });
            let resource = {
                token,
                saltedHash: "sha256:" + sha256(token + content),
            };
            const { exists } = yield this.client.sendCommand("Resource.exists", {
                resource,
            });
            if (!exists) {
                ({ resource } = yield this.client.sendCommand("Resource.create", { content }));
            }
            return resource;
        });
    }
    closeConnection() {
        if (this.client) {
            this.client.close();
            this.client = undefined;
            this.clientReady = (0, utils_1.defer)();
        }
    }
}
exports.ReplayClient = ReplayClient;
//# sourceMappingURL=upload.js.map