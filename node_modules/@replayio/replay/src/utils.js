"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidUUID = exports.getDirectory = exports.maybeLog = exports.defer = exports.exponentialBackoffRetry = void 0;
const debug_1 = __importDefault(require("debug"));
const path_1 = __importDefault(require("path"));
const debug = (0, debug_1.default)("replay:cli");
function defer() {
    let resolve = () => { };
    let reject = () => { };
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return { promise, resolve, reject };
}
exports.defer = defer;
function maybeLog(verbose, str) {
    debug(str);
    if (verbose) {
        console.log(str);
    }
}
exports.maybeLog = maybeLog;
function getDirectory(opts) {
    const home = process.env.HOME || process.env.USERPROFILE;
    return ((opts && opts.directory) || process.env.RECORD_REPLAY_DIRECTORY || path_1.default.join(home, ".replay"));
}
exports.getDirectory = getDirectory;
function isValidUUID(str) {
    if (typeof str != "string" || str.length != 36) {
        return false;
    }
    for (let i = 0; i < str.length; i++) {
        if ("0123456789abcdef-".indexOf(str[i]) == -1) {
            return false;
        }
    }
    return true;
}
exports.isValidUUID = isValidUUID;
function waitForTime(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise(r => setTimeout(r, ms));
    });
}
// Random extra delay under 100ms to avoid retrying in bursts.
function jitter() {
    return Math.random() * 100.0;
}
// Returns backoff timeouts (in ms) in a geometric progression, and with jitter.
function backoff(iteration) {
    return Math.pow(2, iteration) * 100 + jitter();
}
const MAX_ATTEMPTS = 5;
function exponentialBackoffRetry(fn, onFail) {
    return __awaiter(this, void 0, void 0, function* () {
        let currentAttempt = 0;
        while (currentAttempt <= MAX_ATTEMPTS) {
            currentAttempt++;
            try {
                return fn();
            }
            catch (e) {
                if (onFail) {
                    onFail(e);
                }
                if (currentAttempt == MAX_ATTEMPTS) {
                    throw e;
                }
                waitForTime(backoff(currentAttempt));
            }
        }
        throw Error("ShouldBeUnreachable");
    });
}
exports.exponentialBackoffRetry = exponentialBackoffRetry;
//# sourceMappingURL=utils.js.map