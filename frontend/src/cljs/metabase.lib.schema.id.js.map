{"version":3,"sources":["metabase/lib/schema/id.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,AAAAA,4CAAA,wGAAA;AAQA,AAAAA,4CAAA,uJAAA,mFAAA,+CACMC;AAEN,AAAAD,4CAAA,kGAAA;AAGA,AAAAA,4CAAA,kGAAA;AAGA,AAAAA,4CAAA,gGAAA;AAGA,AAAAA,4CAAA,sGAAA;AAGA,AAAAA,4CAAA,mGAAA;AAGA,AAAAA,4CAAA,qGAAA","names":["metabase.util.malli.registry/register!","metabase.mbql.schema/saved-questions-virtual-database-id"],"sourcesContent":["(ns metabase.lib.schema.id\n  (:require\n   [metabase.lib.schema.common :as common]\n   [metabase.mbql.schema :as mbql.s]\n   [metabase.util.malli.registry :as mr]))\n\n;;; these aren't anything special right now, but maybe in the future we can do something special/intelligent with\n;;; them, e.g. when we start working on the generative stuff\n\n(mr/def ::database\n  ::common/int-greater-than-or-equal-to-zero)\n\n;;; not sure under what circumstances we actually want to allow this, this is an icky hack. How are we supposed to\n;;; resolve stuff with a fake Database ID? I guess as far as the schema is concerned we can allow this tho.\n;;;\n;;; EDIT: Sometimes the FE uses this when starting a query based on a Card if it doesn't know the database associated\n;;; with that Card. The QP will resolve this to the correct Database later.\n(mr/def ::saved-questions-virtual-database\n  [:= mbql.s/saved-questions-virtual-database-id])\n\n(mr/def ::table\n  ::common/int-greater-than-or-equal-to-zero)\n\n(mr/def ::field\n  ::common/int-greater-than-or-equal-to-zero)\n\n(mr/def ::card\n  ::common/int-greater-than-or-equal-to-zero)\n\n(mr/def ::segment\n  ::common/int-greater-than-or-equal-to-zero)\n\n(mr/def ::metric\n  ::common/int-greater-than-or-equal-to-zero)\n\n(mr/def ::snippet\n  ::common/int-greater-than-or-equal-to-zero)\n"]}