{"version":3,"sources":["metabase/lib/schema/expression/temporal.cljc"],"mappings":"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","names":["metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","metabase.lib.schema.expression/type-of-method","p__60795","vec__60796","cljs.core.nth","_tag","_opts","temporal","inner-type","metabase.lib.schema.expression/type-of","cljs.core/set?","temporal-set","clojure.set.intersection","cljs.core._EQ_","cljs.core/count","cljs.core/first","metabase.lib.hierarchy/derive","seq__60799","cljs.core/seq","chunk__60800","count__60801","i__60802","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/next","op","seq__60803","chunk__60804","count__60805","i__60806","seq__60811","chunk__60812","count__60813","i__60814","temporal-extract-op","metabase.util.malli.registry/register!","metabase.lib.schema.mbql_clause.define_catn_mbql_clause","cljs.core.into","p__60815","map__60816","cljs.core/--destructure-map","cljs.core.get","value","_","cljs.core.pr_str","cljs.core.sort","js/shadow.js.shim.module$moment","base-type","p1__60817#","cljs.core/some","cljs.core.isa_QMARK_","metabase.lib.schema.mbql_clause.define_mbql_clause","p__60820","vec__60821","unit","or__5045__auto__","malli.core.validate","cljs.core/re-matches","metabase.lib.schema.literal/year-month-regex","metabase.lib.schema.literal/year-regex","value-type","p1__60819#","cljs.core.filter"],"sourcesContent":["(ns metabase.lib.schema.expression.temporal\n  (:require\n   [clojure.set :as set]\n   [malli.core :as mc]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.literal :as literal]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.util.malli.registry :as mr])\n  #?@\n  (:clj\n   [(:import\n     (java.time ZoneId))]\n   :cljs\n   [(:require\n     [\"moment\" :as moment]\n     [\"moment-timezone\" :as mtz])]))\n\n#?(:cljs\n   ;; so the moment-timezone stuff gets loaded\n   (comment mtz/keep-me))\n\n(mbql-clause/define-tuple-mbql-clause :interval :- :type/Interval\n  :int\n  ::temporal-bucketing/unit.date-time.interval)\n\n(defmethod expression/type-of-method :lib.type-of/type-is-temporal-type-of-first-arg [[_tag _opts temporal]]\n  ;; For datetime-add, datetime-subtract, etc. the first arg is a temporal value. However, some valid values are\n  ;; formatted strings for which type-of returns eg. #{:type/String :type/DateTime}. Since we're doing date arithmetic,\n  ;; we know for sure it's the temporal type.\n  (let [inner-type (expression/type-of temporal)]\n    (if (set? inner-type)\n      (let [temporal-set (set/intersection inner-type #{:type/Date :type/DateTime})]\n        (if (= (count temporal-set) 1)\n          (first temporal-set)\n          temporal-set))\n      inner-type)))\n\n;; For most purposes, `:lib.type-of/type-is-temporal-type-of-first-arg` is the same as\n;; `:lib.type-of/type-is-type-of-first-arg`. In particular, for the unambiguous `lib.metadata.calculation/type-of`, they\n;; are identical. They only differ when there's a set of possibilities in `lib.schema.expression/type-of`.\n(lib.hierarchy/derive :lib.type-of/type-is-temporal-type-of-first-arg :lib.type-of/type-is-type-of-first-arg)\n\n;;; TODO -- we should constrain this so that you can only use a Date unit if expr is a date, etc.\n(doseq [op [:datetime-add :datetime-subtract]]\n  (mbql-clause/define-tuple-mbql-clause op\n    #_expr   [:ref ::expression/temporal]\n    #_amount :int\n    #_unit   [:ref ::temporal-bucketing/unit.date-time.interval])\n  (lib.hierarchy/derive op :lib.type-of/type-is-temporal-type-of-first-arg))\n\n(doseq [op [:get-year :get-month :get-day :get-hour :get-minute :get-second :get-quarter]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Integer\n    [:schema [:ref ::expression/temporal]]))\n\n(mbql-clause/define-tuple-mbql-clause :datetime-diff :- :type/Integer\n  #_:datetime1 [:schema [:ref ::expression/temporal]]\n  #_:datetime2 [:schema [:ref ::expression/temporal]]\n  #_:unit [:ref ::temporal-bucketing/unit.date-time.truncate])\n\n(doseq [temporal-extract-op #{:get-second :get-minute :get-hour\n                              :get-day :get-day-of-week\n                              :get-month :get-quarter :get-year}]\n  (mbql-clause/define-tuple-mbql-clause temporal-extract-op :- :type/Integer\n    #_:datetime [:schema [:ref ::expression/temporal]]))\n\n(mr/def ::get-week-mode\n  [:enum :iso :us :instance])\n\n(mbql-clause/define-catn-mbql-clause :get-week :- :type/Integer\n  [:datetime [:schema [:ref ::expression/temporal]]]\n  ;; TODO : the mode should probably go in the options map in modern MBQL rather than have it be a separate positional\n  ;; argument. But we can't refactor everything in one go, so that will have to be a future refactor.\n  [:mode     [:? [:schema [:ref ::get-week-mode]]]])\n\n(mr/def ::timezone-id\n  [:and\n   ::common/non-blank-string\n   (into [:enum\n          {:error/message \"valid timezone ID\"\n           :error/fn      (fn [{:keys [value]} _]\n                            (str \"invalid timezone ID: \" (pr-str value)))}]\n         (sort\n          #?( ;; 600 timezones on java 17\n             :clj (ZoneId/getAvailableZoneIds)\n             ;; 596 timezones on moment-timezone 0.5.38\n             :cljs (.names (.-tz moment)))))])\n\n(mbql-clause/define-catn-mbql-clause :convert-timezone\n  [:datetime [:schema [:ref ::expression/temporal]]]\n  [:target   [:schema [:ref ::timezone-id]]]\n  [:source   [:? [:schema [:ref ::timezone-id]]]])\n\n(lib.hierarchy/derive :convert-timezone :lib.type-of/type-is-temporal-type-of-first-arg)\n\n(mbql-clause/define-tuple-mbql-clause :now :- :type/DateTimeWithTZ)\n\n;;; if `:absolute-datetime` has `:base-type` in options, it must either derive from `:type/Date` or `:type/DateTime`.\n;;; TODO -- we should do additional validation here and make sure the unit/value agree with base-type when it's\n;;; present.\n(mr/def ::absolute-datetime.base-type\n  [:and\n   [:ref ::common/base-type]\n   [:fn\n    {:error/message \":absolute-datetime base-type must derive from :type/Date or :type/DateTime\"}\n    (fn [base-type]\n      (some #(isa? base-type %)\n            [:type/Date\n             :type/DateTime]))]])\n\n(mr/def ::absolute-datetime.options\n  [:merge\n   [:ref ::common/options]\n   [:map\n    [:base-type {:optional true} [:ref ::absolute-datetime.base-type]]]])\n\n(mbql-clause/define-mbql-clause :absolute-datetime\n  [:cat\n   {:error/message \"valid :absolute-datetime clause\"}\n   [:= :absolute-datetime]\n   [:schema [:ref ::absolute-datetime.options]]\n   [:alt\n    [:cat\n     {:error/message \":absolute-datetime literal and unit for :type/Date\"}\n     [:schema [:or\n               [:ref ::literal/date]\n               ;; absolute datetime also allows `year-month` and `year` literals.\n               [:ref ::literal/string.year-month]\n               [:ref ::literal/string.year]]]\n     [:schema [:or\n               [:= :default]\n               [:ref ::temporal-bucketing/unit.date]]]]\n    [:cat\n     {:error/message \":absolute-datetime literal and unit for :type/DateTime\"}\n     [:schema [:or\n               [:= :current]\n               [:ref ::literal/datetime]]]\n     [:schema [:or\n               [:= :default]\n               [:ref ::temporal-bucketing/unit.date-time]]]]]])\n\n(defmethod expression/type-of-method :absolute-datetime\n  [[_tag _opts value unit]]\n  (or\n   ;; if value is `:current`, then infer the type based on the unit. Date unit = `:type/Date`. Anything else =\n   ;; `:type/DateTime`.\n   (when (= value :current)\n     (cond\n       (= unit :default)                                 :type/DateTime\n       (mc/validate ::temporal-bucketing/unit.date unit) :type/Date\n       :else                                             :type/DateTime))\n   ;; handle year-month and year string regexes, which are not allowed as date literals unless wrapped in\n   ;; `:absolute-datetime`.\n   (when (string? value)\n     (cond\n       (re-matches literal/year-month-regex value) :type/Date\n       (re-matches literal/year-regex value)       :type/Date))\n   ;; for things that return a union of types like string literals, only the temporal types make sense, so filter out\n   ;; everything else.\n   (let [value-type (expression/type-of value)\n         value-type (if (set? value-type)\n                      (into #{} (filter #(isa? % :type/Temporal)) value-type)\n                      value-type)]\n     (if (and (set? value-type)\n              (= (count value-type) 1))\n       (first value-type)\n       value-type))))\n\n(mr/def ::relative-datetime.amount\n  [:or\n   [:= :current]\n   :int])\n\n(mbql-clause/define-catn-mbql-clause :relative-datetime :- :type/DateTime\n  [:n    [:schema [:ref ::relative-datetime.amount]]]\n  [:unit [:? [:schema [:ref ::temporal-bucketing/unit.date-time.interval]]]])\n\n(mbql-clause/define-tuple-mbql-clause :time :- :type/Time\n  #_:timestr [:schema [:ref ::expression/string]]\n  #_:unit [:ref ::temporal-bucketing/unit.time.interval])\n\n(mr/def ::temporal-extract.unit\n  [:enum\n   :year-of-era\n   :quarter-of-year\n   :month-of-year\n   :week-of-year-iso\n   :week-of-year-us\n   :week-of-year-instance\n   :day-of-month\n   :day-of-week\n   :hour-of-day\n   :minute-of-hour\n   :second-of-minute])\n\n(mr/def ::temporal-extract.week-mode\n  [:enum :iso :us :instance])\n\n;;; TODO -- this should make sure unit agrees with the type of expression we're extracting from.\n(mbql-clause/define-catn-mbql-clause :temporal-extract :- :type/Integer\n  [:datetime [:schema [:ref ::expression/temporal]]]\n  [:unit     [:schema [:ref ::temporal-extract.unit]]]\n  [:mode     [:? [:schema [:ref ::temporal-extract.week-mode]]]])\n"]}