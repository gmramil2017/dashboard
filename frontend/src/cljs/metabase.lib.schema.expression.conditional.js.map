{"version":3,"sources":["metabase/lib/schema/expression/conditional.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;;;;8DAAA,9DAAOA,oIAGJC,EAAEC;AAHL,AAIE,GACE,MAAA,LAAMD;AACNC;;AAFF,GAKE,EAAI,+CAAA,/CAACC,6CAAEF,uIACH,+CAAA,/CAACE,6CAAED;AANT;;AAAA,GAUE,EAAK,cAAAE,bAAUH,qCACV,cAAAG,bAAUF;AACf,OAACG,6CAAoCJ,EAAEC;;AAZzC,GAiBE,cAAAE,bAAUH;AACVA;;AAlBF,GAoBE,cAAAG,bAAUF;AACVA;;AArBF,AA2BE,IAAAI,mBAAI,iBAAAC,qBAAwB,AAACE,oBAAU,AAACC,uDAAiBT,EAAEC;AAAvD,AAAA,oBAAAK;AAAA,AAAA,mBAAAA,fAAWC;AAAX,AACE,GAAI,2EAAA,3EAACL,6CAAE,AAACQ,gBAAMH;AACZ,OAACI,gBAAMJ;;AACPA;;;AAHJ;;;AAAJ,AAAA,oBAAAF;AAAAA;;AAII,OAACO,gDAAUZ,EAAEC;;;;;;;;;AAGrB,AAAAY,4CAAA,4JAAA,mFAAA,uDAAA,2CAAA,oEAAA,uCAAA,mFAAA,mDAAA,+HAAA,mFAAA,mDAAA;AAOA,6FAAA,uGAAA,mFAAA,0EAAA,mFAAA,kEAAA,2CAAA,kDAAA,YAAA,mFAAA,mDAAA,oLAAA,mFAAA,4DAAA,mFAAA,gDAAA,mFAAA,0DAAA,mFAAA,mDAAA,97CAACC;AAKD,AAAAC,0FAAA,qDAAA,WAAAC;AAAA,AAAA,IAAAC,aAAAD;WAAA,AAAAE,4CAAAD,WAAA,IAAA,lEACIE;YADJ,AAAAD,4CAAAD,WAAA,IAAA,nEACSG;sBADT,AAAAF,4CAAAD,WAAA,IAAA,7EACeI;eADf,AAAAH,4CAAAD,WAAA,IAAA,tEAC+BK;AAD/B,AAEE,OAACC,+CACA,sBAAAC,XAAKE;AAAL,AAAA,IAAAD,aAAAD;YAAA,AAAAN,4CAAAO,WAAA,IAAA,nEAAiBE;WAAjB,AAAAT,4CAAAO,WAAA,IAAA,lEAAuBG;AAAvB,AACE,IAAMC,YAAU,AAACC,uCAAmBF;AAApC,AACE,OAAC7B,4DAAiB2B,WAAWG;GACjC,2BAAA,iDAAA,1EAAM,GAAA,aAAA,ZAAOP,qBACX,AAACQ,uCAAmBR,gBACtBD;;AAGH,6FAAA,8GAAA,mFAAA,uDAAA,mFAAA,wDAAA,2CAAA,kDAAA,YAAA,mFAAA,0DAAA,mFAAA,mDAAA,51BAACP;AAGD,AAAAC,0FAAA,4DAAA,WAAAgB;AAAA,AAAA,IAAAC,aAAAD;IAAAE,aAAA,AAAAC,cAAAF;IAAAG,eAAA,AAAAxB,gBAAAsB;IAAAA,iBAAA,AAAAG,eAAAH;WAAAE,PACIhB;IADJgB,mBAAA,AAAAxB,gBAAAsB;IAAAA,iBAAA,AAAAG,eAAAH;YAAAE,RACSf;YADTa,RACiBI;AADjB,AAGE,OAACd,+CAAOxB,4DACA,AAACuC,4CAAIR,uCAAmBO","names":["metabase.lib.schema.expression.conditional/best-return-type","x","y","cljs.core._EQ_","cljs.core/Keyword","metabase.types/most-specific-common-ancestor","or__5045__auto__","temp__5804__auto__","intersection","cljs.core/not-empty","clojure.set.intersection","cljs.core/count","cljs.core/first","clojure.set.union","metabase.util.malli.registry/register!","metabase.lib.schema.mbql_clause.define_catn_mbql_clause","metabase.lib.schema.expression/type-of-method","p__60565","vec__60566","cljs.core.nth","_tag","_opts","pred-expr-pairs","default","cljs.core.reduce","p__60569","vec__60570","best-guess","_pred","expr","expr-type","metabase.lib.schema.expression/type-of","p__60577","vec__60578","seq__60579","cljs.core/seq","first__60580","cljs.core/next","exprs","cljs.core.map"],"sourcesContent":["(ns metabase.lib.schema.expression.conditional\n  \"Conditional expressions like `:case` and `:coalesce`.\"\n  (:require\n   [clojure.set :as set]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.types :as types]\n   [metabase.util.malli.registry :as mr]\n   ))\n\n;;; the logic for calculating the return type of a `:case` or similar statement is not optimal nor perfect. But it\n;;; should be ok for now and errors on the side of being permissive. See this Slack thread for more info:\n;;; https://metaboat.slack.com/archives/C04DN5VRQM6/p1678325996901389\n(defn- best-return-type\n  \"For expressions like `:case` and `:coalesce` that can return different possible expressions, determine the best\n  return type given all of the various options.\"\n  [x y]\n  (cond\n    (nil? x)\n    y\n\n    ;; if the type of either x or y is unknown, then the overall type of this has to be unknown as well.\n    (or (= x ::expression/type.unknown)\n        (= y ::expression/type.unknown))\n    ::expression/type.unknown\n\n    ;; if both types are keywords return their most-specific ancestor.\n    (and (keyword? x)\n         (keyword? y))\n    (types/most-specific-common-ancestor x y)\n\n    ;; if one type is a specific type but the other is an ambiguous union of possible types, return the specific\n    ;; type. A case can't possibly have multiple different return types, so if one expression has an unambiguous\n    ;; type then the whole thing has to have a compatible type.\n    (keyword? x)\n    x\n\n    (keyword? y)\n    y\n\n    ;; if both types are ambiguous unions of possible types then return the intersection of the two. But if the\n    ;; intersection is empty, return the union of everything instead. I don't really want to go down a rabbit\n    ;; hole of trying to find the intersection between the most-specific common ancestors\n    :else\n    (or (when-let [intersection (not-empty (set/intersection x y))]\n          (if (= (count intersection) 1)\n            (first intersection)\n            intersection))\n        (set/union x y))))\n\n;;; believe it or not, a `:case` clause really has the syntax [:case {} [[pred1 expr1] [pred2 expr2] ...]]\n(mr/def ::case-subclause\n  [:tuple\n   {:error/message \"Valid :case [pred expr] pair\"}\n   #_pred [:ref ::expression/boolean]\n   #_expr [:ref ::expression/expression]])\n\n\n(mbql-clause/define-catn-mbql-clause :case\n  ;; TODO -- we should further constrain this so all of the exprs are of the same type\n  [:pred-expr-pairs [:sequential {:min 1} [:ref ::case-subclause]]]\n  [:default [:? [:schema [:ref ::expression/expression]]]])\n\n(defmethod expression/type-of-method :case\n  [[_tag _opts pred-expr-pairs default]]\n  (reduce\n   (fn [best-guess [_pred expr]]\n     (let [expr-type (expression/type-of expr)]\n       (best-return-type best-guess expr-type)))\n   (when (some? default)\n     (expression/type-of default))\n   pred-expr-pairs))\n\n;;; TODO -- add constraint that these types have to be compatible\n(mbql-clause/define-catn-mbql-clause :coalesce\n  [:exprs [:repeat {:min 2} [:schema [:ref ::expression/expression]]]])\n\n(defmethod expression/type-of-method :coalesce\n  [[_tag _opts & exprs]]\n  #_{:clj-kondo/ignore [:reduce-without-init]}\n  (reduce best-return-type\n          (map expression/type-of exprs)))\n"]}