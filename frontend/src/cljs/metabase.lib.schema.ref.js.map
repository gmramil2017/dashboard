{"version":3,"sources":["metabase/lib/schema/ref.cljc"],"mappings":"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","names":["metabase.util.malli.registry/register!","metabase.lib.schema.mbql_clause.define_mbql_clause","clause","cljs.core/sequential?","vec__62674","cljs.core.nth","_field","_opts","id-or-name","metabase.lib.dispatch/dispatch-value","metabase.lib.hierarchy/derive","metabase.lib.schema.expression/type-of-method","p__62681","vec__62682","_tag","opts","_id-or-name","or__5045__auto__","cljs.core.some_fn","metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","p__62685","vec__62686","_expression-name","p__62689","vec__62690","_index","_","clojure.string.join","cljs.core.sort","cljs.core/deref","cljs.core.descendants","metabase.lib.hierarchy/hierarchy","p__62693","vec__62694","tag","_clause","metabase.lib.hierarchy/isa?"],"sourcesContent":["(ns metabase.lib.schema.ref\n  \"Malli schema for a Field, aggregation, or expression reference (etc.)\"\n  (:require\n   [clojure.string :as str]\n   [metabase.lib.dispatch :as lib.dispatch]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.id :as id]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.types]\n   [metabase.util.malli.registry :as mr]))\n\n(comment metabase.types/keep-me)\n\n(mr/def ::field.options\n  [:merge\n   ::common/options\n   [:map\n    [:temporal-unit {:optional true} ::temporal-bucketing/unit]]])\n\n(mr/def ::field.literal.options\n  [:merge\n   ::field.options\n   [:map\n    [:base-type ::common/base-type]]])\n\n;;; `:field` clause\n(mr/def ::field.literal\n  [:tuple\n   [:= :field]\n   ::field.literal.options\n   ::common/non-blank-string])\n\n(mr/def ::field.id\n  [:tuple\n   [:= :field]\n   ::field.options ; TODO -- we should make `:base-type` required here too\n   ::id/field])\n\n(mbql-clause/define-mbql-clause :field\n  [:and\n   [:tuple\n    [:= :field]\n    ::field.options\n    [:or ::id/field ::common/non-blank-string]]\n   [:multi {:dispatch      (fn [clause]\n                             ;; apparently it still tries to dispatch when humanizing errors even if the `:tuple`\n                             ;; schema above failed, so we need to check that this is actually a tuple here again.\n                             (when (sequential? clause)\n                               (let [[_field _opts id-or-name] clause]\n                                 (lib.dispatch/dispatch-value id-or-name))))\n            ;; without this it gives us dumb messages like \"Invalid dispatch value\" if the dispatch function above\n            ;; doesn't return something that matches.\n            :error/message \"Invalid :field clause ID or name: must be a string or integer\"}\n    [:dispatch-type/integer ::field.id]\n    [:dispatch-type/string ::field.literal]]])\n\n(lib.hierarchy/derive :field ::ref)\n\n(defmethod expression/type-of-method :field\n  [[_tag opts _id-or-name]]\n  (or ((some-fn :effective-type :base-type) opts)\n      ::expression/type.unknown))\n\n(mbql-clause/define-tuple-mbql-clause :expression\n  ::common/non-blank-string)\n\n(defmethod expression/type-of-method :expression\n  [[_tag opts _expression-name]]\n  (or ((some-fn :effective-type :base-type) opts)\n      ::expression/type.unknown))\n\n(lib.hierarchy/derive :expression ::ref)\n\n(mr/def ::aggregation-options\n  [:merge\n   ::common/options\n   [:map\n    [:name {:optional true} ::common/non-blank-string]\n    [:display-name {:optional true} ::common/non-blank-string]]])\n\n(mbql-clause/define-mbql-clause :aggregation\n  [:tuple\n   [:= :aggregation]\n   ::aggregation-options\n   :string])\n\n(defmethod expression/type-of-method :aggregation\n  [[_tag opts _index]]\n  (or ((some-fn :effective-type :base-type) opts)\n      ::expression/type.unknown))\n\n(lib.hierarchy/derive :aggregation ::ref)\n\n(mbql-clause/define-tuple-mbql-clause :metric :- ::expression/type.unknown\n  #_metric-id [:schema [:ref ::id/metric]])\n\n(lib.hierarchy/derive :metric ::ref)\n\n(mr/def ::ref\n  [:and\n   ::mbql-clause/clause\n   [:fn\n    {:error/fn (fn [_ _]\n                 (str \"Valid reference, must be one of these clauses: \"\n                      (str/join \", \" (sort (descendants @lib.hierarchy/hierarchy ::ref)))))}\n    (fn [[tag :as _clause]]\n      (lib.hierarchy/isa? tag ::ref))]])\n"]}