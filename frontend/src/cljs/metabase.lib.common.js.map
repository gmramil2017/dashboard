{"version":3,"sources":["metabase/lib/common.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA,AAGA;;;;;;;kCAAA,0CAAAA,5EAASG;AAAT,AAAA,IAAAF,aAAAD;eAAA,AAAAE,4CAAAD,WAAA,IAAA,tEAEIG;cAFJ,AAAAF,4CAAAD,WAAA,IAAA,rEAEaI;aAFbJ,TAEyBK;AAFzB,AAAA;AAGE,oBAAMA;AAAN,AAAA,kDAAA,0DAAA,yEAAA,8DAEa,iBAAAC,WAAQH;AAAR,AAAA,GACE,qBAAAI,pBAAUJ;AADZ,sBAAAG,fACsBE;;AADtBF;;KAFb,iEAAA,RAIaF,6DACA,sDAAA,tDAACK,+CAAOJ;;AALrB;;;AAOF,GAAA,QAAAK,qCAAAC,yCAAAC,gDAAAC;AAAA;AAAA,AAAA;;;kCAAA,iBAAAC,6BAAA,AAAAC,6CAAA,7HAAUS;IAAVR,6BAAA,AAAAD,6CAAA;IAAAE,6BAAA,AAAAF,6CAAA;IAAAG,iCAAA,AAAAH,6CAAA;IAAAI,0BAAA,AAAAC,4CAAA,2CAAA,yGAAA,gEAAA,iBAAAC,eAAA,zIAIaK;AAJb,AAAA,QAAAL,6CAAAA,+CAAAA;;AAAA,AAAA,YAAAC,kBAAA,AAAAC,+CAAA,sBAAA,iDAAA,4DAAAJ,wBAAAL,2BAAAE,2BAAAC,2BAAAC,1MAGEO;;;AAGF,AAAAD,4EAAA,4DAAA,WACGG;AADH,AAEE,GAAI,EAAK,AAACC,wBAAQD,QACT,+BAAApB,9BAAU,AAACsB,gBAAMF;AAExB,OAACG,6CAAKN,gCAASG;;AAEfA;;;AAEJ,AAAAH,4EAAA,0FAAA,WACGO;AADH,AAEE,OAACD,6CAAKN,gCAASO;;AAEjB,AAAAP,4EAAA,yEAAA,WACGQ;AADH,AAEE,OAACC,qBAAYD;;AAEf,AAAAR,4EAAA,uEAAA,WACGU;AADH,AAEE,OAACD,qBAAYC;;AAEf,AAAAV,4EAAA,yEAAA,WAAAW;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;eAAA,AAAAhB,4CAAAgB,eAAA,tEACWjC;cADX,AAAAiB,4CAAAgB,eAAA,yDAAA,9HACoBhC;WADpB,AAAAgB,4CAAAgB,eAAA,lEAC4BE;AAD5B,AAEE,OAACd,8DAAS,AAACe,iCAAwB,6CAAA,7CAACC,gIAAM,AAACC,gDAAQtC,UAAUC,gBACpB,AAACsC,4CAAIlB,iCACLc;;AAE3C;;;mCAAA,nCAAMK,8EAEHC,QAAQN;AAFX,AAGE,oDAAA,2FAAA,2CAAA,nLAACE,gIAAMI,8GAAmB,4CAAK,AAACC,yCAC1B,AAACH,4CAAIlB,iCACLc","names":["p__63442","vec__63444","cljs.core.nth","metabase.lib.common/external-op","operator","options","clause","G__63447","cljs.core/Keyword","cljs.core/name","cljs.core.subvec","js/metabase","js/metabase.lib","js/metabase.lib.common","js/metabase.lib.common.->op-arg","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","cljs.core.get","fexpr__63451","cljs.core/MultiFn","cljs.core.symbol","metabase.lib.common/->op-arg","metabase.lib.dispatch/dispatch-value","metabase.lib.hierarchy/hierarchy","x","cljs.core/vector?","cljs.core/first","cljs.core.mapv","xs","field-metadata","metabase.lib.ref/ref","metric-def","p__63455","map__63456","cljs.core/--destructure-map","args","metabase.lib.options/ensure-uuid","cljs.core.into","cljs.core.keyword","cljs.core.map","metabase.lib.common/defop-create","op-name","cljs.core/random-uuid"],"sourcesContent":["(ns metabase.lib.common\n  (:require\n   [metabase.lib.dispatch :as lib.dispatch]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.ref :as lib.ref]\n   [metabase.lib.schema.common :as schema.common]\n   [metabase.util.malli :as mu])\n  #?(:cljs (:require-macros [metabase.lib.common])))\n\n(comment lib.options/keep-me\n         mu/keep-me)\n\n(mu/defn external-op :- [:maybe ::schema.common/external-op]\n  \"Convert the internal operator `clause` to the external format.\"\n  [[operator options :as clause]]\n  (when clause\n    {:lib/type :lib/external-op\n     :operator (cond-> operator\n                 (keyword? operator) name)\n     :options  options\n     :args     (subvec clause 2)}))\n\n(defmulti ->op-arg\n  \"Ensures that clause arguments are properly unwrapped\"\n  {:arglists '([x])}\n  lib.dispatch/dispatch-value\n  :hierarchy lib.hierarchy/hierarchy)\n\n(defmethod ->op-arg :default\n  [x]\n  (if (and (vector? x)\n           (keyword? (first x)))\n    ;; MBQL clause\n    (mapv ->op-arg x)\n    ;; Something else - just return it\n    x))\n\n(defmethod ->op-arg :dispatch-type/sequential\n  [xs]\n  (mapv ->op-arg xs))\n\n(defmethod ->op-arg :metadata/column\n  [field-metadata]\n  (lib.ref/ref field-metadata))\n\n(defmethod ->op-arg :metadata/metric\n  [metric-def]\n  (lib.ref/ref metric-def))\n\n(defmethod ->op-arg :lib/external-op\n  [{:keys [operator options args] :or {options {}}}]\n  (->op-arg (lib.options/ensure-uuid (into [(keyword operator) options]\n                                           (map ->op-arg)\n                                           args))))\n\n(defn defop-create\n  \"Impl for [[defop]].\"\n  [op-name args]\n  (into [op-name {:lib/uuid (str (random-uuid))}]\n        (map ->op-arg)\n        args))\n\n#?(:clj\n   (defmacro defop\n     \"Defines a clause creating function with given args.\n      Calling the clause without query and stage produces a fn that can be resolved later.\"\n     [op-name & argvecs]\n     {:pre [(symbol? op-name)\n            (every? vector? argvecs) (every? #(every? symbol? %) argvecs)\n            (every? #(not-any? #{'query 'stage-number} %) argvecs)]}\n     `(mu/defn ~op-name :- ~(keyword \"mbql.clause\" (name op-name))\n        ~(format \"Create a standalone clause of type `%s`.\" (name op-name))\n        ~@(for [argvec argvecs\n                :let [arglist-expr (if (contains? (set argvec) '&)\n                                     (cons `list* (remove #{'&} argvec))\n                                     argvec)]]\n            `([~@argvec]\n              (defop-create ~(keyword op-name) ~arglist-expr))))))\n"]}