{"version":3,"sources":["metabase/lib/metadata.cljc"],"mappings":"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","names":["metabase.util.malli.registry/register!","metabase.lib.metadata/ColumnMetadata","metabase.lib.metadata/CardMetadata","metabase.lib.metadata/SegmentMetadata","metabase.lib.metadata/MetricMetadata","metabase.lib.metadata/TableMetadata","metabase.lib.metadata/DatabaseMetadata","metabase.lib.metadata.protocols/metadata-provider?","metabase.lib.metadata/MetadataProvider","metabase.lib.metadata/MetadataProviderable","metabase.lib.metadata/->metadata-provider","metadata-providerable","metabase.lib.metadata/database","metabase.lib.metadata.protocols/database","metabase.lib.metadata/tables","metabase.lib.metadata.protocols/tables","metabase.lib.metadata/table","table-id","metabase.lib.metadata.protocols/table","metabase.lib.metadata/fields","metabase.lib.metadata.protocols/fields","metabase.lib.metadata/field","field-id","metabase.lib.metadata.protocols/field","metabase.lib.metadata/StageMetadata","metabase.lib.metadata/stage","query","stage-number","metabase.lib.util/query-stage","var_args","G__64845","metabase.lib.metadata/stage-column","js/Error","column-name","metabase.lib.metadata.stage_column","cljs.core/some","column","cljs.core._EQ_","metabase.lib.metadata/card","card-id","metabase.lib.metadata.protocols/card","metabase.lib.metadata/segment","segment-id","metabase.lib.metadata.protocols/segment","metabase.lib.metadata/metric","metric-id","metabase.lib.metadata.protocols/metric","metabase.lib.metadata/table-or-card","temp__5802__auto__","metabase.lib.util/legacy-string-table-id->card-id"],"sourcesContent":["(ns metabase.lib.metadata\n  (:require\n   [metabase.lib.metadata.protocols :as lib.metadata.protocols]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.id :as lib.schema.id]\n   [metabase.lib.util :as lib.util]\n   [metabase.util.malli :as mu]\n   [metabase.util.malli.registry :as mr]))\n\n;;; Column vs Field?\n;;;\n;;; Lately I've been using `Field` to only mean a something that lives in the application database, i.e. something\n;;; that is associated with row in the `Field` table and has an `:id`. I'm using `Column` as a more generic term that\n;;; includes not only `Field`s but also the columns returned by a stage of a query, e.g. `SELECT count(*) AS count`\n;;; returns a `Column` called `count`, but it's not a `Field` because it's not associated with an actual Field in the\n;;; application database.\n;;;\n;;; Column = any column returned by a query or stage of a query\n;;; Field  = a Column that is associated with a capital-F Field in the application database, i.e. has an `:id`\n;;;\n;;; All Fields are Columns, but not all Columns are Fields.\n;;;\n;;; Also worth a mention: we also have `Dimension`s, associated with the `dimension` table in the application\n;;; database, which can act like psuedo-Fields or affect how we treat normal Fields. For example, Dimensions are used\n;;; to implement column remapping, e.g. the GUI might display values of `categories.name` when it presents filter\n;;; options for `venues.category_id` -- you can remap a meaningless integer FK column to something more helpful.\n;;; 'Human readable values' like these can also be entered manually from the GUI, for example for enum columns. How\n;;; will this affect what MLv2 needs to know or does? Not clear at this point, but we'll probably want to abstract\n;;; away dealing with Dimensions in the future so the FE QB GUI doesn't need to special case them.\n\n(mr/def ::column-source\n  [:enum\n   ;; these are for things from some sort of source other than the current stage;\n   ;; they must be referenced with string names rather than Field IDs\n   :source/card\n   :source/native\n   :source/previous-stage\n   ;; these are for things that were introduced by the current stage of the query; `:field` references should be\n   ;; referenced with Field IDs if available.\n   ;;\n   ;; default columns returned by the `:source-table` for the current stage.\n   :source/table-defaults\n   ;; specifically introduced by the corresponding top-level clauses.\n   :source/fields\n   :source/aggregations\n   :source/breakouts\n   ;; introduced by a join, not necessarily ultimately returned.\n   :source/joins\n   ;; Introduced by `:expressions`; not necessarily ultimately returned.\n   :source/expressions\n   ;; Not even introduced, but 'visible' because this column is implicitly joinable.\n   :source/implicitly-joinable])\n\n(def ColumnMetadata\n  \"Malli schema for a valid map of column metadata, which can mean one of two things:\n\n  1. Metadata about a particular Field in the application database. This will always have an `:id`\n\n  2. Results metadata from a column in `data.cols` and/or `data.results_metadata.columns` in a Query Processor\n     response, or saved in something like `Card.result_metadata`. These *may* have an `:id`, or may not -- columns\n     coming back from native queries or things like `SELECT count(*)` aren't associated with any particular `Field`\n     and thus will not have an `:id`.\n\n  Now maybe these should be two different schemas, but `:id` being there or not is the only real difference; besides\n  that they are largely compatible. So they're the same for now. We can revisit this in the future if we actually want\n  to differentiate between the two versions.\"\n  [:map\n   {:error/message \"Valid column metadata\"}\n   [:lib/type  [:= :metadata/column]]\n   [:name      ::lib.schema.common/non-blank-string]\n   ;; TODO -- ignore `base_type` and make `effective_type` required; see #29707\n   [:base-type ::lib.schema.common/base-type]\n   [:id             {:optional true} ::lib.schema.id/field]\n   [:display-name   {:optional true} [:maybe ::lib.schema.common/non-blank-string]]\n   [:effective-type {:optional true} [:maybe ::lib.schema.common/base-type]]\n   ;; if this is a field from another table (implicit join), this is the field in the current table that should be\n   ;; used to perform the implicit join. e.g. if current table is `VENUES` and this field is `CATEGORIES.ID`, then the\n   ;; `fk_field_id` would be `VENUES.CATEGORY_ID`. In a `:field` reference this is saved in the options map as\n   ;; `:source-field`.\n   [:fk-field-id    {:optional true} [:maybe ::lib.schema.id/field]]\n   ;; Join alias of the table we're joining against, if any. Not really 100% clear why we would need this on top\n   ;; of [[metabase.lib.join/current-join-alias]], which stores the same info under a namespaced key. I think we can\n   ;; remove it.\n   [:source-alias   {:optional true} [:maybe ::lib.schema.common/non-blank-string]]\n   ;; what top-level clause in the query this metadata originated from, if it is calculated (i.e., if this metadata\n   ;; was generated by [[metabase.lib.metadata.calculation/metadata]])\n   [:lib/source     {:optional true} [:ref ::column-source]]\n   ;;\n   ;; this stuff is adapted from [[metabase.query-processor.util.add-alias-info]]. It is included in\n   ;; the [[metabase.lib.metadata.calculation/metadata]]\n   ;;\n   ;; the alias that should be used to this clause on the LHS of a `SELECT <lhs> AS <rhs>` or equivalent, i.e. the\n   ;; name of this clause as exported by the previous stage, source table, or join.\n   [:lib/source-column-alias {:optional true} [:maybe ::lib.schema.common/non-blank-string]]\n   ;; the name we should export this column as, i.e. the RHS of a `SELECT <lhs> AS <rhs>` or equivalent. This is\n   ;; guaranteed to be unique in each stage of the query.\n   [:lib/desired-column-alias {:optional true} [:maybe [:string {:min 1, :max 60}]]]\n   ;; when column metadata is returned by certain things\n   ;; like [[metabase.lib.aggregation/selected-aggregation-operators]] or [[metabase.lib.field/fieldable-columns]], it\n   ;; might include this key, which tells you whether or not that column is currently selected or not already, e.g.\n   ;; for [[metabase.lib.field/fieldable-columns]] it means its already present in `:fields`\n   [:selected? {:optional true} :boolean]])\n\n(def CardMetadata\n  \"Schema for metadata about a specific Saved Question (which may or may not be a Model). More or less the same as\n  a [[metabase.models.card]], but with kebab-case keys. Note that the `:dataset-query` is not necessarily converted to\n  pMBQL yet. Probably safe to assume it is normalized however. Likewise, `:result-metadata` is probably not quite\n  massaged into a sequence of `ColumnMetadata`s just yet. See [[metabase.lib.card/card-metadata-columns]] that\n  converts these as needed.\"\n  [:map\n   {:error/message \"Valid Card metadata\"}\n   [:lib/type [:= :metadata/card]]\n   [:id   ::lib.schema.id/card]\n   [:name ::lib.schema.common/non-blank-string]\n   ;; saved query. This is possibly still a legacy query, but should already be normalized.\n   ;; Call [[metabase.lib.convert/->pMBQL]] on it as needed\n   [:dataset-query   {:optional true} :map]\n   ;; vector of column metadata maps; these are ALMOST the correct shape to be [[ColumnMetadata]], but they're\n   ;; probably missing `:lib/type` and probably using `:snake_case` keys.\n   [:result-metadata {:optional true} [:maybe [:sequential :map]]]\n   ;; whether this Card is a Model or not.\n   [:dataset         {:optional true} :boolean]\n   ;; I think Database ID is always supposed to be present for a Card, altho our mock metadata in tests might not have\n   ;; it. It's `NOT NULL` in the application database. Probably safe to generally assume it's there.\n   ;;\n   ;; TODO -- confirm whether we can make this non-optional in the schema or not.\n   [:database-id     {:optional true} [:maybe ::lib.schema.id/database]]\n   ;; Table ID is nullable in the application database, because native queries are not necessarily associated with a\n   ;; particular Table (unless they are against MongoDB)... for MBQL queries it should be populated however.\n   [:table-id        {:optional true} [:maybe ::lib.schema.id/table]]])\n\n(def SegmentMetadata\n  \"More or less the same as a [[metabase.models.segment]], but with kebab-case keys.\"\n  [:map\n   {:error/message \"Valid Segment metadata\"}\n   [:lib/type [:= :metadata/segment]]\n   [:id       ::lib.schema.id/segment]\n   [:name     ::lib.schema.common/non-blank-string]])\n\n(def MetricMetadata\n  \"Malli schema for a legacy v1 [[metabase.models.metric]], but with kebab-case keys. A Metric defines an MBQL snippet\n  with an aggregation and optionally a filter clause. You can add a `:metric` reference to the `:aggregations` in an\n  MBQL stage, and the QP treats it like a macro and expands it to the underlying clauses --\n  see [[metabase.query-processor.middleware.expand-macros]].\"\n  [:map\n   {:error/message \"Valid Metric metadata\"}\n   [:lib/type   [:= :metadata/metric]]\n   [:id         ::lib.schema.id/metric]\n   [:name       ::lib.schema.common/non-blank-string]\n   [:table-id   ::lib.schema.id/table]\n   ;; the MBQL snippet defining this Metric; this may still be in legacy\n   ;; format. [[metabase.lib.metric/metric-definition]] handles conversion to pMBQL if needed.\n   [:definition :map]\n   [:description {:optional true} [:maybe ::lib.schema.common/non-blank-string]]])\n\n(def TableMetadata\n  \"Schema for metadata about a specific [[metabase.models.table]]. More or less the same as a [[metabase.models.table]],\n  but with kebab-case keys.\"\n  [:map\n   {:error/message \"Valid Table metadata\"}\n   [:lib/type [:= :metadata/table]]\n   [:id       ::lib.schema.id/table]\n   [:name     ::lib.schema.common/non-blank-string]\n   [:display-name {:optional true} [:maybe ::lib.schema.common/non-blank-string]]\n   [:schema       {:optional true} [:maybe ::lib.schema.common/non-blank-string]]])\n\n(def DatabaseMetadata\n  \"Malli schema for the DatabaseMetadata as returned by `GET /api/database/:id/metadata` -- what should be available to\n  the frontend Query Builder.\"\n  [:map\n   {:error/message \"Valid Database metadata\"}\n   [:lib/type [:= :metadata/database]]\n   [:id ::lib.schema.id/database]\n   ;; Like `:fields` for [[TableMetadata]], this is now optional -- we can fetch the Tables separately if needed.\n   [:tables   {:optional true} [:sequential TableMetadata]]\n   ;; TODO -- this should validate against the driver features list in [[metabase.driver/driver-features]] if we're in\n   ;; Clj mode\n   [:features {:optional true} [:set :keyword]]])\n\n(def MetadataProvider\n  \"Schema for something that satisfies the [[lib.metadata.protocols/MetadataProvider]] protocol.\"\n  [:fn\n   {:error/message \"Valid MetadataProvider\"}\n   #'lib.metadata.protocols/metadata-provider?])\n\n(def MetadataProviderable\n  \"Something that can be used to get a MetadataProvider. Either a MetadataProvider, or a map with a MetadataProvider in\n  the key `:lib/metadata` (i.e., a query).\"\n  [:or\n   MetadataProvider\n   [:map\n    {:error/message \"map with a MetadataProvider in the key :lib/metadata (i.e. a query)\"}\n    [:lib/metadata MetadataProvider]]])\n\n(mu/defn ->metadata-provider :- MetadataProvider\n  \"Get a MetadataProvider from something that can provide one.\"\n  [metadata-providerable :- MetadataProviderable]\n  (if (lib.metadata.protocols/metadata-provider? metadata-providerable)\n    metadata-providerable\n    (:lib/metadata metadata-providerable)))\n\n(mu/defn database :- DatabaseMetadata\n  \"Get metadata about the Database we're querying.\"\n  [metadata-providerable :- MetadataProviderable]\n  (lib.metadata.protocols/database (->metadata-provider metadata-providerable)))\n\n(mu/defn tables :- [:sequential TableMetadata]\n  \"Get metadata about all Tables for the Database we're querying.\"\n  [metadata-providerable :- MetadataProviderable]\n  (lib.metadata.protocols/tables (->metadata-provider metadata-providerable)))\n\n(mu/defn table :- TableMetadata\n  \"Find metadata for a specific Table, either by string `table-name`, and optionally `schema`, or by ID.\"\n  [metadata-providerable :- MetadataProviderable\n   table-id              :- ::lib.schema.id/table]\n  (lib.metadata.protocols/table (->metadata-provider metadata-providerable) table-id))\n\n(mu/defn fields :- [:sequential ColumnMetadata]\n  \"Get metadata about all the Fields belonging to a specific Table.\"\n  [metadata-providerable :- MetadataProviderable\n   table-id              :- ::lib.schema.id/table]\n  (lib.metadata.protocols/fields (->metadata-provider metadata-providerable) table-id))\n\n(mu/defn field :- ColumnMetadata\n  \"Get metadata about a specific Field in the Database we're querying.\"\n  [metadata-providerable :- MetadataProviderable\n   field-id              :- ::lib.schema.id/field]\n  (lib.metadata.protocols/field (->metadata-provider metadata-providerable) field-id))\n\n;;;; Stage metadata\n\n(def StageMetadata\n  \"Metadata about the columns returned by a particular stage of a pMBQL query. For example a single-stage native query\n  like\n\n    {:database 1\n     :lib/type :mbql/query\n     :stages   [{:lib/type :mbql.stage/mbql\n                 :native   \\\"SELECT id, name FROM VENUES;\\\"}]}\n\n  might have stage metadata like\n\n    {:columns [{:name \\\"id\\\", :base-type :type/Integer}\n               {:name \\\"name\\\", :base-type :type/Text}]}\n\n  associated with the query's lone stage.\n\n  At some point in the near future we will hopefully attach this metadata directly to each stage in a query, so a\n  multi-stage query will have `:lib/stage-metadata` for each stage. The main goal is to facilitate things like\n  returning lists of visible or filterable columns for a given stage of a query. This is TBD, see #28717 for a WIP\n  implementation of this idea.\n\n  This is the same format as the results metadata returned with QP results in `data.results_metadata`. The `:columns`\n  portion of this (`data.results_metadata.columns`) is also saved as `Card.result_metadata` for Saved Questions.\n\n  Note that queries currently actually come back with both `data.results_metadata` AND `data.cols`; it looks like the\n  Frontend actually *merges* these together -- see `applyMetadataDiff` in\n  `frontend/src/metabase/query_builder/selectors.js` -- but this is ridiculous. Let's try to merge anything missing in\n  `results_metadata` into `cols` going forward so things don't need to be manually merged in the future.\"\n  [:map\n   [:lib/type [:= :metadata/results]]\n   [:columns [:sequential ColumnMetadata]]])\n\n(mu/defn stage :- [:maybe StageMetadata]\n  \"Get metadata associated with a particular `stage-number` of the query, if any. `stage-number` can be a negative\n  index.\n\n  Currently, only returns metadata if it is explicitly attached to a stage; in the future we will probably dynamically\n  calculate this stuff if possible based on DatabaseMetadata and previous stages. Stay tuned!\"\n  [query        :- :map\n   stage-number :- :int]\n  (:lib/stage-metadata (lib.util/query-stage query stage-number)))\n\n(mu/defn stage-column :- [:maybe ColumnMetadata]\n  \"Metadata about a specific column returned by a specific stage of the query, e.g. perhaps the first stage of the\n  query has an expression `num_cans`, then\n\n    (lib.metadata/stage-column query stage \\\"num_cans\\\")\n\n  should return something like\n\n    {:name \\\"num_cans\\\", :base-type :type/Integer, ...}\n\n  This is currently a best-effort thing and will only return information about columns if stage metadata is attached\n  to a particular stage. In the near term future this should be better about calculating that metadata dynamically and\n  returning correct info here.\"\n  ([query       :- :map\n    column-name :- ::lib.schema.common/non-blank-string]\n   (stage-column query -1 column-name))\n\n  ([query        :- :map\n    stage-number :- :int\n    column-name  :- ::lib.schema.common/non-blank-string]\n   (some (fn [column]\n           (when (= (:name column) column-name)\n             column))\n         (:columns (stage query stage-number)))))\n\n(mu/defn card :- [:maybe CardMetadata]\n  \"Get metadata for a Card, aka Saved Question, with `card-id`, if it can be found.\"\n  [metadata-providerable :- MetadataProviderable\n   card-id               :- ::lib.schema.id/card]\n  (lib.metadata.protocols/card (->metadata-provider metadata-providerable) card-id))\n\n(mu/defn segment :- [:maybe SegmentMetadata]\n  \"Get metadata for the Segment with `segment-id`, if it can be found.\"\n  [metadata-providerable :- MetadataProviderable\n   segment-id            :- ::lib.schema.id/segment]\n  (lib.metadata.protocols/segment (->metadata-provider metadata-providerable) segment-id))\n\n(mu/defn metric :- [:maybe MetricMetadata]\n  \"Get metadata for the Metric with `metric-id`, if it can be found.\"\n  [metadata-providerable :- MetadataProviderable\n   metric-id             :- ::lib.schema.id/metric]\n  (lib.metadata.protocols/metric (->metadata-provider metadata-providerable) metric-id))\n\n(mu/defn table-or-card :- [:maybe [:or CardMetadata TableMetadata]]\n  \"Convenience, for frontend JS usage (see #31915): look up metadata based on Table ID, handling legacy-style\n  `card__<id>` strings as well. Throws an Exception (Clj-only, due to Malli validation) if passed an integer Table ID\n  and the Table does not exist, since this is a real error; however if passed a `card__<id>` that does not exist,\n  simply returns `nil` (since we do not have a strict expectation that Cards always be present in the\n  MetadataProvider).\"\n  [metadata-providerable :- MetadataProviderable\n   table-id              :- [:or ::lib.schema.id/table :string]]\n  (if-let [card-id (lib.util/legacy-string-table-id->card-id table-id)]\n    (card metadata-providerable card-id)\n    (table metadata-providerable table-id)))\n"]}