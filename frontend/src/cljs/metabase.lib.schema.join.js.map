{"version":3,"sources":["metabase/lib/schema/join.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuBA,AAAAA,4CAAA,uGAAA,mFAAA,gDAAA,mFAAA,qDAAA,kDAAA,6DAAA,mFAAA,kEAAA,2CAAA,kDAAA,YAAA,mFAAA,mDAAA;AAYA,AAAAA,4CAAA,oGAAA,mFAAA,gDAAA,2CAAA,2DAAA,WAAAC;AAAA,AAEe,oDAAAA,kBAAA,gDAAW,AAACC;WAF3B;AAKA,AAAAF,4CAAA,+GAAA,mFAAA,kEAAA,2CAAA,kDAAA,YAAA,mFAAA,mDAAA;AAQA,AAAAA,4CAAA,4GAAA,mFAAA,qDAAA,+DAAA,gEAAA,gEAAA;AAOA,AAAAA,4CAAA,oGAAA,mFAAA,mDAAA,mFAAA,0DAAA,mFAAA,+CAAA,4EAAA,mFAAA,8DAAA,uHAAA,mFAAA,yDAAA,mFAAA,mDAAA,8GAAA,mFAAA,kEAAA,uHAAA,mFAAA,wDAAA,4GAAA,mFAAA,0DAAA,2CAAA,6DAAA,aAAA,+GAAA,mFAAA,8DAAA,2CAAA,6DAAA,aAAA;AAUA,AAAAA,4CAAA,qGAAA,mFAAA,mDAAA,mFAAA,kEAAA,2CAAA,kDAAA,YAAA,mFAAA,mDAAA,oHAAA,mFAAA,kDAAA,2CAAA,2DAIe;mCAAOG;AAAP,AACE,OAAAC,kCAAA;;;IADKD;;;;EAAAA;;oCAAAA;;;IAAAA;0BAAAA;;;;;SAElB,8DAAgCE;AAAhC,AACE,IAAAC,qBAAiB,AAACE,oBAAU,AAACC,+CAAOC,sBAAM,4CAAA,5CAACC,oGAAWN;AAAtD,AAAA,oBAAAC;AAAA,cAAAA,VAASC;AAAT,AACE,OAACK,8CAAMC,0BAAUN;;AADnB;;;AAIN,AAAAP,4CAAA,yHAAA,mFAAA,mDAAA,mFAAA,0DAAA,mFAAA,+CAAA,kGAAA,mFAAA,8DAAA,mFAAA,mDAAA,4HAAA,mFAAA,4DAAA,2CAAA,6DAAA,aAAA","names":["metabase.util.malli.registry/register!","p1__61180#","cljs.core/random-uuid","_","metabase.shared.util.i18n/js-i18n","joins","temp__5802__auto__","aliases","cljs.core/not-empty","cljs.core.filter","cljs.core/some?","cljs.core.map","cljs.core.apply","cljs.core/distinct?"],"sourcesContent":["(ns metabase.lib.schema.join\n  \"Schemas for things related to joins.\"\n  (:require\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util.malli.registry :as mr]))\n\n;;; The Fields to include in the results *if* a top-level `:fields` clause *is not* specified. This can be either\n;;; `:none`, `:all`, or a sequence of Field clauses.\n;;;\n;;; *  `:none`: no Fields from the joined table or nested query are included (unless indirectly included by\n;;;    breakouts or other clauses). This is the default, and what is used for automatically-generated joins.\n;;;\n;;; *  `:all`: will include all of the Fields from the joined table or query\n;;;\n;;; * a sequence of Field clauses: include only the Fields specified. Only `:field` clauses are allowed here!\n;;;    References to expressions or aggregations in the thing we're joining should use column literal (string column\n;;;    name) `:field` references. This should be non-empty and all elements should be distinct. The normalizer will\n;;;    automatically remove duplicate fields for you, and replace empty clauses with `:none`.\n;;;\n;;; Driver implementations: you can ignore this clause. Relevant fields will be added to top-level `:fields` clause\n;;; with appropriate aliases.\n(mr/def ::fields\n  [:or\n   [:enum :all :none]\n   ;; TODO -- `:fields` is supposed to be distinct (ignoring UUID), e.g. you can't have `[:field {} 1]` in there\n   ;; twice. (#32489)\n   [:sequential {:min 1} [:ref :mbql.clause/field]]])\n\n;;; The name used to alias the joined table or query. This is usually generated automatically and generally looks\n;;; like `table__via__field`. You can specify this yourself if you need to reference a joined field with a\n;;; `:join-alias` in the options.\n;;;\n;;; Driver implementations: This is guaranteed to be present after pre-processing.\n(mr/def ::alias\n  [:or\n   {:gen/fmap #(str % \"-\" (random-uuid))}\n   ::common/non-blank-string])\n\n(mr/def ::conditions\n  [:sequential {:min 1} [:ref ::expression/boolean]])\n\n;;; valid values for the optional `:strategy` key in a join. Note that these are only valid if the current Database\n;;; supports that specific join type; these match 1:1 with the Database `:features`, e.g. a Database that supports\n;;; left joins will support the `:left-join` feature.\n;;;\n;;; When `:strategy` is not specified, `:left-join` is the default strategy.\n(mr/def ::strategy\n  [:enum\n   :left-join\n   :right-join\n   :inner-join\n   :full-join])\n\n(mr/def ::join\n  [:map\n   [:lib/type    [:= :mbql/join]]\n   [:lib/options ::common/options]\n   [:stages      [:ref :metabase.lib.schema/stages]]\n   [:conditions  ::conditions]\n   [:alias       ::alias]\n   [:fields   {:optional true} ::fields]\n   [:strategy {:optional true} ::strategy]])\n\n(mr/def ::joins\n  [:and\n   [:sequential {:min 1} [:ref ::join]]\n   [:fn\n    {:error/fn (fn [& _]\n                 (i18n/tru \"Join aliases must be unique at a given stage of a query\"))}\n    (fn ensure-unique-join-aliases [joins]\n      (if-let [aliases (not-empty (filter some? (map :alias joins)))]\n        (apply distinct? aliases)\n        true))]])\n\n(mr/def ::strategy.option\n  [:map\n   [:lib/type [:= :option/join.strategy]]\n   [:strategy [:ref ::strategy]]\n   [:default {:optional true} :boolean]])\n"]}