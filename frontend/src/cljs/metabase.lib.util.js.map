{"version":3,"sources":["metabase/lib/util.cljc"],"mappings":"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","names":["metabase.lib.util/format","goog.string/format","metabase.lib.util/clause?","clause","cljs.core/vector?","cljs.core/count","cljs.core/Keyword","cljs.core/first","cljs.core/map?","cljs.core/second","cljs.core/contains?","metabase.lib.util/clause-of-type?","clause-type","cljs.core._EQ_","metabase.lib.util/field-clause?","metabase.lib.util/expression-name","cljs.core.get_in","metabase.lib.util/named-expression-clause","a-name","cljs.core/assoc-in","cljs.core/random-uuid","metabase.lib.schema.expression/type-of","js/Error","metabase.lib.util/replace-clause","stage","location","target-clause","new-clause","p1__64433#","cljs.core.some_fn","medley.core/update-existing-in","clause-or-clauses","iter__5523__auto__","s__64442","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","b__64444","cljs.core/chunk-buffer","i__64443","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__64441","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","metabase.lib.options/uuid","cljs.core/vec","metabase.lib.util/remove-clause","temp__5802__auto__","target","vec__64446","cljs.core.nth","target-uuid","first-loc","last-loc","cljs.core/last","result","cljs.core.into","cljs.core.remove","cljs.core.comp","p1__64445#","cljs.core/every?","cljs.core.ex_info","metabase.shared.util.i18n/js-i18n","cljs.core.update_in","cljs.core/pop","cljs.core/dissoc","medley.core.dissoc_in","metabase.lib.util/native-query->pipeline","query","cljs.core.merge","clojure.set/rename-keys","cljs.core.dissoc","metabase.lib.util/update-legacy-boolean-expression->list","m","legacy-key","pMBQL-key","G__64450","p1__64449#","cljs.core.update","cljs.core.drop","metabase.lib.util/join->pipeline","join","source","cljs.core/select-keys","stages","metabase.lib.util/inner-query->stages","cljs.core.assoc","metabase.lib.options/ensure-uuid","metabase.lib.util/joins->pipeline","joins","cljs.core.mapv","metabase.lib.util/->stage-metadata","source-metadata","cljs.core/seqable?","columns","column","cljs.core/update-keys","metabase.util/->kebab-case-en","p__64468","map__64469","cljs.core/--destructure-map","cljs.core.get","source-query","inner-query","previous-stages","previous-stage","G__64475","and__5043__auto__","stage-type","this-stage","G__64483","cljs.core.conj","metabase.lib.util/mbql-query->pipeline","metabase.lib.util/LegacyOrPMBQLQuery","metabase.lib.util/pipeline","G__64522","p__64524","map__64525","metabase.lib.util/canonical-stage-index","_query","stage-number","stage-number'","metabase.shared.util.i18n.js_i18n","metabase.lib.util/previous-stage-number","metabase.lib.util/first-stage?","cljs.core/not","p__64529","map__64530","metabase.lib.util/next-stage-number","metabase.lib.util/query-stage","map__64532","metabase.lib.util/previous-stage","stage-num","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","metabase.lib.util/update-query-stage","seq64577","G__64578","cljs.core/next","G__64579","G__64580","self__5754__auto__","f","args","map__64595","stages'","cljs.core.apply","cljs.core/update","metabase.lib.util/ensure-mbql-final-stage","G__64624","cljs.core/conj","metabase.lib.util/join-strings-with-conjunction","conjunction","coll","clojure.string/trim","clojure.string.join","cljs.core/butlast","metabase.lib.util/string-byte-count","s","js/TextEncoder","metabase.lib.util/truncate-string-to-byte-count","max-length-bytes","buf","js/Uint8Array","cljs.core.subs","metabase.lib.util/truncate-alias-max-length-bytes","metabase.lib.util/truncated-alias-hash-suffix-length","metabase.lib.util/crc32-checksum","js/shadow.js.shim.module$crc_32.str","G__64690","metabase.lib.util/truncate-alias","metabase.lib.util.truncate_alias","max-bytes","checksum","truncated","metabase.lib.util/legacy-string-table-id->card-id","table-id","vec__64718","_match","card-id-str","cljs.core/re-find","cljs.core/parse-long","metabase.lib.util/source-table-id","metabase.lib.util/source-card-id","metabase.lib.util/unique-name-generator","metabase.mbql.util.unique_name_generator","metabase.util/lower-case-en","original","suffix","metabase.lib.util/strip-id-regex","js/RegExp","metabase.lib.util/strip-id","display-name","clojure.string/replace","metabase.lib.util/add-summary-clause","a-summary-clause","or__5045__auto__","new-summary?","new-query","metabase.lib.util.update_query_stage","summary-clauses","metabase.lib.common/->op-arg","medley.core.update_existing","p1__64761#","p1__64762#","cljs.core/subvec","metabase.lib.util/with-default-effective-type","options","metabase.lib.options/options","default-effective-type","G__64781","metabase.lib.options.update_options","cljs.core/assoc","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.lib.util\n  (:refer-clojure :exclude [format])\n  (:require\n   #?@(:clj\n       ([potemkin :as p]))\n   #?@(:cljs\n       ([\"crc-32\" :as CRC32]\n        [goog.string :as gstring]\n        [goog.string.format :as gstring.format]))\n   [clojure.set :as set]\n   [clojure.string :as str]\n   [medley.core :as m]\n   [metabase.lib.common :as lib.common]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.expression :as lib.schema.expression]\n   [metabase.lib.schema.id :as lib.schema.id]\n   [metabase.mbql.util :as mbql.u]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util :as u]\n   [metabase.util.malli :as mu]))\n\n#?(:clj\n   (set! *warn-on-reflection* true))\n\n;; The formatting functionality is only loaded if you depend on goog.string.format.\n#?(:cljs (comment gstring.format/keep-me))\n\n;;; For convenience: [[metabase.lib.util/format]] maps to [[clojure.core/format]] in Clj and [[goog.string/format]] in\n;;; Cljs. They both work like [[clojure.core/format]], but since that doesn't exist in Cljs, you can use this instead.\n#?(:clj\n   (p/import-vars [clojure.core format])\n\n   :cljs\n   (def format \"Exactly like [[clojure.core/format]] but ClojureScript-friendly.\" gstring/format))\n\n(defn clause?\n  \"Returns true if this is a clause.\"\n  [clause]\n  (and (vector? clause)\n       (> (count clause) 1)\n       (keyword? (first clause))\n       (map? (second clause))\n       (contains? (second clause) :lib/uuid)))\n\n(defn clause-of-type?\n  \"Returns true if this is a clause.\"\n  [clause clause-type]\n  (and (clause? clause)\n       (= (first clause) clause-type)))\n\n(defn field-clause?\n  \"Returns true if this is a field clause.\"\n  [clause]\n  (clause-of-type? clause :field))\n\n(defn expression-name\n  \"Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause.\"\n  [clause]\n  (when (clause? clause)\n    (get-in clause [1 :lib/expression-name])))\n\n(defn named-expression-clause\n  \"Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value.\"\n  [clause a-name]\n  (assoc-in\n    (if (clause? clause)\n      clause\n      [:value {:lib/uuid (str (random-uuid))\n               :effective-type (lib.schema.expression/type-of clause)}\n       clause])\n    [1 :lib/expression-name] a-name))\n\n(defn replace-clause\n  \"Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens.\"\n  [stage location target-clause new-clause]\n  {:pre [((some-fn clause? #(= (:lib/type %) :mbql/join)) target-clause)]}\n  (let [new-clause (if (= :expressions (first location))\n                     (named-expression-clause new-clause (expression-name target-clause))\n                     new-clause)]\n    (m/update-existing-in\n      stage\n      location\n      (fn [clause-or-clauses]\n        (->> (for [clause clause-or-clauses]\n               (if (= (lib.options/uuid clause) (lib.options/uuid target-clause))\n                 new-clause\n                 clause))\n             vec)))))\n\n(defn remove-clause\n  \"Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage.\"\n  [stage location target-clause]\n  {:pre [(clause? target-clause)]}\n  (if-let [target (get-in stage location)]\n    (let [target-uuid (lib.options/uuid target-clause)\n          [first-loc last-loc] [(first location) (last location)]\n          result (into [] (remove (comp #{target-uuid} lib.options/uuid)) target)\n          result (when-not (and (= location [:fields])\n                                (every? #(clause-of-type? % :expression) result))\n                   result)]\n      (cond\n        (seq result)\n        (assoc-in stage location result)\n\n        (= [:joins :conditions] [first-loc last-loc])\n        (throw (ex-info (i18n/tru \"Cannot remove the final join condition\")\n                        {:conditions (get-in stage location)}))\n\n        (= [:joins :fields] [first-loc last-loc])\n        (update-in stage (pop location) dissoc last-loc)\n\n        :else\n        (m/dissoc-in stage location)))\n    stage))\n\n;;; TODO -- all of this `->pipeline` stuff should probably be merged into [[metabase.lib.convert]] at some point in\n;;; the near future.\n\n(defn- native-query->pipeline\n  \"Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n          ;; readability in the REPL.\n          :stages   [(merge {:lib/type :mbql.stage/native}\n                            (set/rename-keys (:native query) {:query :native}))]}\n         (dissoc query :type :native)))\n\n(declare inner-query->stages)\n\n(defn- update-legacy-boolean-expression->list\n  \"Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`\"\n  [m legacy-key pMBQL-key]\n  (cond-> m\n    (contains? m legacy-key) (update legacy-key #(if (and (vector? %)\n                                                       (= (first %) :and))\n                                                   (vec (drop 1 %))\n                                                   [%]))\n    (contains? m legacy-key) (set/rename-keys {legacy-key pMBQL-key})))\n\n(defn- join->pipeline [join]\n  (let [source (select-keys join [:source-table :source-query])\n        stages (inner-query->stages source)]\n    (-> join\n        (dissoc :source-table :source-query)\n        (update-legacy-boolean-expression->list :condition :conditions)\n        (assoc :lib/type :mbql/join\n               :stages stages)\n        lib.options/ensure-uuid)))\n\n(defn- joins->pipeline [joins]\n  (mapv join->pipeline joins))\n\n(defn ->stage-metadata\n  \"Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]].\"\n  [source-metadata]\n  (when source-metadata\n    (-> (if (seqable? source-metadata)\n          {:columns source-metadata}\n          source-metadata)\n        (update :columns (fn [columns]\n                           (mapv (fn [column]\n                                   (-> column\n                                       (update-keys u/->kebab-case-en)\n                                       (assoc :lib/type :metadata/column)))\n                                 columns)))\n        (assoc :lib/type :metadata/results))))\n\n(defn- inner-query->stages [{:keys [source-query source-metadata], :as inner-query}]\n  (let [previous-stages (if source-query\n                          (inner-query->stages source-query)\n                          [])\n        source-metadata (->stage-metadata source-metadata)\n        previous-stage  (dec (count previous-stages))\n        previous-stages (cond-> previous-stages\n                          (and source-metadata\n                               (not (neg? previous-stage))) (assoc-in [previous-stage :lib/stage-metadata] source-metadata))\n        stage-type      (if (:native inner-query)\n                          :mbql.stage/native\n                          :mbql.stage/mbql)\n        ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n        ;; readability in the REPL.\n        this-stage      (merge {:lib/type stage-type}\n                               (dissoc inner-query :source-query :source-metadata))\n        this-stage      (cond-> this-stage\n                          (seq (:joins this-stage)) (update :joins joins->pipeline)\n                          :always (update-legacy-boolean-expression->list :filter :filters))]\n    (conj previous-stages this-stage)))\n\n(defn- mbql-query->pipeline\n  \"Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          :stages   (inner-query->stages (:query query))}\n         (dissoc query :type :query)))\n\n(def LegacyOrPMBQLQuery\n  \"Schema for a map that is either a legacy query OR a pMBQL query.\"\n  [:or\n   [:map\n    {:error/message \"legacy query\"}\n    [:type [:enum :native :query]]]\n   [:map\n    {:error/message \"pMBQL query\"}\n    [:lib/type [:= :mbql/query]]]])\n\n(mu/defn pipeline\n  \"Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)\"\n  [query :- LegacyOrPMBQLQuery]\n  (if (= (:lib/type query) :mbql/query)\n    query\n    (case (:type query)\n      :native (native-query->pipeline query)\n      :query  (mbql-query->pipeline query))))\n\n(mu/defn canonical-stage-index :- [:int {:min 0}]\n  \"If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc.\"\n  [{:keys [stages], :as _query} :- :map\n   stage-number                 :- :int]\n  (let [stage-number' (if (neg? stage-number)\n                        (+ (count stages) stage-number)\n                        stage-number)]\n    (when (or (>= stage-number' (count stages))\n              (neg? stage-number'))\n      (throw (ex-info (i18n/tru \"Stage {0} does not exist\" stage-number)\n                      {:num-stages (count stages)})))\n    stage-number'))\n\n(mu/defn previous-stage-number :- [:maybe [:int {:min 0}]]\n  \"The index of the previous stage, if there is one. `nil` if there is no previous stage.\"\n  [query        :- :map\n   stage-number :- :int]\n  (let [stage-number (canonical-stage-index query stage-number)]\n    (when (pos? stage-number)\n      (dec stage-number))))\n\n(defn first-stage?\n  \"Whether a `stage-number` is referring to the first stage of a query or not.\"\n  [query stage-number]\n  (not (previous-stage-number query stage-number)))\n\n(defn next-stage-number\n  \"The index of the next stage, if there is one. `nil` if there is no next stage.\"\n  [{:keys [stages], :as _query} stage-number]\n  (let [stage-number (if (neg? stage-number)\n                       (+ (count stages) stage-number)\n                       stage-number)]\n    (when (< (inc stage-number) (count stages))\n      (inc stage-number))))\n\n(mu/defn query-stage :- ::lib.schema/stage\n  \"Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int]\n  (let [{:keys [stages], :as query} (pipeline query)]\n    (get (vec stages) (canonical-stage-index query stage-number))))\n\n(mu/defn previous-stage :- [:maybe ::lib.schema/stage]\n  \"Return the previous stage of the query, if there is one; otherwise return `nil`.\"\n  [query stage-number :- :int]\n  (when-let [stage-num (previous-stage-number query stage-number)]\n    (query-stage query stage-num)))\n\n(mu/defn update-query-stage :- ::lib.schema/query\n  \"Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int\n   f & args]\n  (let [{:keys [stages], :as query} (pipeline query)\n        stage-number'               (canonical-stage-index query stage-number)\n        stages'                     (apply update (vec stages) stage-number' f args)]\n    (assoc query :stages stages')))\n\n(mu/defn ensure-mbql-final-stage :- ::lib.schema/query\n  \"Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one.\"\n  [query]\n  (let [query (pipeline query)]\n    (cond-> query\n      (= (:lib/type (query-stage query -1)) :mbql.stage/native)\n      (update :stages conj {:lib/type :mbql.stage/mbql}))))\n\n(defn join-strings-with-conjunction\n  \"This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \\\"and\\\" [\\\"X\\\" \\\"Y\\\" \\\"Z\\\"])\n  ;; => \\\"X, Y, and Z\\\"\"\n  [conjunction coll]\n  (when (seq coll)\n    (if (= (count coll) 1)\n      (first coll)\n      (let [conjunction (str \\space (str/trim conjunction) \\space)]\n        (if (= (count coll) 2)\n          ;; exactly 2 args: X and Y\n          (str (first coll) conjunction (second coll))\n          ;; > 2 args: X, Y, and Z\n          (str\n           (str/join \", \" (butlast coll))\n           \",\"\n           conjunction\n           (last coll)))))))\n\n(mu/defn ^:private string-byte-count :- [:int {:min 0}]\n  \"Number of bytes in a string using UTF-8 encoding.\"\n  [s :- :string]\n  #?(:clj (count (.getBytes (str s) \"UTF-8\"))\n     :cljs (.. (js/TextEncoder.) (encode s) -length)))\n\n#?(:clj\n   (mu/defn ^:private string-character-at :- [:string {:min 0, :max 1}]\n     [s :- :string\n      i :-[:int {:min 0}]]\n     (str (.charAt ^String s i))))\n\n(mu/defn ^:private truncate-string-to-byte-count :- :string\n  \"Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n  *characters*).\"\n  [s                :- :string\n   max-length-bytes :- [:int {:min 1}]]\n  #?(:clj\n     (loop [i 0, cumulative-byte-count 0]\n       (cond\n         (= cumulative-byte-count max-length-bytes) (subs s 0 i)\n         (> cumulative-byte-count max-length-bytes) (subs s 0 (dec i))\n         (>= i (count s))                           s\n         :else                                      (recur (inc i)\n                                                           (long (+\n                                                                  cumulative-byte-count\n                                                                  (string-byte-count (string-character-at s i)))))))\n\n     :cljs\n     (let [buf (js/Uint8Array. max-length-bytes)\n           result (.encodeInto (js/TextEncoder.) s buf)] ;; JS obj {read: chars_converted, write: bytes_written}\n       (subs s 0 (.-read result)))))\n\n(def ^:private truncate-alias-max-length-bytes\n  \"Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n  reasoning.\"\n  60)\n\n(def ^:private truncated-alias-hash-suffix-length\n  \"Length of the hash suffixed to truncated strings by [[truncate-alias]].\"\n  ;; 8 bytes for the CRC32 plus one for the underscore\n  9)\n\n(mu/defn ^:private crc32-checksum :- [:string {:min 8, :max 8}]\n  \"Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string.\"\n  [s :- :string]\n  (let [s #?(:clj (Long/toHexString (.getValue (doto (java.util.zip.CRC32.)\n                                                 (.update (.getBytes ^String s \"UTF-8\")))))\n             :cljs (-> (CRC32/str s 0)\n                       (unsigned-bit-shift-right 0) ; see https://github.com/SheetJS/js-crc32#signed-integers\n                       (.toString 16)))]\n    ;; pad to 8 characters if needed. Might come out as less than 8 if the first byte is `00` or `0x` or something.\n    (loop [s s]\n      (if (< (count s) 8)\n        (recur (str \\0 s))\n        s))))\n\n(mu/defn truncate-alias :- [:string {:min 1, :max 60}]\n  \"Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \\\"some_really_long_string\\\" 15) ;   -> \\\"some_r_8e0f9bc2\\\"\n    (truncate-alias \\\"some_really_long_string_2\\\" 15) ; -> \\\"some_r_2a3c73eb\\\"\"\n  ([s]\n   (truncate-alias s truncate-alias-max-length-bytes))\n\n  ([s         :- ::lib.schema.common/non-blank-string\n    max-bytes :- [:int {:min 0}]]\n   (if (<= (string-byte-count s) max-bytes)\n     s\n     (let [checksum  (crc32-checksum s)\n           truncated (truncate-string-to-byte-count s (- max-bytes truncated-alias-hash-suffix-length))]\n       (str truncated \\_ checksum)))))\n\n(mu/defn legacy-string-table-id->card-id :- [:maybe ::lib.schema.id/card]\n  \"If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`.\"\n  [table-id]\n  (when (string? table-id)\n    (when-let [[_match card-id-str] (re-find #\"^card__(\\d+)$\" table-id)]\n      (parse-long card-id-str))))\n\n(mu/defn source-table-id :- [:maybe ::lib.schema.id/table]\n  \"If this query has a `:source-table` ID, return it.\"\n  [query]\n  (-> query :stages first :source-table))\n\n(mu/defn source-card-id :- [:maybe ::lib.schema.id/card]\n  \"If this query has a `:source-card` ID, return it.\"\n  [query]\n  (-> query :stages first :source-card))\n\n(mu/defn unique-name-generator :- [:=>\n                                   [:cat ::lib.schema.common/non-blank-string]\n                                   ::lib.schema.common/non-blank-string]\n  \"Create a new function with the signature\n\n    (f str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash).\"\n  []\n  (comp truncate-alias\n        (mbql.u/unique-name-generator\n         ;; unique by lower-case name, e.g. `NAME` and `name` => `NAME` and `name_2`\n         :name-key-fn     u/lower-case-en\n         ;; truncate alias to 60 characters (actually 51 characters plus a hash).\n         :unique-alias-fn (fn [original suffix]\n                            (truncate-alias (str original \\_ suffix))))))\n\n(def ^:private strip-id-regex\n  #?(:cljs (js/RegExp. \" id$\" \"i\")\n     ;; `(?i)` is JVM-specific magic to turn on the `i` case-insensitive flag.\n     :clj  #\"(?i) id$\"))\n\n(mu/defn strip-id :- :string\n  \"Given a display name string like \\\"Product ID\\\", this will drop the trailing \\\"ID\\\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining.\"\n  [display-name :- :string]\n  (-> display-name\n      (str/replace strip-id-regex \"\")\n      str/trim))\n\n(mu/defn add-summary-clause :- ::lib.schema/query\n  \"If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages.\"\n  [query :- ::lib.schema/query\n   stage-number :- :int\n   location :- [:enum :breakout :aggregation]\n   a-summary-clause]\n  (let [query (pipeline query)\n        stage-number (or stage-number -1)\n        stage (query-stage query stage-number)\n        new-summary? (not (or (seq (:aggregation stage)) (seq (:breakout stage))))\n        new-query (update-query-stage\n                    query stage-number\n                    update location\n                    (fn [summary-clauses]\n                      (conj (vec summary-clauses) (lib.common/->op-arg a-summary-clause))))]\n    (if new-summary?\n      (-> new-query\n          (update-query-stage\n            stage-number\n            (fn [stage]\n              (-> stage\n                  (dissoc :order-by :fields)\n                  (m/update-existing :joins (fn [joins] (mapv #(dissoc % :fields) joins))))))\n          ;; subvec holds onto references, so create a new vector\n          (update :stages (comp #(into [] %) subvec) 0 (inc (canonical-stage-index query stage-number))))\n      new-query)))\n\n(defn with-default-effective-type\n  \"Adds a default :effective-type property if it does not exist and\n  :base-type is known.\n\n  This is needed only because we have to convert queries to the Legacy\n  form.\n  The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n  :effective-type property, but it should be present for the frontend\n  to work. It defaults to the :base-type property.\"\n  [clause]\n  (let [options (lib.options/options clause)\n        default-effective-type (when-not (:effective-type options)\n                                 (:base-type options))]\n    (cond-> clause\n      default-effective-type\n      (lib.options/update-options assoc :effective-type default-effective-type))))\n"]}