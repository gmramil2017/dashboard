{"version":3,"sources":["metabase/lib/dispatch.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA,yCAAA,zCAAOA,0FAAkBC;AAAzB,AACE,GAAM,EAAK,AAACC,wBAAQD,QACT,+BAAAE,9BAAU,AAACC,gBAAMH;AAD5B,AAEE,OAACG,gBAAMH;;AAFT;;;AAIF;;;;;;;;;;;uCAAA,vCAAMI,sFAUHJ;AAVH,AAaE,IAAAK,mBAAI,AAACN,uCAAiBC;AAAtB,AAAA,oBAAAK;AAAAA;;AAAA,IAAAA,uBACI,2BAAA,2FAAA,pHAAM,AAACC,qBAAKN,IACV,AAAA,wFAAWA;AAFjB,AAAA,oBAAAK;AAAAA;;AAGI,OAACE,oCAAwBP","names":["metabase.lib.dispatch/mbql-clause-type","x","cljs.core/vector?","cljs.core/Keyword","cljs.core/first","metabase.lib.dispatch/dispatch-value","or__5045__auto__","cljs.core/map?","metabase.util/dispatch-type-keyword"],"sourcesContent":["(ns metabase.lib.dispatch\n  (:require [metabase.util :as u]))\n\n(defn- mbql-clause-type [x]\n  (when (and (vector? x)\n             (keyword? (first x)))\n    (first x)))\n\n(defn dispatch-value\n  \"Dispatch value for a clause, map, or other object. Dispatch rules are as follows:\n\n  1. If it is an MBQL clause (vector with a keyword as its first argument), dispatch on that clause keyword\n\n  2. If it is a map with a `:lib/type` key, dispatch on that;\n\n  3. Otherwise, dispatch on a keyword representing the class of the object, e.g. `:dispatch-type/string` for a String.\n     The main reason this returns weird keywords like this rather than class names like `String` is to make it easier to\n     write cross-compatible code. See [[u/dispatch-type-keyword]] for more info.\"\n  [x]\n  ;; TODO -- for Clj, we should probably handle Toucan instances as well, and dispatch off\n  ;; of [[toucan2.core/model]]?\n  (or (mbql-clause-type x)\n      (when (map? x)\n        (:lib/type x))\n      (u/dispatch-type-keyword x)))\n"]}