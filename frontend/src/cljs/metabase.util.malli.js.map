{"version":3,"sources":["metabase/util/malli.cljc"],"mappings":"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","names":["metabase.util.malli/encode-uri","fragment","js/encodeURI","var_args","G__58497","metabase.util.malli/->malli-io-link","js/Error","schema","metabase.util.malli.__GT_malli_io_link","e58498","malli.generator.generate","_","value","url-schema","metabase.util.pprint_to_str","malli.core.form","url-value","cljs.core._EQ_","url","cljs.core/re-find","p__58499","map__58500","cljs.core/--destructure-map","cljs.core.get","metabase.util.malli/humanize-include-value","message","metabase.shared.util.i18n/js-i18n","cljs.core.pr_str","metabase.util.malli/*enforce*","metabase.util.malli/explain-fn-fail!","type","data","map__58501","input","args","output","humanized","malli.error.humanize","malli.core.explain","link","cljs.core.ex_info","G__58502","cljs.core.assoc","and__5043__auto__","metabase.util.malli/instrument!","_id","metabase.util.malli/Schema","cljs.core/any?","malli.core/schema","metabase.util.malli/localized-string-schema","cljs.core/string?","G__58512","metabase.util.malli/with-api-error-message","mschema","error-message","metabase.util.malli.with_api_error_message","description-message","specific-error-message","malli.util.update_properties","malli.core.schema","cljs.core/assoc"],"sourcesContent":["(ns metabase.util.malli\n  (:refer-clojure :exclude [defn])\n  (:require\n   [clojure.core :as core]\n   [malli.core :as mc]\n   [malli.destructure]\n   [malli.error :as me]\n   [malli.generator :as mg]\n   [malli.util :as mut]\n   [metabase.shared.util.i18n :refer [tru]]\n   [metabase.util :as u]\n   #?@(:clj  ([clojure.string :as str]\n              [malli.experimental :as mx]\n              [malli.instrument :as minst]\n              [metabase.util.i18n :as i18n]\n              [net.cgrand.macrovich :as macros]\n              [ring.util.codec :as codec])))\n  #?(:cljs (:require-macros [metabase.util.malli])))\n\n(core/defn- encode-uri [fragment]\n  (#?(:clj codec/url-encode :cljs js/encodeURI) fragment))\n\n(core/defn- ->malli-io-link\n  ([schema]\n   (->malli-io-link schema (try\n                             ;; try to make a sample value\n                             (mg/generate schema {:seed 1 :size 1})\n                             ;; not all schemas can generate values\n                             (catch #?(:clj Exception :cljs js/Error) _ ::none))))\n  ([schema value]\n   (when schema\n     (let [url-schema (encode-uri (u/pprint-to-str (mc/form schema)))\n           url-value (if (= ::none value)\n                       \"\"\n                       (encode-uri (u/pprint-to-str value)))\n           url (str \"https://malli.io?schema=\" url-schema \"&value=\" url-value)]\n       (cond\n         ;; functions are not going to work\n         (re-find #\"#function\" url) nil\n         ;; cant be too long\n         (<= 2000 (count url)) nil\n         :else url)))))\n\n(core/defn humanize-include-value\n  \"Pass into mu/humanize to include the value received in the error message.\"\n  [{:keys [value message]}]\n  ;; TODO Should this be translated with more complete context? (tru \"{0}, received: {1}\" message (pr-str value))\n  (str message \", \" (tru \"received\") \": \" (pr-str value)))\n\n(def ^:dynamic *enforce*\n  \"Bind to false to skip enforcing instrumented function schemas.\"\n  true)\n\n(core/defn explain-fn-fail!\n  \"Used as reporting function to minst/instrument!\"\n  [type data]\n  (when *enforce*\n    (let [{:keys [input args output value]} data\n          humanized (cond input  (me/humanize (mc/explain input args) {:wrap humanize-include-value})\n                          output (me/humanize (mc/explain output value) {:wrap humanize-include-value}))\n          link (cond input (->malli-io-link input args)\n                     output (->malli-io-link output value))]\n      (throw (ex-info\n               (pr-str humanized)\n               (cond-> {:type type :data data}\n                 data (assoc :humanized humanized)\n                 (and data link) (assoc :link link))))))\n  data)\n\n#?(:clj\n   (clojure.core/defn instrument!\n     \"Instrument a [[metabase.util.malli/defn]].\"\n     [id]\n     (with-out-str (minst/instrument! {:filters [(minst/-filter-var #(-> % meta :validate! (= id)))]\n                                       :report  #'explain-fn-fail!})))\n   :cljs\n   (clojure.core/defn instrument!\n     \"Instrument a [[metabase.util.malli/defn]]. No-op for ClojureScript. Instrumentation currently only works in\n     Clojure AFAIK. [[malli.instrument]] is a Clj-only namespace.\"\n     [_id]))\n\n#?(:clj\n   (core/defn- -defn [target schema args]\n     (let [{:keys [name return doc meta arities] :as parsed} (mc/parse schema args)\n           _ (when (= ::mc/invalid parsed) (mc/-fail! ::parse-error {:schema schema, :args args}))\n           parse (fn [{:keys [args] :as parsed}] (merge (malli.destructure/parse args) parsed))\n           ->schema (fn [{:keys [schema]}] [:=> schema (:schema return :any)])\n           single (= :single (key arities))\n           parglists (if single\n                       (->> arities val parse vector)\n                       (->> arities val :arities (map parse)))\n           raw-arglists (map :raw-arglist parglists)\n           schema (as-> (map ->schema parglists) $ (if single (first $) (into [:function] $)))\n           annotated-doc (str/trim\n                           (str \"Inputs: \" (if single\n                                             (pr-str (first (mapv :raw-arglist parglists)))\n                                             (str \"(\" (str/join \"\\n           \" (map (comp pr-str :raw-arglist) parglists)) \")\"))\n                                \"\\n  Return: \" (str/replace (u/pprint-to-str (:schema return :any))\n                                                            \"\\n\"\n                                                            (str \"\\n          \"))\n                                (when (not-empty doc) (str \"\\n\\n  \" doc))))\n           id (str (gensym \"id\"))\n           inner-defn `(core/defn\n                         ~name\n                         ~@(some-> annotated-doc vector)\n                         ~(assoc meta\n                                 :raw-arglists (list 'quote raw-arglists)\n                                 :schema schema\n                                 :validate! id)\n                         ~@(map (fn [{:keys [arglist prepost body]}] `(~arglist ~prepost ~@body)) parglists)\n                         ~@(when-not single (some->> arities val :meta vector)))]\n       (case target\n         :clj  `(let [defn# ~inner-defn]\n                  (mc/=> ~name ~schema)\n                  ;; instrument the defn we just registered, via ~id\n                  (instrument! ~id)\n                  defn#)\n         ;; Vars aren't real in CLJS, so wrapping the inner `defn` in a `let` doesn't work like in does in CLJ.\n         ;; In CLJS `mu/defn` is just `cljs.core/defn` with some extra metadata and augmented docstring;\n         ;; [[mc/=>]] is not called, nor is [[instrument!]].\n         :cljs inner-defn))))\n\n#?(:clj\n   (defmacro defn\n     \"Like s/defn, but for malli. Will always validate input and output without the need for calls to instrumentation (they are emitted automatically).\n     Calls to minst/unstrument! can remove this, so use a filter that avoids :validate! if you use that.\"\n     [& args]\n     ;; [[macros/case]] only works properly in a `defmacro`, not in a helper function called by a `defmacro`.\n     ;; So we use it here and pass :clj or :cljs to [[-defn]].\n     (-defn (macros/case :clj :clj :cljs :cljs)\n            mx/SchematizedParams args)))\n\n(def ^:private Schema\n  [:and any?\n   [:fn {:description \"a malli schema\"} mc/schema]])\n\n(def ^:private localized-string-schema\n  #?(:clj  [:fn {:error/message \"must be a localized string\"}\n            i18n/localized-string?]\n     ;; TODO Is there a way to check if a string is being localized in CLJS, by the `ttag`?\n     ;; The compiler seems to just inline the translated strings with no annotation or wrapping.\n     :cljs string?))\n\n;; Kondo gets confused by :refer [defn] on this, so it's referenced fully qualified.\n(metabase.util.malli/defn with-api-error-message\n  \"Update a malli schema to have a :description (used by umd/describe, which is used by api docs),\n  and a :error/fn (used by me/humanize, which is used by defendpoint).\n  They don't have to be the same, but usually are.\n\n  (with-api-error-message\n    [:string {:min 1}]\n    (deferred-tru \\\"Must be a string with at least 1 character representing a User ID.\\\"))\"\n  ([mschema :- Schema error-message :- localized-string-schema]\n   (with-api-error-message mschema error-message error-message))\n  ([mschema                :- :any\n    description-message    :- localized-string-schema\n    specific-error-message :- localized-string-schema]\n   (mut/update-properties (mc/schema mschema) assoc\n                          ;; override generic description in api docs and :errors key in API's response\n                          :description description-message\n                          ;; override generic description in :specific-errors key in API's response\n                          :error/fn    (fn [_ _] specific-error-message))))\n"]}