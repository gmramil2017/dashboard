{"version":3,"sources":["metabase/lib/schema/literal.cljc"],"mappings":"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","names":["metabase.lib.schema.expression/type-of-method","_nil","metabase.util.malli.registry/register!","_bool","_int","_non-integer-real","metabase.lib.schema.literal/year-part","metabase.lib.schema.literal/month-part","metabase.lib.schema.literal/day-part","metabase.lib.schema.literal/date-part","metabase.lib.schema.literal/hour-part","metabase.lib.schema.literal/minutes-part","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","metabase.lib.schema.literal/optional","seq60734","self__5755__auto__","cljs.core/seq","parts","cljs.core.apply","cljs.core/str","metabase.lib.schema.literal/seconds-milliseconds-part","metabase.lib.schema.literal.optional","metabase.lib.schema.literal/time-part","metabase.lib.schema.literal/date-time-part","metabase.lib.schema.literal/offset-part","metabase.lib.schema.literal/local-date-regex","cljs.core/re-pattern","metabase.lib.schema.literal/local-time-regex","metabase.lib.schema.literal/offset-time-regex","metabase.lib.schema.literal/local-datetime-regex","metabase.lib.schema.literal/offset-datetime-regex","s","pred__60739","expr__60740","malli.core/validate","metabase.lib.schema.literal/year-month-regex","metabase.lib.schema.literal/year-regex","metabase.lib.schema.mbql_clause.define_mbql_clause","cljs.core/any?"],"sourcesContent":["(ns metabase.lib.schema.literal\n  \"Malli schemas for string, temporal, number, and boolean literals.\"\n  (:require\n   [malli.core :as mc]\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.util.malli.registry :as mr]\n   #?@(:clj ([metabase.lib.schema.literal.jvm]))))\n\n(defmethod expression/type-of-method :dispatch-type/nil\n  [_nil]\n  :type/*)\n\n(mr/def ::boolean\n  :boolean)\n\n(defmethod expression/type-of-method :dispatch-type/boolean\n  [_bool]\n  :type/Boolean)\n\n(mr/def ::boolean\n  :boolean)\n\n(mr/def ::integer\n  #?(:clj [:or\n           :int\n           :metabase.lib.schema.literal.jvm/big-integer]\n     :cljs :int))\n\n(defmethod expression/type-of-method :dispatch-type/integer\n  [_int]\n  :type/Integer)\n\n;;; we should probably also restrict this to disallow NaN and positive/negative infinity, I don't know in what\n;;; universe we'd want to allow those if they're not disallowed already.\n(mr/def ::non-integer-real\n  #?(:clj [:or\n           :double\n           :metabase.lib.schema.literal.jvm/float\n           :metabase.lib.schema.literal.jvm/big-decimal]\n     :cljs :double))\n\n(defmethod expression/type-of-method :dispatch-type/number\n  [_non-integer-real]\n  ;; `:type/Float` is the 'base type' of all non-integer real number types in [[metabase.types]] =(\n  :type/Float)\n\n(mr/def ::string\n  :string)\n\n;;; TODO -- these temporal literals could be a little stricter, right now they are pretty permissive, you shouldn't be\n;;; allowed to have month `13` or `02-29` for example\n\n(def ^:private year-part\n  \"\\\\d{4}\")\n\n(def ^:private month-part\n  \"\\\\d{2}\")\n\n(def ^:private day-part\n  \"\\\\d{2}\")\n\n(def ^:private date-part\n  (str year-part \\- month-part \\- day-part))\n\n(def ^:private hour-part\n  \"\\\\d{2}\")\n\n(def ^:private minutes-part\n  \"\\\\d{2}\")\n\n(defn- optional [& parts]\n  (str \"(?:\" (apply str parts) \")?\"))\n\n(def ^:private seconds-milliseconds-part\n  (str \":\\\\d{2}\" (optional \"\\\\.\\\\d{1,6}\")))\n\n(def ^:private time-part\n  (str hour-part \\: minutes-part (optional seconds-milliseconds-part)))\n\n(def ^:private date-time-part\n  (str date-part \\T time-part))\n\n(def ^:private offset-part\n  (str \"(?:Z|(?:[+-]\" time-part \"))\"))\n\n(def ^:private ^:const local-date-regex\n  (re-pattern (str \\^ date-part \\$)))\n\n(def ^:private ^:const local-time-regex\n  (re-pattern (str \\^ time-part \\$)))\n\n(def ^:private ^:const offset-time-regex\n  (re-pattern (str \\^ time-part offset-part \\$)))\n\n(def ^:private ^:const local-datetime-regex\n  (re-pattern (str \\^ date-time-part \\$)))\n\n(def ^:private ^:const offset-datetime-regex\n  (re-pattern (str \\^ date-time-part offset-part \\$)))\n\n(mr/def ::string.date\n  [:re\n   {:error/message \"date string literal\"}\n   local-date-regex])\n\n(mr/def ::string.time\n  [:or\n   [:re\n    {:error/message \"local time string literal\"}\n    local-time-regex]\n   [:re\n    {:error/message \"offset time string literal\"}\n    offset-time-regex]])\n\n(mr/def ::string.datetime\n  [:or\n   [:re\n    {:error/message \"local date time string literal\"}\n    local-datetime-regex]\n   [:re\n    {:error/message \"offset date time string literal\"}\n    offset-datetime-regex]])\n\n(defmethod expression/type-of-method :dispatch-type/string\n  [s]\n  (condp mc/validate s\n    ::string.datetime #{:type/Text :type/DateTime}\n    ::string.date     #{:type/Text :type/Date}\n    ::string.time     #{:type/Text :type/Time}\n    :type/Text))\n\n(mr/def ::date\n  #?(:clj  [:or\n            :time/local-date\n            ::string.date]\n     :cljs ::string.date))\n\n(mr/def ::time\n  #?(:clj [:or\n           ::string.time\n           :time/local-time\n           :time/offset-time]\n     :cljs ::string.time))\n\n(mr/def ::datetime\n  #?(:clj [:or\n           ::string.datetime\n           :time/local-date-time\n           :time/offset-date-time\n           :time/zoned-date-time]\n     :cljs ::string.datetime))\n\n(mr/def ::temporal\n  [:or\n   ::date\n   ::time\n   ::datetime])\n\n;;; these are currently only allowed inside `:absolute-datetime`\n\n(def ^:const year-month-regex\n  \"Regex for a year-month literal string.\"\n  (re-pattern (str \\^ year-part \\- month-part \\$)))\n\n(mr/def ::string.year-month\n  [:re\n   {:error/message \"year-month string literal\"}\n   year-month-regex])\n\n(def ^:const year-regex\n  \"Regex for a year literal string.\"\n  (re-pattern (str \\^ year-part \\$)))\n\n(mr/def ::string.year\n  [:re\n   {:error/message \"year string literal\"}\n   year-regex])\n\n;;; `:effective-type` is required for `:value` clauses. This was not a rule in the legacy MBQL schema, but in actual\n;;; usage they basically always have `:base-type`; in MLv2 we're trying to use `:effective-type` everywhere instead;\n;;; These clauses are useless/pointless without type information anyway, so let's enforce this rule going forward.\n;;; Conversion can take care of `:base-type` <=> `:effective-type` as needed.\n(mr/def ::value.options\n  [:merge\n   [:ref ::common/options]\n   [:map\n    [:effective-type ::common/base-type]]])\n\n;;; [:value <opts> <value>] clauses are mostly used internally by the query processor to add type information to\n;;; literals, to make it easier for drivers to process queries; see\n;;; the [[metabase.query-processor.middleware.wrap-value-literals]] middleware. It is also used to differentiate `nil`\n;;; (as in no clause or value) from something intended to be `NULL` in a compiled query, and to associate type\n;;; information with that `nil`. Even if this is mostly used internally, the schema still needs to know about it.\n;;;\n;;; The schema itself does not currently enforce that the actual <value> matches up with the `:effective-type` in the\n;;; options map; this is only enforced in the QP. For now, it assumes you know what you are doing and takes your word\n;;; for it when you say something has a given `:effective-type`.\n(mbql-clause/define-mbql-clause :value\n  [:tuple\n   {:error/message \"Value :value clause\"}\n   #_tag   [:= :value]\n   #_opts  [:ref ::value.options]\n   #_value any?])\n"]}