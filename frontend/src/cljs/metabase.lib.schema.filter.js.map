{"version":3,"sources":["metabase/lib/schema/filter.cljc"],"mappings":"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","names":["seq__60941","cljs.core/seq","chunk__60942","count__60943","i__60944","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/first","cljs.core/next","op","metabase.lib.schema.mbql_clause.define_catn_mbql_clause","metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","seq__60953","chunk__60954","count__60955","i__60956","seq__60964","chunk__60965","count__60966","i__60967","seq__60970","chunk__60971","count__60972","i__60973","seq__60975","chunk__60976","count__60977","i__60978","metabase.lib.schema.filter/string-filter-options","seq__60980","chunk__60981","count__60982","i__60983","metabase.lib.schema.mbql_clause.define_mbql_clause","metabase.lib.schema.filter/time-interval-options","metabase.util.malli.registry/register!"],"sourcesContent":["(ns metabase.lib.schema.filter\n  \"Schemas for the various types of filter clauses that you'd pass to `:filters` or use inside something else that takes\n  a boolean expression.\"\n  (:require\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.util.malli.registry :as mr]))\n\n(doseq [op [:and :or]]\n  (mbql-clause/define-catn-mbql-clause op :- :type/Boolean\n    [:args [:repeat {:min 2} [:schema [:ref ::expression/boolean]]]]))\n\n(mbql-clause/define-tuple-mbql-clause :not :- :type/Boolean\n  [:ref ::expression/boolean])\n\n(doseq [op [:= :!=]]\n  (mbql-clause/define-catn-mbql-clause op :- :type/Boolean\n    [:args [:repeat {:min 2} [:schema [:ref ::expression/equality-comparable]]]]))\n\n(doseq [op [:< :<= :> :>=]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Boolean\n    #_x [:ref ::expression/orderable]\n    #_y [:ref ::expression/orderable]))\n\n(mbql-clause/define-tuple-mbql-clause :between :- :type/Boolean\n  ;; TODO -- we should probably enforce additional constraints that the various arg types have to agree, e.g. it makes\n  ;; no sense to say something like `[:between {} <date> <[:ref ::expression/string]> <integer>]`\n  #_expr [:ref ::expression/orderable]\n  #_min  [:ref ::expression/orderable]\n  #_max  [:ref ::expression/orderable])\n\n;; sugar: a pair of `:between` clauses\n(mbql-clause/define-tuple-mbql-clause :inside :- :type/Boolean\n  #_lat-expr [:ref ::expression/orderable]\n  #_lon-expr [:ref ::expression/orderable]\n  #_lat-max  [:ref ::expression/orderable]\n  #_lon-min  [:ref ::expression/orderable]\n  #_lat-min  [:ref ::expression/orderable]\n  #_lon-max  [:ref ::expression/orderable])\n\n;;; null checking expressions\n;;;\n;;; these are sugar for [:= ... nil] and [:!= ... nil] respectively\n(doseq [op [:is-null :not-null]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Boolean\n    [:ref ::expression/expression]))\n\n;;; one-arg [:ref ::expression/string] filter clauses\n;;;\n;;; :is-empty is sugar for [:or [:= ... nil] [:= ... \"\"]]\n;;;\n;;; :not-empty is sugar for [:and [:!= ... nil] [:!= ... \"\"]]\n(doseq [op [:is-empty :not-empty]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Boolean\n    [:ref ::expression/string]))\n\n(def ^:private string-filter-options\n  [:map [:case-sensitive {:optional true} :boolean]]) ; default true\n\n;; binary [:ref ::expression/string] filter clauses. These also accept a `:case-sensitive` option\n;;\n;; `:does-not-contain` is sugar for `[:not [:contains ...]]`:\n;;\n;; [:does-not-contain ...] = [:not [:contains ...]]\n(doseq [op [:starts-with :ends-with :contains :does-not-contain]]\n  (mbql-clause/define-mbql-clause op :- :type/Boolean\n    [:tuple\n     [:= op]\n     [:merge ::common/options string-filter-options]\n     #_whole [:ref ::expression/string]\n     #_part  [:ref ::expression/string]]))\n\n(def ^:private time-interval-options\n  [:map [:include-current {:optional true} :boolean]]) ; default false\n\n;; SUGAR: rewritten as a filter clause with a relative-datetime value\n(mbql-clause/define-mbql-clause :time-interval :- :type/Boolean\n  ;; TODO -- we should probably further constrain this so you can't do weird stuff like\n  ;;\n  ;;    [:time-interval {} <time> :current :year]\n  ;;\n  ;; using units that don't agree with the expr type\n  [:tuple\n   [:= :time-interval]\n   [:merge ::common/options time-interval-options]\n   #_expr [:ref ::expression/temporal]\n   #_n    [:or\n           [:enum :current :last :next]\n           ;; I guess there's no reason you shouldn't be able to do something like 1 + 2 in here\n           [:ref ::expression/integer]]\n   #_unit [:ref ::temporal-bucketing/unit.date-time.interval]])\n\n;; segments are guaranteed to return valid filter clauses and thus booleans, right?\n(mbql-clause/define-mbql-clause :segment :- :type/Boolean\n  [:tuple\n   [:= :segment]\n   ::common/options\n   [:or ::common/int-greater-than-zero ::common/non-blank-string]])\n\n(mr/def ::operator\n  [:map\n   [:lib/type [:= :operator/filter]]\n   [:short [:enum := :!= :inside :between :< :> :<= :>= :is-null :not-null :is-empty :not-empty :contains :does-not-contain :starts-with :ends-with]]\n   ;; this is used for display name and it depends on the arguments to the filter clause itself... e.g.\n   ;;\n   ;; number_a < number_b\n   ;;\n   ;; gets a display name of \"less than\" for the operator, while\n   ;;\n   ;; timestamp_a < timestamp_b\n   ;;\n   ;; gets a display name of \"before\" for the operator. We don't want to encode the display name in the `::operator`\n   ;; definition itself, because it forces us to do i18n in the definition itself; it's nicer to have static\n   ;; definitions and only add the display name when we call `display-name` or `display-info`.\n   [:display-name-variant :keyword]])\n"]}