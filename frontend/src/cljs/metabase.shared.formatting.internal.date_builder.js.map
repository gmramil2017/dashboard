{"version":3,"sources":["metabase/shared/formatting/internal/date_builder.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;kEAAA,wCAAA,2DAAA,8DAAA,gFAAA,2EAAA,6DAAA,kEAAA,6DAAA,wDAAA,2EAAA,8EAAA,2DAAA,oDAAA,kEAAA,yEAAA,oEAAA,gEAAA,gEAAA,iEAAA,8DAAA,qEAAA,gEAAA,IAAA,KAAA,MAAA,KAAA,KAAA,KAAA,IAAA,IAAA,MAAA,OAAA,IAAA,OAAA,MAAA,IAAA,MAAA,KAAA,IAAA,OAAA,IAAA,KAAA,pjDAAKA;AAyBL,yEAAA,zEAAOC,0JAAuBC;AAA9B,AACW,QAAA,qDAAA,LAASA;;AAGpB;;;;kEAAA,lEAAMC,4IAGHC;AAHH,AAIE,IAAME,aAAmBC;IACnBC,QAAU,iBAAAC,qBAAA,wFAAAC;AAAA,AAAA,YAAAC,kBAAA,KAAA;AAAA,AAAA,IAAAD,eAAAA;;AAAA,AAAA,IAAAE,qBAAA,AAAAC,cAAAH;AAAA,AAAA,GAAAE;AAAA,AAAA,IAAAF,eAAAE;AAAA,AAAA,GAAA,AAAAE,6BAAAJ;AAAA,IAAAK,kBAs5EiC,AAAA4B,sBAAAjC;IAt5EjCM,qBAAA,AAAAC,gBAAAF;IAAAG,WAAA,AAAAC,uBAAAH;AAAA,AAAA,GAAA,AAAA,iBAAAI,WAAA;;AAAA,AAAA,GAAA,CAAAA,WAAAJ;AAAA,UAAA,AAAAK,eAAAN,gBAAAK,rCAAMU;AAAN,AAAA,AAAA,AAAAR,uBAAAJ,SACE,uJAAA,qIAAA,1RACE,gBAAAa,fAAUD,mCAAiB,AAACE,4CAAIhC,gEAAe8B,OAC/C,iDAAA,jDAACG,6CAAEH,UAAwB,uEAAA,vEAAC7B,8EAC5B,sCAAA,tCAACiC,kCAAiBJ,UAAS,iBAAAK,WAAA,6FAAIL,7CAAI,iDAAA,jDAACO,hDAAQC;AAAjB,AAAA,sMAAAH,sFAAAA,pRAAyBnC,gGAAAA,0GAAAA;KAHtD,uGAAA,rGAIE,OAAS8B,kBAAkB,AAAC7B,uEAAsB6B,KACvB,kBAAO,gDAAA,iCAAA,2CAAA,wEAAA,pMAACS,gMACsBT,8DACA1B;;;AAR7D,eAAA,CAAAgB,WAAA;;;;AAAA;;;;;AAAA,OAAAG,qBAAA,AAAAC,gBAAAN,UAAA,AAAAO,8EAAA,AAAAC,qBAAAhB;;AAAA,OAAAa,qBAAA,AAAAC,gBAAAN,UAAA;;;AAAA,UAAA,AAAAS,gBAAAjB,tBAAMoB;AAAN,AAAA,OAAAF,eACE,uJAAA,qIAAA,1RACE,gBAAAG,fAAUD,mCAAiB,AAACE,4CAAIhC,gEAAe8B,OAC/C,iDAAA,jDAACG,6CAAEH,UAAwB,uEAAA,vEAAC7B,8EAC5B,sCAAA,tCAACiC,kCAAiBJ,UAAS,iBAAAM,WAAA,6FAAIN,7CAAI,iDAAA,jDAACO,hDAAQC;AAAjB,AAAA,sMAAAF,sFAAAA,pRAAyBpC,gGAAAA,0GAAAA;KAHtD,uGAAA,rGAIE,OAAS8B,kBAAkB,AAAC7B,uEAAsB6B,KACvB,kBAAO,gDAAA,iCAAA,2CAAA,wEAAA,pMAACS,gMACsBT,8DACA1B;KAR7D,AAAAqB,8EAAA,AAAAI,eAAAnB;;;AAAA;;;;GAAA,KAAA;;AAAA,AAAA,OAAAD,mBAAU,CAACH,2CAAAA,wDAAAA,fAAQF,oCAAAA;;IAS7BoC,UAAU,AAACC,8CAAMC,cAAIlC;AAV3B,AAAA,kBAAAH;AAAA,AAWY,OAAAA,wBAAWmC","names":["metabase.shared.formatting.internal.date-builder/format-strings","metabase.shared.formatting.internal.date-builder/format-string-literal","lit","metabase.shared.formatting.internal.date-builder/->formatter","format-list","p1__81521#","js->clj","cljs.core/js->clj","parts","iter__5523__auto__","s__81529","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","cljs.core/count","b__81531","cljs.core/chunk-buffer","i__81530","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__81527","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","fmt","cljs.core/Keyword","cljs.core.get","cljs.core._EQ_","clojure.string/starts-with?","G__81553","G__81571","cljs.core.subs","cljs.core.keyword","cljs.core.ex_info","fmt-str","cljs.core.apply","cljs.core/str","cljs.core/chunk-first"],"sourcesContent":["(ns metabase.shared.formatting.internal.date-builder\n  \"The formatting strings are not standardized.\n  Rather than wrangling with strings, this library defines a data structure for describing the format of\n  date/time strings.\n\n  A format is represented as a (JS or CLJS) list of keyword or string date fragments (`:year` or `\\\":day-of-month\\\"`).\n  Literal strings, eg. /, -, and the \\\"Q\\\" of \\\"Q4 - 2022\\\" are simply strings that don't start with : - except for the\n  literal string \\\":\\\" as a special case.\n\n  Examples:\n  - `[:year \\\"-\\\" :month-dd]` gives `\\\"2022-12\\\"`\n  - `[\\\"Q\\\" \\\":quarter\\\" \\\" - \\\" \\\":year\\\"]` gives `\\\"Q4 - 2022\\\"`\n  - `[:month-full-name]` gives `\\\"April\\\"`\n  - `[:month-name]` gives `\\\"Apr\\\"`\n  - `[:month-dd]` gives `\\\"04\\\"`\"\n  (:require\n   [clojure.string :as str])\n  #?(:clj (:import\n           java.time.format.DateTimeFormatter)))\n\n(def format-strings\n  \"This is the complete set of keys the formats can contain, mapped to the platform-specific magic string expected\n  by Moment.js or java.time.format.DateTimeFormatter. Many are the same, but not all.\"\n  {:year              #?(:cljs \"YYYY\" :clj \"yyyy\")  ; 2022\n   :quarter           \"Q\"                           ; 2 (\"Q2\" etc. is added by higher level formatting)\n   :month-full        \"MMMM\"                        ; April\n   :month-short       \"MMM\"                         ; Apr\n   :month-dd          \"MM\"                          ; 04\n   :month-d           \"M\"                           ; 4\n   :day-of-month-d    #?(:cljs \"D\"    :clj \"d\")     ; 6\n   :day-of-month-dd   #?(:cljs \"DD\"   :clj \"dd\")    ; 06\n   :day-of-week-full  #?(:cljs \"dddd\" :clj \"EEEE\")  ; Friday\n   :day-of-week-short #?(:cljs \"ddd\"  :clj \"EEE\")   ; Fri\n   :hour-24-dd        \"HH\"                          ; 17, 05\n   :hour-24-d         \"H\"                           ; 17, 5\n   :hour-12-dd        \"hh\"                          ; 05\n   :hour-12-d         \"h\"                           ; 5\n   :am-pm             #?(:cljs \"A\"    :clj \"a\")     ; AM\n   :minute-d          \"m\"                           ; 7, 39\n   :minute-dd         \"mm\"                          ; 07, 39\n   :second-dd         \"ss\"                          ; 08, 45\n   :millisecond-ddd   \"SSS\"                         ; 001, 423\n   :day-of-year       #?(:cljs \"DDD\"  :clj \"D\")     ; 235\n   :week-of-year      #?(:cljs \"wo\"   :clj \"w\")})   ; 34th in CLJS, 34 in CLJ. No ordinal numbers in Java.\n\n(defn- format-string-literal [lit]\n  #?(:cljs (str \"[\" lit \"]\")\n     :clj  (str \"'\" (str/replace lit \"'\" \"''\") \"'\")))\n\n(defn ->formatter\n  \"Given a data structure describing the date format, as given in [[format-strings]], return a function that takes a\n  date object and formats it.\"\n  [format-list]\n  (let [js->clj   #?(:cljs js->clj :clj identity)\n        parts     (for [fmt (js->clj format-list)]\n                    (cond\n                      (keyword? fmt)             (get format-strings fmt)\n                      (= fmt \":\")                (format-string-literal \":\")\n                      (str/starts-with? fmt \":\") (-> fmt (subs 1) keyword format-strings)\n                      (string? fmt)              (format-string-literal fmt)\n                      :else                      (throw (ex-info \"Unknown element of date format\"\n                                                                 {:bad-element fmt\n                                                                  :format      format-list}))))\n        fmt-str   (apply str parts)]\n    #?(:cljs #(.format % fmt-str)\n       :clj  (let [formatter (DateTimeFormatter/ofPattern fmt-str)]\n               #(.format formatter %)))))\n"]}