{"version":3,"sources":["metabase/lib/equality.cljc"],"mappings":"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","names":["js/metabase","js/metabase.lib","js/metabase.lib.equality","js/metabase.lib.equality.=","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","cljs.core.get","fexpr__64889","cljs.core/MultiFn","cljs.core.symbol","metabase.lib.equality/=","x","y","x-dispatch-value","metabase.lib.dispatch/dispatch-value","y-dispatch-value","cljs.core.not_EQ_","metabase.lib.hierarchy/hierarchy","_x","_y","metabase.lib.equality/relevant-keys-set","m","cljs.core.into","cljs.core.remove","k","cljs.core/qualified-keyword?","cljs.core/keys","m1","m2","m1-keys","m2-keys","cljs.core._EQ_","cljs.core/every?","xs","ys","and__5043__auto__","cljs.core/count","G__64918","vec__64920","seq__64921","cljs.core/seq","first__64922","cljs.core/first","cljs.core/next","G__64919","vec__64923","seq__64924","first__64925","vec__64926","seq__64927","first__64928","vec__64929","seq__64930","first__64931","more-x","more-y","or__5045__auto__","cljs.core/empty?","metabase.lib.equality/*side->uuid->index*","metabase.lib.equality/aggregation-uuid->index","stage","cljs.core.map_indexed","p__64938","vec__64940","cljs.core.nth","map__64943","cljs.core/--destructure-map","idx","_tag","ag-uuid","*side->uuid->index*-orig-val__64944","*side->uuid->index*-temp-val__64945","fexpr__64946","cljs.core/get-method","p__64947","p__64948","vec__64949","vec__64952","x-tag","x-opts","x-uuid","y-tag","y-opts","y-uuid","cljs.core.get_in","cljs.core/map?","fexpr__64957","cljs.core/sequential?","fexpr__64958","metabase.lib.equality/ref=","metabase.lib.util/with-default-effective-type","metabase.lib.equality/update-options-remove-namespaced-keys","a-ref","metabase.lib.options/update-options","options","p__64961","vec__64962","_v","var_args","G__64970","metabase.lib.equality/find-closest-matching-ref","js/Error","refs","p1__64965#","p1__64966#","p1__64967#","xform","cljs.core/identity","more-xforms","metabase.lib.options.update_options","medley.core/update-existing","cljs.core/dissoc","p1__64968#","medley.core.find_first","cljs.core.comp","cljs.core/rest","metadata-providerable","metabase.lib.equality.find_closest_matching_ref","cljs.core.filter","cljs.core/some?","&parents","&match","cljs.core/vector?","&match_0__64974","cljs.core/keyword-identical?","&match_2__64976","temp__5804__auto__","cljs.core.match/backtrack","e64979","e__61771__auto__","e64978","e64977","metabase.mbql.util.match.impl/match-in-collection","match-64972","opts","field-id","cljs.core/integer?","field-name","metabase.lib.metadata/field"],"sourcesContent":["(ns metabase.lib.equality\n  \"Logic for determining whether two pMBQL queries are equal.\"\n  (:refer-clojure :exclude [=])\n  (:require\n   [medley.core :as m]\n   [metabase.lib.dispatch :as lib.dispatch]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.metadata :as lib.metadata]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.util :as lib.util]\n   [metabase.mbql.util.match :as mbql.u.match]))\n\n(defmulti =\n  \"Determine whether two already-normalized pMBQL maps, clauses, or other sorts of expressions are equal. The basic rule\n  is that two things are considered equal if they are [[clojure.core/=]], or, if they are both maps, if they\n  are [[clojure.core/=]] if you ignore all qualified keyword keys besides `:lib/type`.\"\n  {:arglists '([x y])}\n  ;; two things with different dispatch values (for maps, the `:lib/type` key; for MBQL clauses, the tag, and for\n  ;; everything else, the `:dispatch-type/*` key) can't be equal.\n  (fn [x y]\n    (let [x-dispatch-value (lib.dispatch/dispatch-value x)\n          y-dispatch-value (lib.dispatch/dispatch-value y)]\n      (if (not= x-dispatch-value y-dispatch-value)\n        ::different-dispatch-values\n        x-dispatch-value)))\n  :hierarchy lib.hierarchy/hierarchy)\n\n(defmethod = ::different-dispatch-values\n  [_x _y]\n  false)\n\n(defn- relevant-keys-set\n  \"Set of keys in a map that we consider relevant for [[=]] purposes.\"\n  [m]\n  (into #{}\n        (remove (fn [k]\n                  (and (qualified-keyword? k)\n                       (not= k :lib/type))))\n        (keys m)))\n\n(defmethod = :dispatch-type/map\n  [m1 m2]\n  (let [m1-keys (relevant-keys-set m1)\n        m2-keys (relevant-keys-set m2)]\n    (and (clojure.core/= m1-keys m2-keys)\n         (every? (fn [k]\n                   (= (get m1 k)\n                      (get m2 k)))\n                 m1-keys))))\n\n(defmethod = :dispatch-type/sequential\n  [xs ys]\n  (and (clojure.core/= (count xs) (count ys))\n       (loop [[x & more-x] xs, [y & more-y] ys]\n         (and (= x y)\n              (or (empty? more-x)\n                  (recur more-x more-y))))))\n\n(def ^:private ^:dynamic *side->uuid->index* nil)\n\n(defn- aggregation-uuid->index\n  [stage]\n  (into {}\n        (map-indexed (fn [idx [_tag {ag-uuid :lib/uuid}]]\n                       [ag-uuid idx]))\n        (:aggregation stage)))\n\n(defmethod = :mbql.stage/mbql\n  [x y]\n  (binding [*side->uuid->index* {:left (aggregation-uuid->index x)\n                                 :right (aggregation-uuid->index y)}]\n    ((get-method = :dispatch-type/map) x y)))\n\n(defmethod = :aggregation\n  [[x-tag x-opts x-uuid :as x] [y-tag y-opts y-uuid :as y]]\n  (and (clojure.core/= 3 (count x) (count y))\n       (clojure.core/= x-tag y-tag)\n       (= x-opts y-opts)\n       ;; If nil, it means we aren't comparing a stage, so just compare the uuid directly\n       (if *side->uuid->index*\n         (clojure.core/= (get-in *side->uuid->index* [:left x-uuid] ::no-left)\n                         (get-in *side->uuid->index* [:right y-uuid] ::no-right))\n         (clojure.core/= x-uuid y-uuid))))\n\n;;; if we've gotten here we at least know the dispatch values for `x` and `y` are the same, which means the types will\n;;; be the same.\n(defmethod = :default\n  [x y]\n  (cond\n    (map? x)        ((get-method = :dispatch-type/map) x y)\n    (sequential? x) ((get-method = :dispatch-type/sequential) x y)\n    :else           (clojure.core/= x y)))\n\n(defn ^:deprecated ref=\n  \"Are two refs `x` and `y` equal?\n\n  DEPRECATED: use [[find-closest-matching-ref]] instead. This does not work if things like `:base-type` are missing or\n  differ slightly, or handle `:binning` correctly, let alone when things are broken more significantly. If we improve\n  type calculation it shouldn't break existing queries... right?\"\n  [x y]\n  (or (= x y)\n      (= (lib.util/with-default-effective-type x)\n         (lib.util/with-default-effective-type y))))\n\n(defn- update-options-remove-namespaced-keys [a-ref]\n  (lib.options/update-options a-ref (fn [options]\n                                      (into {} (remove (fn [[k _v]] (qualified-keyword? k))) options))))\n\n(defn find-closest-matching-ref\n  \"Find the ref that most closely matches `a-ref` from a sequence of `refs`. This is meant to power things\n  like [[metabase.lib.breakout/breakoutable-columns]] which are supposed to include `:breakout-position` for columns\n  that are already present as a breakout; sometimes the column in the breakout does not exactly match what MLv2 would\n  have generated. So try to figure out which column it is referring to.\n\n  This first looks for a matching ref with a strict comparison, then in increasingly less-strict comparisons until it\n  finds something that matches. This is mostly to work around bugs like #31482 where MLv1 generated queries with\n  `:field` refs that did not include join aliases even tho the Fields came from joined Tables... we still know the\n  Fields are the same if they have the same IDs.\n\n  The three-arity version can also find matches between integer Field ID references like `[:field {} 1]` and\n  equivalent string column name field literal references like `[:field {} \\\"bird_type\\\"]` by resolving Field IDs using\n  a `metadata-providerable` (something that can be treated as a metadata provider, e.g. a `query` with a\n  MetadataProvider associated with it). This is the ultimately hacky workaround for totally busted legacy queries.\n  Note that this currently only works when `a-ref` is the one with the integer Field ID and `refs` have string literal\n  column names; it does not work the other way around. Luckily we currently don't have problems with MLv1/legacy\n  queries accidentally using string :field literals where it shouldn't have been doing so.\"\n  ([a-ref refs]\n   (loop [xform identity, more-xforms [ ;; ignore irrelevant keys from :binning options\n                                       #(lib.options/update-options % m/update-existing :binning dissoc :metadata-fn :lib/type)\n                                       ;; ignore namespaced keys\n                                       update-options-remove-namespaced-keys\n                                       ;; ignore type info\n                                       #(lib.options/update-options % dissoc :base-type :effective-type)\n                                       ;; ignore join alias\n                                       #(lib.options/update-options % dissoc :join-alias)]]\n     (or (let [a-ref (xform a-ref)]\n           (m/find-first #(= (xform %) a-ref)\n                         refs))\n         (when (seq more-xforms)\n           (recur (comp xform (first more-xforms)) (rest more-xforms))))))\n\n  ([metadata-providerable a-ref refs]\n   (or (find-closest-matching-ref a-ref refs)\n       (mbql.u.match/match-one a-ref\n         [:field opts (field-id :guard integer?)]\n         (when-let [field-name (:name (lib.metadata/field metadata-providerable field-id))]\n           (find-closest-matching-ref [:field opts field-name] refs))))))\n"]}