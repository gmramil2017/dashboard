{"version":3,"sources":["metabase/lib/options.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA,0CAAA,1CAAOA,4FAAcC;AAArB,AACE,SAAK,AAACC,wBAAQD,QACT,+BAAAE,9BAAU,AAACC,gBAAMH;;AAExB;;;;;;;;;;;;;;;;;;;;;;+BAAA,/BAASI,sEAiBNJ;AAjBH,AAAA;AAkBE,GACE,AAACK,qBAAKL;AACN,OAAA,4FAAcA;;AAFhB,GAIE,AAACD,wCAAaC;AACd,GAAM,AAACK,qBAAK,AAACC,iBAAON;AAApB,AACE,OAACM,iBAAON;;AADV;;;AALF,AAAA;;;;;AAWF;;;;;;;;;;;;;;oCAAA,pCAASO,gFASNP,EAAEQ;AATL,AAAA;AAUE,GACE,AAACH,qBAAKL;AACN,oCAAA,7BAACS,2BAAeT,gEAAe,AAACU,oBAAUF;;AAF5C,GAIE,AAACT,wCAAaC;AACd,oBAAI,AAAC,AAACW,gDAAQC,qBAAKP,sBAAM,AAACC,iBAAON;AAC/B,sEAAA,/DAACa,8CAAM,AAACC,cAAId,OAAKQ;;AACjB,oDAAA,7CAACO,gIAAM,AAACZ,gBAAMH,GAAGQ,oBAAa,AAACQ,eAAKhB;;;AAPxC,AAUE,MAAO,wUAAA,2CAAA,nXAACiB,gDAAQ,AAAAC,uEAAA,2FAAmD,AAACC,wGAAOnB,wGACvDA;;;;;AAExB,AAAA;;;;;sCAAA,8CAAAoB,pFAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,yEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,2EAAA,3EAAME,sFAIH1B,EAAEgC,EAAIC;AAJT,AAKE,IAAMC,kBAAgB,AAAC9B,6BAAQJ;IACzBQ,cAAgB,AAAC2B,8CAAMH,EAAEE,gBAAgBD;AAD/C,AAEE,OAAC1B,kCAAaP,EAAEQ;;;AAPpB,CAAA,8DAAA,9DAAMkB;;AAAN;AAAA,CAAA,wDAAA,WAAAC,nEAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAzB,gBAAAwB;IAAAA,eAAA,AAAAE,eAAAF;IAAAG,WAAA,AAAA3B,gBAAAwB;IAAAA,eAAA,AAAAE,eAAAF;AAAA,AAAA,IAAAI,qBAAA;AAAA,AAAA,OAAAA,wDAAAH,SAAAE,SAAAH;;;AAAA,AASA;;;;mCAAA,nCAAMS,8EAGHpC;AAHH,AAIE,OAAC0B,oCAAe1B,EAAE,WAAKqC;AAAL,AACE,IAAAC,WAAQD;AAAR,AAAA,GACE,AAACE,cAAI,AAAA,yFAAWF;AAChB,qDAAAC,SAAA,vDAACzB,kHAAgB,4CAAK,AAAC2B;;AAFzBF;;;;AAItB;;;;;;;4BAAA,5BAASG,gEAENzC;AAFH,AAAA;AAGE,OAAA,yFAAW,AAACI,6BAAQJ","names":["metabase.lib.options/mbql-clause?","x","cljs.core/vector?","cljs.core/Keyword","cljs.core/first","metabase.lib.options/options","cljs.core/map?","cljs.core/second","metabase.lib.options/with-options","new-options","metabase.util/assoc-dissoc","cljs.core/not-empty","cljs.core.some_fn","cljs.core/nil?","cljs.core.assoc","cljs.core/vec","cljs.core.into","cljs.core/rest","cljs.core.ex_info","metabase.shared.util.i18n.js_i18n","cljs.core.pr_str","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","metabase.lib.options/update-options","seq60052","G__60053","cljs.core/next","G__60054","self__5754__auto__","f","args","current-options","cljs.core.apply","metabase.lib.options/ensure-uuid","options-map","G__60055","cljs.core/not","cljs.core/random-uuid","metabase.lib.options/uuid"],"sourcesContent":["(ns metabase.lib.options\n  (:refer-clojure :exclude [uuid])\n  (:require\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util :as u]\n   [metabase.util.malli :as mu]))\n\n;;; TODO -- not 100% sure we actually need all of this stuff anymore.\n\n(defn- mbql-clause? [x]\n  (and (vector? x)\n       (keyword? (first x))))\n\n(mu/defn options :- [:maybe map?]\n  \"Return the Dashboard lib options map associated with an `x`. Lib options is currently used mostly for\n  the `:lib/uuid` we attach to everything to facilitate removing or replacing clauses later, but we will probably\n  stick more stuff in here in the future. Some clauses like `:field` use options extensively for different things.\n\n  Normally for an MBQL clause, options are an optional second argument, e.g.\n\n    [:= {:lib/uuid \\\"03baa510-0415-48ef-987a-462d789c8a02\\\"} 1 2]\n\n  a la Hiccup or Malli. The default implementation already knows how to handle clauses that follow this shape. For\n  historic reasons some MBQL clauses like `:field` or some of the string filter clauses have options as the last\n  argument; you'll have to implement this method, and [[with-options]], to deal with the special cases.\n\n  For maps like join specs, options are currently stored under the `:lib/options` key. Does this make sense? Not sure.\n  Maybe options should be included directly in the map, but then we'd have to decide which keys are and are not\n  options. Is a join `:alias` an option? Probably. What about a `:condition`? It's not optional. So for purposes of\n  writing Dashboard lib and tracking `:lib/uuid`, this approach seems ok in the short term.\"\n  [x]\n  (cond\n    (map? x)\n    (:lib/options x)\n\n    (mbql-clause? x)\n    (when (map? (second x))\n      (second x))\n\n    :else\n    nil))\n\n(mu/defn with-options\n  \"Update `x` so its [[options]] are `new-options`. If the clause or map already has options, this will\n  *replace* the old options; if it does not, this will set the new options.\n\n  If `x` is a map with `:lib/options` and `new-options` is `empty?`, this will drop `:lib/options` entirely.\n\n  You should probably prefer [[update-options]] to using this directly, so you don't stomp over existing stuff\n  unintentionally. Implement this if you need to teach Dashboard lib how to support something that doesn't follow the\n  usual patterns described in [[options]].\"\n  [x new-options :- [:maybe map?]]\n  (cond\n    (map? x)\n    (u/assoc-dissoc x :lib/options (not-empty new-options))\n\n    (mbql-clause? x)\n    (if ((some-fn nil? map?) (second x))\n      (assoc (vec x) 1 new-options)\n      (into [(first x) new-options] (rest x)))\n\n    :else\n    (throw (ex-info (i18n/tru \"Don''t know how to set options for {0}\" (pr-str x))\n                    {:x x}))))\n\n(defn update-options\n  \"Update the existing options in an `x` by applying `f` like this:\n\n    (apply f existing-options args)\"\n  [x f & args]\n  (let [current-options (options x)\n        new-options     (apply f current-options args)]\n    (with-options x new-options)))\n\n(defn ensure-uuid\n  \"Check that `x` has a `:lib/uuid` in its [[options]]; generate a UUID and add it if it does not\n  already have one.\"\n  [x]\n  (update-options x (fn [options-map]\n                      (cond-> options-map\n                        (not (:lib/uuid options-map))\n                        (assoc :lib/uuid (str (random-uuid)))))))\n\n(mu/defn uuid :- [:maybe ::lib.schema.common/non-blank-string]\n  \"Get the `:lib/uuid` associated with something, e.g. an MBQL clause or join.\"\n  [x]\n  (:lib/uuid (options x)))\n"]}