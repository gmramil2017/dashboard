{"version":3,"sources":["metabase/util/format.cljc"],"mappings":"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","names":["metabase.util.format/format-with-unit","n","suffix","metabase.util.format/format-nanoseconds","nanoseconds","G__52820","vec__52831","seq__52832","cljs.core/seq","first__52833","cljs.core/first","cljs.core/next","vec__52834","cljs.core.nth","vec__52845","seq__52846","first__52847","vec__52848","unit","divisor","more","js/Number.POSITIVE_INFINITY","cljs.core/name","metabase.util.format/format-microseconds","microseconds","metabase.util.format/format-milliseconds","milliseconds","metabase.util.format/format-seconds","seconds","metabase.util.format/format-bytes","num-bytes","G__52862","vec__52863","seq__52864","first__52865","vec__52872","seq__52873","first__52874","metabase.util.format/colorize","_","x","var_args","G__52884","metabase.util.format/format-color","args-arr__5794__auto__","len__5769__auto__","i__5770__auto__","argseq__5795__auto__","cljs.core/IndexedSeq","seq52880","G__52881","G__52882","self__5754__auto__","color","format-str","args","cljs.core.apply","goog.string/format"],"sourcesContent":["(ns metabase.util.format\n  #?(:clj  (:require\n            [colorize.core :as colorize]\n            [metabase.config :as config])\n     :cljs (:require\n            [goog.string :as gstring])))\n\n(defn- format-with-unit [n suffix]\n  #?(:clj  (format \"%.1f %s\" n suffix)\n     :cljs (str (.toFixed n 1) \" \" suffix)))\n\n(defn format-nanoseconds\n  \"Format a time interval in nanoseconds to something more readable. (\u00b5s/ms/etc.)\"\n  ^String [nanoseconds]\n  ;; The basic idea is to take `n` and see if it's greater than the divisior. If it is, we'll print it out as that\n  ;; unit. If more, we'll divide by the divisor and recur, trying each successively larger unit in turn. e.g.\n  ;;\n  ;; (format-nanoseconds 500)    ; -> \"500 ns\"\n  ;; (format-nanoseconds 500000) ; -> \"500 \u00b5s\"\n  (loop [n nanoseconds, [[unit divisor] & more] [[:ns 1000] [:\u00b5s 1000] [:ms 1000] [:s 60] [:mins 60] [:hours 24]\n                                                 [:days 7] [:weeks (/ 365.25 7)]\n                                                 [:years #?(:clj  Double/POSITIVE_INFINITY\n                                                            :cljs js/Number.POSITIVE_INFINITY)]]]\n    (if (and (> n divisor)\n             (seq more))\n      (recur (/ n divisor) more)\n      (format-with-unit (double n) (name unit)))))\n\n(defn format-microseconds\n  \"Format a time interval in microseconds into something more readable.\"\n  ^String [microseconds]\n  (format-nanoseconds (* 1000.0 microseconds)))\n\n(defn format-milliseconds\n  \"Format a time interval in milliseconds into something more readable.\"\n  ^String [milliseconds]\n  (format-microseconds (* 1000.0 milliseconds)))\n\n(defn format-seconds\n  \"Format a time interval in seconds into something more readable.\"\n  ^String [seconds]\n  (format-milliseconds (* 1000.0 seconds)))\n\n(defn format-bytes\n  \"Nicely format `num-bytes` as kilobytes/megabytes/etc.\n\n    (format-bytes 1024) ; -> 2.0 KB\"\n  [num-bytes]\n  (loop [n num-bytes [suffix & more] [\"B\" \"KB\" \"MB\" \"GB\"]]\n    (if (and (seq more)\n             (>= n 1024))\n      (recur (/ n 1024.0) more)\n      (format-with-unit n suffix))))\n\n#?(:clj\n   (def ^:private colorize?\n     ;; As of 0.35.0 we support the NO_COLOR env var. See https://no-color.org/ (But who hates color logs?)\n     (if (config/config-str :no-color)\n       false\n       (config/config-bool :mb-colorize-logs))))\n\n(def ^{:arglists '(^String [color-symb x])} colorize\n  \"Colorize string `x` using `color`, a symbol or keyword, but only if `MB_COLORIZE_LOGS` is enabled (the default).\n  `color` can be `green`, `red`, `yellow`, `blue`, `cyan`, `magenta`, etc. See the entire list of avaliable\n  colors [here](https://github.com/ibdknox/colorize/blob/master/src/colorize/core.clj)\"\n  #?(:clj  (if colorize?\n             (fn [color x]\n               (colorize/color (keyword color) (str x)))\n             (fn [_ x]\n               (str x)))\n     :cljs (fn [_ x]\n             (str x))))\n\n(defn format-color\n  \"With one arg, converts something to a string and colorizes it. With two args, behaves like `format`, but colorizes\n  the output.\n\n    (format-color :red \\\"%d cans\\\" 2)\"\n  {:arglists '(^String [color x] ^String [color format-string & args])}\n  (^String [color x]\n   (colorize color x))\n\n  (^String [color format-str & args]\n   (colorize color (apply #?(:clj format :cljs gstring/format) format-str args))))\n"]}