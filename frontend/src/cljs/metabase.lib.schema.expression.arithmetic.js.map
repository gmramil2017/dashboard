{"version":3,"sources":["metabase/lib/schema/expression/arithmetic.cljc"],"mappings":"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","names":["p__60387","vec__60388","cljs.core.nth","metabase.lib.schema.expression.arithmetic/valid-interval-for-type?","_tag","_opts","_n","unit","_interval","expr-type","unit-schema","cljs.core.isa_QMARK_","malli.core.validate","metabase.util.malli.registry/register!","p__60392","vec__60393","seq__60394","cljs.core/seq","first__60395","cljs.core/first","cljs.core/next","expr","intervals","metabase.lib.schema.expression/type-of","p1__60391#","cljs.core/every?","p__60397","vec__60398","seq__60399","first__60400","metabase.lib.schema.expression.arithmetic/validate-plus-minus-temporal-arithmetic-expression","exprs","map__60402","cljs.core/--destructure-map","cljs.core.get","non-intervals","p1__60396#","cljs.core/group-by","cljs.core.not_EQ_","cljs.core/count","cljs.core/some","p__60403","vec__60405","interval","metabase.lib.schema.expression.arithmetic/plus-minus-temporal-schema","tag","p__60408","map__60409","value","_","cljs.core/complement","metabase.lib.schema.expression.arithmetic/plus-minus-numeric-schema","metabase.lib.schema.expression.arithmetic/plus-minus-schema","metabase.lib.schema.expression.arithmetic/type-of-numeric-arithmetic-args","args","cljs.core.reduce","metabase.types/most-specific-common-ancestor","cljs.core.map","and__5043__auto__","metabase.lib.schema.expression.arithmetic/type-of-temporal-arithmetic-args","first-non-interval-arg-type","p1__60416#","medley.core.find_first","metabase.lib.schema.expression.arithmetic/type-of-arithmetic-args","p1__60418#","metabase.lib.schema.mbql_clause.define_mbql_clause","metabase.lib.schema.mbql_clause.define_catn_mbql_clause","seq__60423","chunk__60424","count__60425","i__60426","temp__5804__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","metabase.lib.hierarchy/derive","metabase.lib.schema.expression/type-of-method","p__60427","vec__60428","seq__60429","first__60430","metabase.lib.schema.mbql_clause.define_tuple_mbql_clause","seq__60431","chunk__60432","count__60433","i__60434","op","seq__60436","chunk__60437","count__60438","i__60439","p__60443","vec__60444","exponent"],"sourcesContent":["(ns metabase.lib.schema.expression.arithmetic\n  \"Arithmetic expressions like `:+`.\"\n  (:require\n   [malli.core :as mc]\n   [medley.core :as m]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.schema.common :as common]\n   [metabase.lib.schema.expression :as expression]\n   [metabase.lib.schema.mbql-clause :as mbql-clause]\n   [metabase.lib.schema.temporal-bucketing :as temporal-bucketing]\n   [metabase.types :as types]\n   [metabase.util.malli.registry :as mr]))\n\n(defn- valid-interval-for-type? [[_tag _opts _n unit :as _interval] expr-type]\n  (let [unit-schema (cond\n                      (isa? expr-type :type/Date)     ::temporal-bucketing/unit.date.interval\n                      (isa? expr-type :type/Time)     ::temporal-bucketing/unit.time.interval\n                      (isa? expr-type :type/DateTime) ::temporal-bucketing/unit.date-time.interval)]\n    (if unit-schema\n      (mc/validate unit-schema unit)\n      true)))\n\n(mr/def ::args.temporal\n  [:and\n   [:catn\n    [:expr      [:schema [:ref ::expression/temporal]]]\n    [:intervals [:+ :mbql.clause/interval]]]\n   [:fn\n    {:error/message \"Temporal arithmetic expression with valid interval units for the expression type\"}\n    (fn [[expr & intervals]]\n      (let [expr-type (expression/type-of expr)]\n        (every? #(valid-interval-for-type? % expr-type) intervals)))]])\n\n(mr/def ::args.numbers\n  [:repeat {:min 2} [:schema [:ref ::expression/number]]])\n\n(defn- validate-plus-minus-temporal-arithmetic-expression\n  \"Validate a `:+` or `:-` expression with temporal args. Return a string describing any errors found, or `nil` if it\n  looks ok.\"\n  [[_tag _opts & exprs]]\n  (let [{non-intervals false, intervals true} (group-by #(isa? (expression/type-of %) :type/Interval) exprs)]\n    (cond\n      (not= (count non-intervals) 1)\n      \"Temporal arithmetic expression must contain exactly one non-interval value\"\n\n      (< (count intervals) 1)\n      \"Temporal arithmetic expression must contain at least one :interval\"\n\n      :else\n      (let [expr-type (expression/type-of (first non-intervals))]\n        (some (fn [[_tag _opts _n unit :as interval]]\n                (when-not (valid-interval-for-type? interval expr-type)\n                  (str \"Cannot add a \" unit \" interval to a \" expr-type \" expression\")))\n              intervals)))))\n\n(defn- plus-minus-temporal-schema\n  \"Create a schema for `:+` or `:-` with temporal args: <temporal> \u00b1 <interval(s)> in any order\"\n  [tag]\n  [:and\n   {:error/message (str tag \" clause with a temporal expression and one or more :interval clauses\")}\n   [:cat\n    [:= tag]\n    [:schema [:ref ::common/options]]\n    [:repeat [:schema [:ref :mbql.clause/interval]]]\n    [:schema [:ref ::expression/temporal]]\n    [:repeat [:schema [:ref :mbql.clause/interval]]]]\n   [:fn\n    {:error/fn (fn [{:keys [value]} _]\n                 (str \"Invalid \" tag \" clause: \" (validate-plus-minus-temporal-arithmetic-expression value)))}\n    (complement validate-plus-minus-temporal-arithmetic-expression)]])\n\n(defn- plus-minus-numeric-schema\n  \"Create a schema for `:+` or `:-` with numeric args.\"\n  [tag]\n  [:cat\n   {:error/message (str tag \" clause with numeric args\")}\n   [:= tag]\n   [:schema [:ref ::common/options]]\n   [:repeat {:min 2} [:schema [:ref ::expression/number]]]])\n\n(defn- plus-minus-schema [tag]\n  [:or\n   (plus-minus-temporal-schema tag)\n   (plus-minus-numeric-schema tag)])\n\n(defn- type-of-numeric-arithmetic-args\n  \"Given a sequence of args to a numeric arithmetic expression like `:+`, determine the type returned by the expression\n  by calculating the most-specific common ancestor type of all the args. E.g. `[:+ ... 2.0 2.0]` has two `:type/Float`\n  args, and thus the most-specific common ancestor type is `:type/Float`. `[:+ ... 2.0 2]` has a `:type/Float` and a\n  `:type/Integer` arg; the most-specific common ancestor type is `:type/Number`. For refs without type\n  information (e.g. `:field` clauses), assume `:type/Number`.\"\n  [args]\n  ;; Okay to use reduce without an init value here since we know we have >= 2 args\n  #_{:clj-kondo/ignore [:reduce-without-init]}\n  (reduce\n   types/most-specific-common-ancestor\n   (map (fn [expr]\n          (let [expr-type (expression/type-of expr)]\n            (if (and (isa? expr-type ::expression/type.unknown)\n                     (mc/validate :metabase.lib.schema.ref/ref expr))\n              :type/Number\n              expr-type)))\n        args)))\n\n(defn- type-of-temporal-arithmetic-args\n  \"Given a temporal value plus one or more intervals `args` passed to an arithmetic expression like `:+`, determine the\n  overall type returned by the expression. This is the type of the temporal value (the arg that is not an interval),\n  or assume `:type/Temporal` if it is a ref without type information.\"\n  [args]\n  (let [first-non-interval-arg-type (m/find-first #(not (isa? % :type/Interval))\n                                                  (map expression/type-of args))]\n    (if (isa? first-non-interval-arg-type ::expression/type.unknown)\n      :type/Temporal\n      first-non-interval-arg-type)))\n\n(defn- type-of-arithmetic-args\n  \"Given a sequence of `args` to an arithmetic expression like `:+`, determine the overall type that the expression\n  returns. There are two types of arithmetic expressions:\n\n  * Ones consisting of numbers. See [[type-of-numeric-arithmetic-args]].\n\n  * Ones consisting of a temporal value like a Date plus one or more `:interval` clauses, in any order. See\n    [[type-of-temporal-arithmetic-args]].\"\n  [args]\n  (if (some #(isa? (expression/type-of %) :type/Interval) args)\n    ;; temporal value + intervals\n    (type-of-temporal-arithmetic-args args)\n    (type-of-numeric-arithmetic-args args)))\n\n(mbql-clause/define-mbql-clause :+\n  (plus-minus-schema :+))\n\n;;; TODO -- should `:-` support just a single arg (for numbers)? What about `:+`?\n(mbql-clause/define-mbql-clause :-\n  (plus-minus-schema :-))\n\n(mbql-clause/define-catn-mbql-clause :*\n  [:args ::args.numbers])\n\n;;; we always do non-integer real division even if all the expressions are integers, e.g.\n;;;\n;;;    [:/ <int-field>  2] => my_int_field / 2.0\n;;;\n;;; so the results are 0.5 as opposed to 0. This is what people expect division to do\n(mbql-clause/define-catn-mbql-clause :/ :- :type/Float\n  [:args ::args.numbers])\n\n(doseq [tag [:+ :- :*]]\n  (lib.hierarchy/derive tag :lib.type-of/type-is-type-of-arithmetic-args))\n\n;;; `:+`, `:-`, and `:*` all have the same logic; also used for [[metabase.lib.metadata.calculation/type-of-method]]\n(defmethod expression/type-of-method :lib.type-of/type-is-type-of-arithmetic-args\n  [[_tag _opts & args]]\n  (type-of-arithmetic-args args))\n\n(mbql-clause/define-tuple-mbql-clause :abs\n  [:schema [:ref ::expression/number]])\n\n(lib.hierarchy/derive :abs :lib.type-of/type-is-type-of-first-arg)\n\n(doseq [op [:log :exp :sqrt]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Float\n    [:schema [:ref ::expression/number]]))\n\n(doseq [op [:ceil :floor :round]]\n  (mbql-clause/define-tuple-mbql-clause op :- :type/Integer\n    [:schema [:ref ::expression/number]]))\n\n(mbql-clause/define-tuple-mbql-clause :power\n  #_num [:schema [:ref ::expression/number]]\n  #_exp [:schema [:ref ::expression/number]])\n\n(defmethod expression/type-of-method :power\n  [[_tag _opts expr exponent]]\n  ;; if both expr and exponent are integers, this will return an integer.\n  (if (and (isa? (expression/type-of expr) :type/Integer)\n           (isa? (expression/type-of exponent) :type/Integer))\n    :type/Integer\n    ;; otherwise this will return some sort of number with a decimal place. e.g.\n    ;;\n    ;;    (Math/pow 2 2.1) => 4.2870938501451725\n    ;;\n    ;; If we don't know the type of `expr` or `exponent` it's safe to assume `:type/Float` anyway, maybe not as\n    ;; specific as `:type/Integer` but better than `:type/*` or `::expression/type.unknown`.\n    :type/Float))\n"]}