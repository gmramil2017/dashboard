{"version":3,"sources":["metabase/lib/schema/common.cljc"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,AAGA,AAAAA,4CAAA,iIAAA,mFAAA,mDAAA,mFAAA,0DAAA,2CAAA,kDAAA,oBAAA,mFAAA,kDAAA,2CAAA,oEAAA,2BAKI,AAACC,qBAAWC;AAGhB,AAAAF,4CAAA,mKAAA,mFAAA,oDAAA,2CAAA,kDAAA;AAGA,AAAAA,4CAAA,0IAAA,mFAAA,oDAAA,2CAAA,kDAAA;AAGA,AAAAA,4CAAA,wGAAA,mFAAA,0DAAA,2CAAA,kDAAA,KAAA,iDAAA;AAIA,kDAAA,lDAAOG,4GAAgBC;AAAvB,AACE,SAAI,qDAAA,rDAACC,mDAAKD,sEACN,qDAAA,rDAACC,mDAAKD;;AAEZ,AAAAJ,4CAAA,2HAAA,mFAAA,kDAAA,2CAAA,oEAAA,sBAAA,2DAGmB,WAAAM,SAAqBK;AAArB,AAAA,IAAAJ,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;YAAA,AAAAE,4CAAAF,eAAA,nEAAaG;AAAb,AACE,QAAA,8BAAmC,AAACE,wGAAOF;WAC7DP;AAEH,8CAAA,9CAAOU,oGAAYT;AAAnB,AACE,SAAK,qDAAA,rDAACC,mDAAKD,+DACN,GAAK,AAACD,gDAAeC;;AAE5B,AAAAJ,4CAAA,iHAAA,mFAAA,kDAAA,2CAAA,oEAAA,kBAAA,2DAGmB,WAAAc,SAAqBH;AAArB,AAAA,IAAAI,aAAAD;IAAAC,iBAAA,AAAAP,4BAAAO;YAAA,AAAAN,4CAAAM,eAAA,nEAAaL;AAAb,AACE,QAAA,0BAA+B,AAACE,wGAAOF;WACzDG;AAEH,AAAAb,4CAAA,+GAAA,mFAAA,mDAAA,mFAAA,2DAAA,gHAAA,mFAAA,+DAAA,2CAAA,6DAAA,aAAA,mFAAA,uDAAA,iIAAA,mFAAA,yEAAA,2CAAA,6DAAA,aAAA,mFAAA,uDAAA,iIAAA,mFAAA,uEAAA,2CAAA,6DAAA,aAAA,mFAAA,uDAAA,2IAAA,mFAAA,uEAAA,2CAAA,6DAAA,aAAA,mFAAA,uDAAA,iJAAA,mFAAA,qDAAA,2CAAA,6DAAA,aAAA,mFAAA,uDAAA,iJAAA,mFAAA,oEAAA,2CAAA,6DAAA,aAAA,mFAAA,uDAAA;AAWA,AAAAA,4CAAA,sHAAA,mFAAA,mDAAA,mFAAA,0DAAA,mFAAA,+CAAA,yFAAA,mFAAA,8DAAA,mFAAA,gDAAA,0DAAA,0EAAA,mFAAA,yDAAA,2CAAA,6DAAA,aAAA,uHAAA,mFAAA,qDAAA,mFAAA,kEAAA","names":["metabase.util.malli.registry/register!","cljs.core/complement","clojure.string/blank?","metabase.lib.schema.common/semantic-type?","x","cljs.core.isa_QMARK_","p__58778","map__58779","cljs.core/--destructure-map","cljs.core.get","value","_","cljs.core.pr_str","metabase.lib.schema.common/base-type?","p__58781","map__58782"],"sourcesContent":["(ns metabase.lib.schema.common\n  (:require\n   [clojure.string :as str]\n   [metabase.types]\n   [metabase.util.malli.registry :as mr]))\n\n(comment metabase.types/keep-me)\n\n;;; Schema for a string that cannot be blank.\n(mr/def ::non-blank-string\n  [:and\n   [:string {:min 1}]\n   [:fn\n    {:error/message \"non-blank string\"}\n    (complement str/blank?)]])\n\n;;; Schema representing an integer than must also be greater than or equal to zero.\n(mr/def ::int-greater-than-or-equal-to-zero\n  [:int {:min 0}])\n\n(mr/def ::int-greater-than-zero\n  [:int {:min 1}])\n\n(mr/def ::uuid\n  ;; TODO -- should this be stricter?\n  [:string {:min 36, :max 36}])\n\n(defn- semantic-type? [x]\n  (or (isa? x :Semantic/*)\n      (isa? x :Relation/*)))\n\n(mr/def ::semantic-type\n  [:fn\n   {:error/message \"valid semantic type\"\n    :error/fn      (fn [{:keys [value]} _]\n                     (str \"Not a valid semantic type: \" (pr-str value)))}\n   semantic-type?])\n\n(defn- base-type? [x]\n  (and (isa? x :type/*)\n       (not (semantic-type? x))))\n\n(mr/def ::base-type\n  [:fn\n   {:error/message \"valid base type\"\n    :error/fn      (fn [{:keys [value]} _]\n                     (str \"Not a valid base type: \" (pr-str value)))}\n   base-type?])\n\n(mr/def ::options\n  [:map\n   [:lib/uuid ::uuid]\n   ;; these options aren't required for any clause in particular, but if they're present they must follow these schemas.\n   [:base-type      {:optional true} [:maybe ::base-type]]\n   [:effective-type {:optional true} [:maybe ::base-type]]\n   [:semantic-type  {:optional true} [:maybe ::semantic-type]]\n   [:database-type  {:optional true} [:maybe ::non-blank-string]]\n   [:name           {:optional true} [:maybe ::non-blank-string]]\n   [:display-name   {:optional true} [:maybe ::non-blank-string]]])\n\n(mr/def ::external-op\n  [:map\n   [:lib/type [:= :lib/external-op]]\n   [:operator [:or :string :keyword]]\n   [:options {:optional true} ::options]\n   [:args [:sequential :any]]])\n"]}