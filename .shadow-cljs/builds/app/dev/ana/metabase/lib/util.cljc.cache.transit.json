["^ ","~:output",["^ ","~:js","goog.provide('metabase.lib.util');\n/**\n * Exactly like [[clojure.core/format]] but ClojureScript-friendly.\n */\nmetabase.lib.util.format = goog.string.format;\n/**\n * Returns true if this is a clause.\n */\nmetabase.lib.util.clause_QMARK_ = (function metabase$lib$util$clause_QMARK_(clause){\nreturn ((cljs.core.vector_QMARK_(clause)) && ((((cljs.core.count(clause) > (1))) && ((((cljs.core.first(clause) instanceof cljs.core.Keyword)) && (((cljs.core.map_QMARK_(cljs.core.second(clause))) && (cljs.core.contains_QMARK_(cljs.core.second(clause),new cljs.core.Keyword(\"lib\",\"uuid\",\"lib/uuid\",-2145250720))))))))));\n});\n/**\n * Returns true if this is a clause.\n */\nmetabase.lib.util.clause_of_type_QMARK_ = (function metabase$lib$util$clause_of_type_QMARK_(clause,clause_type){\nreturn ((metabase.lib.util.clause_QMARK_(clause)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(clause),clause_type)));\n});\n/**\n * Returns true if this is a field clause.\n */\nmetabase.lib.util.field_clause_QMARK_ = (function metabase$lib$util$field_clause_QMARK_(clause){\nreturn metabase.lib.util.clause_of_type_QMARK_(clause,new cljs.core.Keyword(null,\"field\",\"field\",-1302436500));\n});\n/**\n * Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause.\n */\nmetabase.lib.util.expression_name = (function metabase$lib$util$expression_name(clause){\nif(metabase.lib.util.clause_QMARK_(clause)){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(clause,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),new cljs.core.Keyword(\"lib\",\"expression-name\",\"lib/expression-name\",-1799326590)], null));\n} else {\nreturn null;\n}\n});\n/**\n * Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value.\n */\nmetabase.lib.util.named_expression_clause = (function metabase$lib$util$named_expression_clause(clause,a_name){\nreturn cljs.core.assoc_in(((metabase.lib.util.clause_QMARK_(clause))?clause:new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"uuid\",\"lib/uuid\",-2145250720),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.random_uuid()),new cljs.core.Keyword(null,\"effective-type\",\"effective-type\",-355725458),metabase.lib.schema.expression.type_of(clause)], null),clause], null)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),new cljs.core.Keyword(\"lib\",\"expression-name\",\"lib/expression-name\",-1799326590)], null),a_name);\n});\n/**\n * Replace the `target-clause` in `stage` `location` with `new-clause`.\n * If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n * If `location` contains no clause with `target-clause` no replacement happens.\n */\nmetabase.lib.util.replace_clause = (function metabase$lib$util$replace_clause(stage,location,target_clause,new_clause){\nif(cljs.core.truth_(cljs.core.some_fn.cljs$core$IFn$_invoke$arity$2(metabase.lib.util.clause_QMARK_,(function (p1__64440_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801).cljs$core$IFn$_invoke$arity$1(p1__64440_SHARP_),new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370));\n}))(target_clause))){\n} else {\nthrow (new Error(\"Assert failed: ((some-fn clause? (fn* [p1__64440#] (= (:lib/type p1__64440#) :mbql/join))) target-clause)\"));\n}\n\nvar new_clause__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"expressions\",\"expressions\",255689909),cljs.core.first(location)))?metabase.lib.util.named_expression_clause(new_clause,metabase.lib.util.expression_name(target_clause)):new_clause);\nreturn medley.core.update_existing_in(stage,location,(function (clause_or_clauses){\nreturn cljs.core.vec((function (){var iter__5523__auto__ = (function metabase$lib$util$replace_clause_$_iter__64441(s__64442){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s__64442__$1 = s__64442;\nwhile(true){\nvar temp__5804__auto__ = cljs.core.seq(s__64442__$1);\nif(temp__5804__auto__){\nvar s__64442__$2 = temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(s__64442__$2)){\nvar c__5521__auto__ = cljs.core.chunk_first(s__64442__$2);\nvar size__5522__auto__ = cljs.core.count(c__5521__auto__);\nvar b__64444 = cljs.core.chunk_buffer(size__5522__auto__);\nif((function (){var i__64443 = (0);\nwhile(true){\nif((i__64443 < size__5522__auto__)){\nvar clause = cljs.core._nth(c__5521__auto__,i__64443);\ncljs.core.chunk_append(b__64444,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(metabase.lib.options.uuid(clause),metabase.lib.options.uuid(target_clause)))?new_clause__$1:clause));\n\nvar G__64879 = (i__64443 + (1));\ni__64443 = G__64879;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__64444),metabase$lib$util$replace_clause_$_iter__64441(cljs.core.chunk_rest(s__64442__$2)));\n} else {\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__64444),null);\n}\n} else {\nvar clause = cljs.core.first(s__64442__$2);\nreturn cljs.core.cons(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(metabase.lib.options.uuid(clause),metabase.lib.options.uuid(target_clause)))?new_clause__$1:clause),metabase$lib$util$replace_clause_$_iter__64441(cljs.core.rest(s__64442__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n}),null,null));\n});\nreturn iter__5523__auto__(clause_or_clauses);\n})());\n}));\n});\n/**\n * Remove the `target-clause` in `stage` `location`.\n * If a clause has :lib/uuid equal to the `target-clause` it is removed.\n * If `location` contains no clause with `target-clause` no removal happens.\n * If the the location is empty, dissoc it from stage.\n * For the [:fields] location if only expressions remain, dissoc from stage.\n */\nmetabase.lib.util.remove_clause = (function metabase$lib$util$remove_clause(stage,location,target_clause){\nif(metabase.lib.util.clause_QMARK_(target_clause)){\n} else {\nthrow (new Error(\"Assert failed: (clause? target-clause)\"));\n}\n\nvar temp__5802__auto__ = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(stage,location);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar target = temp__5802__auto__;\nvar target_uuid = metabase.lib.options.uuid(target_clause);\nvar vec__64446 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(location),cljs.core.last(location)], null);\nvar first_loc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__64446,(0),null);\nvar last_loc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__64446,(1),null);\nvar result = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentVector.EMPTY,cljs.core.remove.cljs$core$IFn$_invoke$arity$1(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashSet.createAsIfByAssoc([target_uuid]),metabase.lib.options.uuid)),target);\nvar result__$1 = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(location,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230)], null))) && (cljs.core.every_QMARK_((function (p1__64445_SHARP_){\nreturn metabase.lib.util.clause_of_type_QMARK_(p1__64445_SHARP_,new cljs.core.Keyword(null,\"expression\",\"expression\",202311876));\n}),result))))?null:result);\nif(cljs.core.seq(result__$1)){\nreturn cljs.core.assoc_in(stage,location,result__$1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [first_loc,last_loc], null))){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(metabase.shared.util.i18n.js_i18n(\"Cannot remove the final join condition\"),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270),cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(stage,location)], null));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [first_loc,last_loc], null))){\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(stage,cljs.core.pop(location),cljs.core.dissoc,last_loc);\n} else {\nreturn medley.core.dissoc_in.cljs$core$IFn$_invoke$arity$2(stage,location);\n\n}\n}\n}\n} else {\nreturn stage;\n}\n});\n/**\n * Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n *   explanation of what this means.\n */\nmetabase.lib.util.native_query__GT_pipeline = (function metabase$lib$util$native_query__GT_pipeline(query){\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql.stage\",\"native\",\"mbql.stage/native\",359422194)], null),clojure.set.rename_keys(new cljs.core.Keyword(null,\"native\",\"native\",-613060878).cljs$core$IFn$_invoke$arity$1(query),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"query\",\"query\",-1288509510),new cljs.core.Keyword(null,\"native\",\"native\",-613060878)], null))], 0))], null)], null),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(query,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"native\",\"native\",-613060878)], 0))], 0));\n});\n/**\n * Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`\n */\nmetabase.lib.util.update_legacy_boolean_expression__GT_list = (function metabase$lib$util$update_legacy_boolean_expression__GT_list(m,legacy_key,pMBQL_key){\nvar G__64467 = m;\nvar G__64467__$1 = ((cljs.core.contains_QMARK_(m,legacy_key))?cljs.core.update.cljs$core$IFn$_invoke$arity$3(G__64467,legacy_key,(function (p1__64466_SHARP_){\nif(((cljs.core.vector_QMARK_(p1__64466_SHARP_)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__64466_SHARP_),new cljs.core.Keyword(null,\"and\",\"and\",-971899817))))){\nreturn cljs.core.vec(cljs.core.drop.cljs$core$IFn$_invoke$arity$2((1),p1__64466_SHARP_));\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [p1__64466_SHARP_], null);\n}\n})):G__64467);\nif(cljs.core.contains_QMARK_(m,legacy_key)){\nreturn clojure.set.rename_keys(G__64467__$1,cljs.core.PersistentArrayMap.createAsIfByAssoc([legacy_key,pMBQL_key]));\n} else {\nreturn G__64467__$1;\n}\n});\nmetabase.lib.util.join__GT_pipeline = (function metabase$lib$util$join__GT_pipeline(join){\nvar source = cljs.core.select_keys(join,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692),new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422)], null));\nvar stages = (metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1 ? metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1(source) : metabase.lib.util.inner_query__GT_stages.call(null,source));\nreturn metabase.lib.options.ensure_uuid(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(metabase.lib.util.update_legacy_boolean_expression__GT_list(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(join,new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422)], 0)),new cljs.core.Keyword(null,\"condition\",\"condition\",1668437652),new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270)),new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),stages], 0)));\n});\nmetabase.lib.util.joins__GT_pipeline = (function metabase$lib$util$joins__GT_pipeline(joins){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(metabase.lib.util.join__GT_pipeline,joins);\n});\n/**\n * Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]].\n */\nmetabase.lib.util.__GT_stage_metadata = (function metabase$lib$util$__GT_stage_metadata(source_metadata){\nif(cljs.core.truth_(source_metadata)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.update.cljs$core$IFn$_invoke$arity$3(((cljs.core.seqable_QMARK_(source_metadata))?new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"columns\",\"columns\",1998437288),source_metadata], null):source_metadata),new cljs.core.Keyword(null,\"columns\",\"columns\",1998437288),(function (columns){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (column){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.update_keys(column,metabase.util.__GT_kebab_case_en),new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"metadata\",\"column\",\"metadata/column\",-1799249054));\n}),columns);\n})),new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"metadata\",\"results\",\"metadata/results\",330329298));\n} else {\nreturn null;\n}\n});\nmetabase.lib.util.inner_query__GT_stages = (function metabase$lib$util$inner_query__GT_stages(p__64501){\nvar map__64502 = p__64501;\nvar map__64502__$1 = cljs.core.__destructure_map(map__64502);\nvar inner_query = map__64502__$1;\nvar source_query = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__64502__$1,new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422));\nvar source_metadata = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__64502__$1,new cljs.core.Keyword(null,\"source-metadata\",\"source-metadata\",-477816085));\nvar previous_stages = (cljs.core.truth_(source_query)?(metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1 ? metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1(source_query) : metabase.lib.util.inner_query__GT_stages.call(null,source_query)):cljs.core.PersistentVector.EMPTY);\nvar source_metadata__$1 = metabase.lib.util.__GT_stage_metadata(source_metadata);\nvar previous_stage = (cljs.core.count(previous_stages) - (1));\nvar previous_stages__$1 = (function (){var G__64510 = previous_stages;\nif(cljs.core.truth_((function (){var and__5043__auto__ = source_metadata__$1;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn (!((previous_stage < (0))));\n} else {\nreturn and__5043__auto__;\n}\n})())){\nreturn cljs.core.assoc_in(G__64510,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [previous_stage,new cljs.core.Keyword(\"lib\",\"stage-metadata\",\"lib/stage-metadata\",1079153610)], null),source_metadata__$1);\n} else {\nreturn G__64510;\n}\n})();\nvar stage_type = (cljs.core.truth_(new cljs.core.Keyword(null,\"native\",\"native\",-613060878).cljs$core$IFn$_invoke$arity$1(inner_query))?new cljs.core.Keyword(\"mbql.stage\",\"native\",\"mbql.stage/native\",359422194):new cljs.core.Keyword(\"mbql.stage\",\"mbql\",\"mbql.stage/mbql\",1578747798));\nvar this_stage = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),stage_type], null),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(inner_query,new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"source-metadata\",\"source-metadata\",-477816085)], 0))], 0));\nvar this_stage__$1 = (function (){var G__64513 = this_stage;\nvar G__64513__$1 = ((cljs.core.seq(new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699).cljs$core$IFn$_invoke$arity$1(this_stage)))?cljs.core.update.cljs$core$IFn$_invoke$arity$3(G__64513,new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),metabase.lib.util.joins__GT_pipeline):G__64513);\nreturn metabase.lib.util.update_legacy_boolean_expression__GT_list(G__64513__$1,new cljs.core.Keyword(null,\"filter\",\"filter\",-948537934),new cljs.core.Keyword(null,\"filters\",\"filters\",974726919));\n\n})();\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(previous_stages__$1,this_stage__$1);\n});\n/**\n * Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n *   pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n *   and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n *   Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n *   all of MLv2 deals with pMBQL. See this Slack thread\n *   https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n *   more information.\n */\nmetabase.lib.util.mbql_query__GT_pipeline = (function metabase$lib$util$mbql_query__GT_pipeline(query){\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),metabase.lib.util.inner_query__GT_stages(new cljs.core.Keyword(null,\"query\",\"query\",-1288509510).cljs$core$IFn$_invoke$arity$1(query))], null),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(query,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"query\",\"query\",-1288509510)], 0))], 0));\n});\n/**\n * Schema for a map that is either a legacy query OR a pMBQL query.\n */\nmetabase.lib.util.LegacyOrPMBQLQuery = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"or\",\"or\",235744169),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"map\",\"map\",1371690461),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"error\",\"message\",\"error/message\",-502809098),\"legacy query\"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"enum\",\"enum\",1679018432),new cljs.core.Keyword(null,\"native\",\"native\",-613060878),new cljs.core.Keyword(null,\"query\",\"query\",-1288509510)], null)], null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"map\",\"map\",1371690461),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"error\",\"message\",\"error/message\",-502809098),\"pMBQL query\"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"=\",\"=\",1152933628),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662)], null)], null)], null)], null);\n/**\n * Inputs: [query :- LegacyOrPMBQLQuery]\n *   Return: :any\n *        \n * \n *   Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n *   goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n *   functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n *   process.)\n */\nmetabase.lib.util.pipeline = (function metabase$lib$util$pipeline(query){\n\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801).cljs$core$IFn$_invoke$arity$1(query),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662))){\nreturn query;\n} else {\nvar G__64522 = new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(query);\nvar G__64522__$1 = (((G__64522 instanceof cljs.core.Keyword))?G__64522.fqn:null);\nswitch (G__64522__$1) {\ncase \"native\":\nreturn metabase.lib.util.native_query__GT_pipeline(query);\n\nbreak;\ncase \"query\":\nreturn metabase.lib.util.mbql_query__GT_pipeline(query);\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__64522__$1)].join('')));\n\n}\n}\n});\n/**\n * Inputs: [{:keys [stages], :as _query} :- :map stage-number :- :int]\n *   Return: [:int {:min 0}]\n *        \n * \n *   If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n *   `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc.\n */\nmetabase.lib.util.canonical_stage_index = (function metabase$lib$util$canonical_stage_index(p__64524,stage_number){\nvar map__64525 = p__64524;\nvar map__64525__$1 = cljs.core.__destructure_map(map__64525);\nvar _query = map__64525__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__64525__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\n\nvar stage_number_SINGLEQUOTE_ = (((stage_number < (0)))?(cljs.core.count(stages) + stage_number):stage_number);\nif((((stage_number_SINGLEQUOTE_ >= cljs.core.count(stages))) || ((stage_number_SINGLEQUOTE_ < (0))))){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(metabase.shared.util.i18n.js_i18n.cljs$core$IFn$_invoke$arity$variadic(\"Stage {0} does not exist\",cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([stage_number], 0)),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"num-stages\",\"num-stages\",1426797535),cljs.core.count(stages)], null));\n} else {\n}\n\nreturn stage_number_SINGLEQUOTE_;\n});\n/**\n * Inputs: [query :- :map stage-number :- :int]\n *   Return: [:maybe [:int {:min 0}]]\n *        \n * \n *   The index of the previous stage, if there is one. `nil` if there is no previous stage.\n */\nmetabase.lib.util.previous_stage_number = (function metabase$lib$util$previous_stage_number(query,stage_number){\n\nvar stage_number__$1 = metabase.lib.util.canonical_stage_index(query,stage_number);\nif((stage_number__$1 > (0))){\nreturn (stage_number__$1 - (1));\n} else {\nreturn null;\n}\n});\n/**\n * Whether a `stage-number` is referring to the first stage of a query or not.\n */\nmetabase.lib.util.first_stage_QMARK_ = (function metabase$lib$util$first_stage_QMARK_(query,stage_number){\nreturn cljs.core.not(metabase.lib.util.previous_stage_number(query,stage_number));\n});\n/**\n * The index of the next stage, if there is one. `nil` if there is no next stage.\n */\nmetabase.lib.util.next_stage_number = (function metabase$lib$util$next_stage_number(p__64527,stage_number){\nvar map__64528 = p__64527;\nvar map__64528__$1 = cljs.core.__destructure_map(map__64528);\nvar _query = map__64528__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__64528__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nvar stage_number__$1 = (((stage_number < (0)))?(cljs.core.count(stages) + stage_number):stage_number);\nif(((stage_number__$1 + (1)) < cljs.core.count(stages))){\nreturn (stage_number__$1 + (1));\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int]\n *   Return: :metabase.lib.schema/stage\n *        \n * \n *   Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n *   the query.\n */\nmetabase.lib.util.query_stage = (function metabase$lib$util$query_stage(query,stage_number){\n\nvar map__64530 = metabase.lib.util.pipeline(query);\nvar map__64530__$1 = cljs.core.__destructure_map(map__64530);\nvar query__$1 = map__64530__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__64530__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(stages),metabase.lib.util.canonical_stage_index(query__$1,stage_number));\n});\n/**\n * Inputs: [query stage-number :- :int]\n *   Return: [:maybe :metabase.lib.schema/stage]\n *        \n * \n *   Return the previous stage of the query, if there is one; otherwise return `nil`.\n */\nmetabase.lib.util.previous_stage = (function metabase$lib$util$previous_stage(query,stage_number){\n\nvar temp__5804__auto__ = metabase.lib.util.previous_stage_number(query,stage_number);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar stage_num = temp__5804__auto__;\nreturn metabase.lib.util.query_stage(query,stage_num);\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int f & args]\n *   Return: :metabase.lib.schema/query\n *        \n * \n *   Update a specific `stage-number` of a `query` by doing\n * \n *  (apply f stage args)\n * \n *   `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query.\n */\nmetabase.lib.util.update_query_stage = (function metabase$lib$util$update_query_stage(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___64907 = arguments.length;\nvar i__5770__auto___64908 = (0);\nwhile(true){\nif((i__5770__auto___64908 < len__5769__auto___64907)){\nargs__5775__auto__.push((arguments[i__5770__auto___64908]));\n\nvar G__64909 = (i__5770__auto___64908 + (1));\ni__5770__auto___64908 = G__64909;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((3) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((3)),(0),null)):null);\nreturn metabase.lib.util.update_query_stage.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__5776__auto__);\n});\n\n(metabase.lib.util.update_query_stage.cljs$core$IFn$_invoke$arity$variadic = (function (query,stage_number,f,args){\n\nvar map__64539 = metabase.lib.util.pipeline(query);\nvar map__64539__$1 = cljs.core.__destructure_map(map__64539);\nvar query__$1 = map__64539__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__64539__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nvar stage_number_SINGLEQUOTE_ = metabase.lib.util.canonical_stage_index(query__$1,stage_number);\nvar stages_SINGLEQUOTE_ = cljs.core.apply.cljs$core$IFn$_invoke$arity$5(cljs.core.update,cljs.core.vec(stages),stage_number_SINGLEQUOTE_,f,args);\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(query__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),stages_SINGLEQUOTE_);\n}));\n\n(metabase.lib.util.update_query_stage.cljs$lang$maxFixedArity = (3));\n\n/** @this {Function} */\n(metabase.lib.util.update_query_stage.cljs$lang$applyTo = (function (seq64535){\nvar G__64536 = cljs.core.first(seq64535);\nvar seq64535__$1 = cljs.core.next(seq64535);\nvar G__64537 = cljs.core.first(seq64535__$1);\nvar seq64535__$2 = cljs.core.next(seq64535__$1);\nvar G__64538 = cljs.core.first(seq64535__$2);\nvar seq64535__$3 = cljs.core.next(seq64535__$2);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__64536,G__64537,G__64538,seq64535__$3);\n}));\n\n/**\n * Inputs: [query]\n *   Return: :metabase.lib.schema/query\n *        \n * \n *   Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one.\n */\nmetabase.lib.util.ensure_mbql_final_stage = (function metabase$lib$util$ensure_mbql_final_stage(query){\n\nvar query__$1 = metabase.lib.util.pipeline(query);\nvar G__64541 = query__$1;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801).cljs$core$IFn$_invoke$arity$1(metabase.lib.util.query_stage(query__$1,(-1))),new cljs.core.Keyword(\"mbql.stage\",\"native\",\"mbql.stage/native\",359422194))){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(G__64541,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),cljs.core.conj,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql.stage\",\"mbql\",\"mbql.stage/mbql\",1578747798)], null));\n} else {\nreturn G__64541;\n}\n});\n/**\n * This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n *   by a string `conjunction`. Uses Oxford commas for > 2 args.\n * \n *   (join-strings-with-conjunction \"and\" [\"X\" \"Y\" \"Z\"])\n *   ;; => \"X, Y, and Z\"\n */\nmetabase.lib.util.join_strings_with_conjunction = (function metabase$lib$util$join_strings_with_conjunction(conjunction,coll){\nif(cljs.core.seq(coll)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(coll),(1))){\nreturn cljs.core.first(coll);\n} else {\nvar conjunction__$1 = [\" \",clojure.string.trim(conjunction),\" \"].join('');\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(coll),(2))){\nreturn [cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(coll)),conjunction__$1,cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.second(coll))].join('');\n} else {\nreturn [clojure.string.join.cljs$core$IFn$_invoke$arity$2(\", \",cljs.core.butlast(coll)),\",\",conjunction__$1,cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.last(coll))].join('');\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [s :- :string]\n *   Return: [:int {:min 0}]\n *        \n * \n *   Number of bytes in a string using UTF-8 encoding.\n */\nmetabase.lib.util.string_byte_count = (function metabase$lib$util$string_byte_count(s){\n\nreturn (new TextEncoder()).encode(s).length;\n});\n/**\n * Inputs: [s :- :string max-length-bytes :- [:int {:min 1}]]\n *   Return: :string\n *        \n * \n *   Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n *   *characters*).\n */\nmetabase.lib.util.truncate_string_to_byte_count = (function metabase$lib$util$truncate_string_to_byte_count(s,max_length_bytes){\n\nvar buf = (new Uint8Array(max_length_bytes));\nvar result = (new TextEncoder()).encodeInto(s,buf);\nreturn cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s,(0),result.read);\n});\n/**\n * Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n *   reasoning.\n */\nmetabase.lib.util.truncate_alias_max_length_bytes = (60);\n/**\n * Length of the hash suffixed to truncated strings by [[truncate-alias]].\n */\nmetabase.lib.util.truncated_alias_hash_suffix_length = (9);\n/**\n * Inputs: [s :- :string]\n *   Return: [:string {:min 8, :max 8}]\n *        \n * \n *   Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string.\n */\nmetabase.lib.util.crc32_checksum = (function metabase$lib$util$crc32_checksum(s){\n\nvar s__$1 = (shadow.js.shim.module$crc_32.str(s,(0)) >>> (0)).toString((16));\nvar s__$2 = s__$1;\nwhile(true){\nif((cljs.core.count(s__$2) < (8))){\nvar G__64910 = [\"0\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(s__$2)].join('');\ns__$2 = G__64910;\ncontinue;\n} else {\nreturn s__$2;\n}\nbreak;\n}\n});\n/**\n * Inputs: ([s]\n *         [s :- :metabase.lib.schema.common/non-blank-string max-bytes :- [:int {:min 0}]])\n *   Return: [:string {:min 1, :max 60}]\n *        \n * \n *   Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n *   checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n *   minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n *   exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n *   end will still have different resulting values.\n * \n *  (truncate-alias \"some_really_long_string\" 15) ;   -> \"some_r_8e0f9bc2\"\n *  (truncate-alias \"some_really_long_string_2\" 15) ; -> \"some_r_2a3c73eb\"\n */\nmetabase.lib.util.truncate_alias = (function metabase$lib$util$truncate_alias(var_args){\nvar G__64631 = arguments.length;\nswitch (G__64631) {\ncase 1:\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$1 = (function (s){\n\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$2(s,metabase.lib.util.truncate_alias_max_length_bytes);\n}));\n\n(metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$2 = (function (s,max_bytes){\n\nif((metabase.lib.util.string_byte_count(s) <= max_bytes)){\nreturn s;\n} else {\nvar checksum = metabase.lib.util.crc32_checksum(s);\nvar truncated = metabase.lib.util.truncate_string_to_byte_count(s,(max_bytes - metabase.lib.util.truncated_alias_hash_suffix_length));\nreturn [truncated,\"_\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(checksum)].join('');\n}\n}));\n\n(metabase.lib.util.truncate_alias.cljs$lang$maxFixedArity = 2);\n\n/**\n * Inputs: [table-id]\n *   Return: [:maybe :metabase.lib.schema.id/card]\n *        \n * \n *   If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n *   queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n *   `:source-card`.\n */\nmetabase.lib.util.legacy_string_table_id__GT_card_id = (function metabase$lib$util$legacy_string_table_id__GT_card_id(table_id){\n\nif(typeof table_id === 'string'){\nvar temp__5804__auto__ = cljs.core.re_find(/^card__(\\d+)$/,table_id);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar vec__64669 = temp__5804__auto__;\nvar _match = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__64669,(0),null);\nvar card_id_str = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__64669,(1),null);\nreturn cljs.core.parse_long(card_id_str);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [query]\n *   Return: [:maybe :metabase.lib.schema.id/table]\n *        \n * \n *   If this query has a `:source-table` ID, return it.\n */\nmetabase.lib.util.source_table_id = (function metabase$lib$util$source_table_id(query){\n\nreturn new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692).cljs$core$IFn$_invoke$arity$1(cljs.core.first(new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532).cljs$core$IFn$_invoke$arity$1(query)));\n});\n/**\n * Inputs: [query]\n *   Return: [:maybe :metabase.lib.schema.id/card]\n *        \n * \n *   If this query has a `:source-card` ID, return it.\n */\nmetabase.lib.util.source_card_id = (function metabase$lib$util$source_card_id(query){\n\nreturn new cljs.core.Keyword(null,\"source-card\",\"source-card\",-1580820390).cljs$core$IFn$_invoke$arity$1(cljs.core.first(new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532).cljs$core$IFn$_invoke$arity$1(query)));\n});\n/**\n * Inputs: []\n *   Return: [:=> [:cat :metabase.lib.schema.common/non-blank-string] :metabase.lib.schema.common/non-blank-string]\n *        \n * \n *   Create a new function with the signature\n * \n *  (f str) => str\n * \n *   That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n *   name truncated to 60 characters (actually 51 characters plus a hash).\n */\nmetabase.lib.util.unique_name_generator = (function metabase$lib$util$unique_name_generator(){\n\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2(metabase.lib.util.truncate_alias,metabase.mbql.util.unique_name_generator.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"name-key-fn\",\"name-key-fn\",-1634839199),metabase.util.lower_case_en,new cljs.core.Keyword(null,\"unique-alias-fn\",\"unique-alias-fn\",32555420),(function (original,suffix){\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$1([cljs.core.str.cljs$core$IFn$_invoke$arity$1(original),\"_\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(suffix)].join(''));\n})], 0)));\n});\nmetabase.lib.util.strip_id_regex = (new RegExp(\" id$\",\"i\"));\n/**\n * Inputs: [display-name :- :string]\n *   Return: :string\n *        \n * \n *   Given a display name string like \"Product ID\", this will drop the trailing \"ID\" and trim whitespace.\n *   Used to turn a FK field's name into a pseudo table name when implicitly joining.\n */\nmetabase.lib.util.strip_id = (function metabase$lib$util$strip_id(display_name){\n\nreturn clojure.string.trim(clojure.string.replace(display_name,metabase.lib.util.strip_id_regex,\"\"));\n});\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int location :- [:enum :breakout :aggregation] a-summary-clause]\n *   Return: :metabase.lib.schema/query\n *        \n * \n *   If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n * as well as any subsequent stages.\n */\nmetabase.lib.util.add_summary_clause = (function metabase$lib$util$add_summary_clause(query,stage_number,location,a_summary_clause){\n\nvar query__$1 = metabase.lib.util.pipeline(query);\nvar stage_number__$1 = (function (){var or__5045__auto__ = stage_number;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn (-1);\n}\n})();\nvar stage = metabase.lib.util.query_stage(query__$1,stage_number__$1);\nvar new_summary_QMARK_ = (!(((cljs.core.seq(new cljs.core.Keyword(null,\"aggregation\",\"aggregation\",1597476696).cljs$core$IFn$_invoke$arity$1(stage))) || (cljs.core.seq(new cljs.core.Keyword(null,\"breakout\",\"breakout\",-732419050).cljs$core$IFn$_invoke$arity$1(stage))))));\nvar new_query = metabase.lib.util.update_query_stage.cljs$core$IFn$_invoke$arity$variadic(query__$1,stage_number__$1,cljs.core.update,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([location,(function (summary_clauses){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(summary_clauses),metabase.lib.common.__GT_op_arg.cljs$core$IFn$_invoke$arity$1(a_summary_clause));\n})], 0));\nif(new_summary_QMARK_){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$5(metabase.lib.util.update_query_stage(new_query,stage_number__$1,(function (stage__$1){\nreturn medley.core.update_existing.cljs$core$IFn$_invoke$arity$3(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(stage__$1,new cljs.core.Keyword(null,\"order-by\",\"order-by\",1527318070),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230)], 0)),new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),(function (joins){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__64708_SHARP_){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(p1__64708_SHARP_,new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230));\n}),joins);\n}));\n})),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),cljs.core.comp.cljs$core$IFn$_invoke$arity$2((function (p1__64709_SHARP_){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,p1__64709_SHARP_);\n}),cljs.core.subvec),(0),(metabase.lib.util.canonical_stage_index(query__$1,stage_number__$1) + (1)));\n} else {\nreturn new_query;\n}\n});\n/**\n * Adds a default :effective-type property if it does not exist and\n *   :base-type is known.\n * \n *   This is needed only because we have to convert queries to the Legacy\n *   form.\n *   The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n *   :effective-type property, but it should be present for the frontend\n *   to work. It defaults to the :base-type property.\n */\nmetabase.lib.util.with_default_effective_type = (function metabase$lib$util$with_default_effective_type(clause){\nvar options = metabase.lib.options.options(clause);\nvar default_effective_type = (cljs.core.truth_(new cljs.core.Keyword(null,\"effective-type\",\"effective-type\",-355725458).cljs$core$IFn$_invoke$arity$1(options))?null:new cljs.core.Keyword(null,\"base-type\",\"base-type\",1167971299).cljs$core$IFn$_invoke$arity$1(options));\nvar G__64754 = clause;\nif(cljs.core.truth_(default_effective_type)){\nreturn metabase.lib.options.update_options.cljs$core$IFn$_invoke$arity$variadic(G__64754,cljs.core.assoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"effective-type\",\"effective-type\",-355725458),default_effective_type], 0));\n} else {\nreturn G__64754;\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","metabase/lib/util.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",22],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.core","~$cljs.core","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.core.match","~$cljs.core.match"],"~:use-macros",null,"~:excludes",["~#set",["~$format"]],"~:name","~$metabase.lib.util","~:reader-aliases",["^ "],"~:js-aliases",["^ ","crc-32","~$shadow.js.shim.module$crc_32"],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$metabase.lib.schema","^V","~$mu","~$metabase.util.malli","~$set","~$clojure.set","~$gstring","~$goog.string","~$i18n","~$metabase.shared.util.i18n","~$lib.schema.common","~$metabase.lib.schema.common","~$u","~$metabase.util","~$lib.schema.expression","~$metabase.lib.schema.expression","~$metabase.mbql.util","^18","^10","^10","~$mbql.u","^18","~$lib.common","~$metabase.lib.common","^C","^C","~$goog","^1<","~$lib.schema","^V","^14","^14","~$lib.options","~$metabase.lib.options","^17","^17","~$metabase.lib.schema.id","^1@","^Z","^Z","~$m","~$medley.core","^15","^15","^1;","^1;","^12","^12","^Q","^Q","~$goog.string.format","^1B","^X","^X","~$gstring.format","^1B","~$str","~$clojure.string","~$lib.schema.id","^1@","^1?","^1?","^1E","^1E","^1A","^1A","~$CRC32","^Q"],"~:seen",["^J",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^W","^X","^11","^12","~$u","^15","^16","^17","^1:","^1;","^C","^C","^17","^17","^15","^15","^1;","^1;","^12","^12","^X","^X"],"~:form",["~#list",["~$ns","^M",["^1M",["~:refer-clojure","~:exclude",["^K"]]],["^1M",["^1I",["crc-32","~:as","^1G"],["^10","^1Q","^["],["^1B","^1Q","^1C"],["^Z","^1Q","^Y"],["^1E","^1Q","^1D"],["^1A","^1Q","~$m"],["^1;","^1Q","^1:"],["^1?","^1Q","^1>"],["^V","^1Q","^1="],["^14","^1Q","^13"],["^17","^1Q","^16"],["^1@","^1Q","^1F"],["^18","^1Q","^19"],["^12","^1Q","^11"],["^15","^1Q","~$u"],["^X","^1Q","^W"]]]]],"~:flags",["^ ","^1I",["^J",[]]],"~:js-deps",["^ ","^P",["^ ","^1Q","^1G"]],"~:deps",["^1<","^C","^Q","^10","^1B","^Z","^1E","^1A","^1;","^1?","^V","^14","^17","^1@","^18","^12","^15","^X"]],"^S","^M","~:resource-id",["~:shadow.build.classpath/resource","metabase/lib/util.cljc"],"~:compiled-at",1692014617313,"^N",["^ ","^V","^V","^W","^X","^Y","^Z","^[","^10","^11","^12","^13","^14","~$u","^15","^16","^17","^18","^18","^10","^10","^19","^18","^1:","^1;","^C","^C","^1<","^1<","^1=","^V","^14","^14","^1>","^1?","^17","^17","^1@","^1@","^Z","^Z","~$m","^1A","^15","^15","^1;","^1;","^12","^12","^Q","^Q","^1B","^1B","^X","^X","^1C","^1B","^1D","^1E","^1F","^1@","^1?","^1?","^1E","^1E","^1A","^1A","^1G","^Q"],"~:resource-name","metabase/lib/util.cljc","~:warnings",[],"~:source","(ns metabase.lib.util\n  (:refer-clojure :exclude [format])\n  (:require\n   #?@(:clj\n       ([potemkin :as p]))\n   #?@(:cljs\n       ([\"crc-32\" :as CRC32]\n        [goog.string :as gstring]\n        [goog.string.format :as gstring.format]))\n   [clojure.set :as set]\n   [clojure.string :as str]\n   [medley.core :as m]\n   [metabase.lib.common :as lib.common]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.expression :as lib.schema.expression]\n   [metabase.lib.schema.id :as lib.schema.id]\n   [metabase.mbql.util :as mbql.u]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util :as u]\n   [metabase.util.malli :as mu]))\n\n#?(:clj\n   (set! *warn-on-reflection* true))\n\n;; The formatting functionality is only loaded if you depend on goog.string.format.\n#?(:cljs (comment gstring.format/keep-me))\n\n;;; For convenience: [[metabase.lib.util/format]] maps to [[clojure.core/format]] in Clj and [[goog.string/format]] in\n;;; Cljs. They both work like [[clojure.core/format]], but since that doesn't exist in Cljs, you can use this instead.\n#?(:clj\n   (p/import-vars [clojure.core format])\n\n   :cljs\n   (def format \"Exactly like [[clojure.core/format]] but ClojureScript-friendly.\" gstring/format))\n\n(defn clause?\n  \"Returns true if this is a clause.\"\n  [clause]\n  (and (vector? clause)\n       (> (count clause) 1)\n       (keyword? (first clause))\n       (map? (second clause))\n       (contains? (second clause) :lib/uuid)))\n\n(defn clause-of-type?\n  \"Returns true if this is a clause.\"\n  [clause clause-type]\n  (and (clause? clause)\n       (= (first clause) clause-type)))\n\n(defn field-clause?\n  \"Returns true if this is a field clause.\"\n  [clause]\n  (clause-of-type? clause :field))\n\n(defn expression-name\n  \"Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause.\"\n  [clause]\n  (when (clause? clause)\n    (get-in clause [1 :lib/expression-name])))\n\n(defn named-expression-clause\n  \"Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value.\"\n  [clause a-name]\n  (assoc-in\n    (if (clause? clause)\n      clause\n      [:value {:lib/uuid (str (random-uuid))\n               :effective-type (lib.schema.expression/type-of clause)}\n       clause])\n    [1 :lib/expression-name] a-name))\n\n(defn replace-clause\n  \"Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens.\"\n  [stage location target-clause new-clause]\n  {:pre [((some-fn clause? #(= (:lib/type %) :mbql/join)) target-clause)]}\n  (let [new-clause (if (= :expressions (first location))\n                     (named-expression-clause new-clause (expression-name target-clause))\n                     new-clause)]\n    (m/update-existing-in\n      stage\n      location\n      (fn [clause-or-clauses]\n        (->> (for [clause clause-or-clauses]\n               (if (= (lib.options/uuid clause) (lib.options/uuid target-clause))\n                 new-clause\n                 clause))\n             vec)))))\n\n(defn remove-clause\n  \"Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage.\"\n  [stage location target-clause]\n  {:pre [(clause? target-clause)]}\n  (if-let [target (get-in stage location)]\n    (let [target-uuid (lib.options/uuid target-clause)\n          [first-loc last-loc] [(first location) (last location)]\n          result (into [] (remove (comp #{target-uuid} lib.options/uuid)) target)\n          result (when-not (and (= location [:fields])\n                                (every? #(clause-of-type? % :expression) result))\n                   result)]\n      (cond\n        (seq result)\n        (assoc-in stage location result)\n\n        (= [:joins :conditions] [first-loc last-loc])\n        (throw (ex-info (i18n/tru \"Cannot remove the final join condition\")\n                        {:conditions (get-in stage location)}))\n\n        (= [:joins :fields] [first-loc last-loc])\n        (update-in stage (pop location) dissoc last-loc)\n\n        :else\n        (m/dissoc-in stage location)))\n    stage))\n\n;;; TODO -- all of this `->pipeline` stuff should probably be merged into [[metabase.lib.convert]] at some point in\n;;; the near future.\n\n(defn- native-query->pipeline\n  \"Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n          ;; readability in the REPL.\n          :stages   [(merge {:lib/type :mbql.stage/native}\n                            (set/rename-keys (:native query) {:query :native}))]}\n         (dissoc query :type :native)))\n\n(declare inner-query->stages)\n\n(defn- update-legacy-boolean-expression->list\n  \"Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`\"\n  [m legacy-key pMBQL-key]\n  (cond-> m\n    (contains? m legacy-key) (update legacy-key #(if (and (vector? %)\n                                                       (= (first %) :and))\n                                                   (vec (drop 1 %))\n                                                   [%]))\n    (contains? m legacy-key) (set/rename-keys {legacy-key pMBQL-key})))\n\n(defn- join->pipeline [join]\n  (let [source (select-keys join [:source-table :source-query])\n        stages (inner-query->stages source)]\n    (-> join\n        (dissoc :source-table :source-query)\n        (update-legacy-boolean-expression->list :condition :conditions)\n        (assoc :lib/type :mbql/join\n               :stages stages)\n        lib.options/ensure-uuid)))\n\n(defn- joins->pipeline [joins]\n  (mapv join->pipeline joins))\n\n(defn ->stage-metadata\n  \"Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]].\"\n  [source-metadata]\n  (when source-metadata\n    (-> (if (seqable? source-metadata)\n          {:columns source-metadata}\n          source-metadata)\n        (update :columns (fn [columns]\n                           (mapv (fn [column]\n                                   (-> column\n                                       (update-keys u/->kebab-case-en)\n                                       (assoc :lib/type :metadata/column)))\n                                 columns)))\n        (assoc :lib/type :metadata/results))))\n\n(defn- inner-query->stages [{:keys [source-query source-metadata], :as inner-query}]\n  (let [previous-stages (if source-query\n                          (inner-query->stages source-query)\n                          [])\n        source-metadata (->stage-metadata source-metadata)\n        previous-stage  (dec (count previous-stages))\n        previous-stages (cond-> previous-stages\n                          (and source-metadata\n                               (not (neg? previous-stage))) (assoc-in [previous-stage :lib/stage-metadata] source-metadata))\n        stage-type      (if (:native inner-query)\n                          :mbql.stage/native\n                          :mbql.stage/mbql)\n        ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n        ;; readability in the REPL.\n        this-stage      (merge {:lib/type stage-type}\n                               (dissoc inner-query :source-query :source-metadata))\n        this-stage      (cond-> this-stage\n                          (seq (:joins this-stage)) (update :joins joins->pipeline)\n                          :always (update-legacy-boolean-expression->list :filter :filters))]\n    (conj previous-stages this-stage)))\n\n(defn- mbql-query->pipeline\n  \"Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          :stages   (inner-query->stages (:query query))}\n         (dissoc query :type :query)))\n\n(def LegacyOrPMBQLQuery\n  \"Schema for a map that is either a legacy query OR a pMBQL query.\"\n  [:or\n   [:map\n    {:error/message \"legacy query\"}\n    [:type [:enum :native :query]]]\n   [:map\n    {:error/message \"pMBQL query\"}\n    [:lib/type [:= :mbql/query]]]])\n\n(mu/defn pipeline\n  \"Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)\"\n  [query :- LegacyOrPMBQLQuery]\n  (if (= (:lib/type query) :mbql/query)\n    query\n    (case (:type query)\n      :native (native-query->pipeline query)\n      :query  (mbql-query->pipeline query))))\n\n(mu/defn canonical-stage-index :- [:int {:min 0}]\n  \"If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc.\"\n  [{:keys [stages], :as _query} :- :map\n   stage-number                 :- :int]\n  (let [stage-number' (if (neg? stage-number)\n                        (+ (count stages) stage-number)\n                        stage-number)]\n    (when (or (>= stage-number' (count stages))\n              (neg? stage-number'))\n      (throw (ex-info (i18n/tru \"Stage {0} does not exist\" stage-number)\n                      {:num-stages (count stages)})))\n    stage-number'))\n\n(mu/defn previous-stage-number :- [:maybe [:int {:min 0}]]\n  \"The index of the previous stage, if there is one. `nil` if there is no previous stage.\"\n  [query        :- :map\n   stage-number :- :int]\n  (let [stage-number (canonical-stage-index query stage-number)]\n    (when (pos? stage-number)\n      (dec stage-number))))\n\n(defn first-stage?\n  \"Whether a `stage-number` is referring to the first stage of a query or not.\"\n  [query stage-number]\n  (not (previous-stage-number query stage-number)))\n\n(defn next-stage-number\n  \"The index of the next stage, if there is one. `nil` if there is no next stage.\"\n  [{:keys [stages], :as _query} stage-number]\n  (let [stage-number (if (neg? stage-number)\n                       (+ (count stages) stage-number)\n                       stage-number)]\n    (when (< (inc stage-number) (count stages))\n      (inc stage-number))))\n\n(mu/defn query-stage :- ::lib.schema/stage\n  \"Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int]\n  (let [{:keys [stages], :as query} (pipeline query)]\n    (get (vec stages) (canonical-stage-index query stage-number))))\n\n(mu/defn previous-stage :- [:maybe ::lib.schema/stage]\n  \"Return the previous stage of the query, if there is one; otherwise return `nil`.\"\n  [query stage-number :- :int]\n  (when-let [stage-num (previous-stage-number query stage-number)]\n    (query-stage query stage-num)))\n\n(mu/defn update-query-stage :- ::lib.schema/query\n  \"Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int\n   f & args]\n  (let [{:keys [stages], :as query} (pipeline query)\n        stage-number'               (canonical-stage-index query stage-number)\n        stages'                     (apply update (vec stages) stage-number' f args)]\n    (assoc query :stages stages')))\n\n(mu/defn ensure-mbql-final-stage :- ::lib.schema/query\n  \"Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one.\"\n  [query]\n  (let [query (pipeline query)]\n    (cond-> query\n      (= (:lib/type (query-stage query -1)) :mbql.stage/native)\n      (update :stages conj {:lib/type :mbql.stage/mbql}))))\n\n(defn join-strings-with-conjunction\n  \"This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \\\"and\\\" [\\\"X\\\" \\\"Y\\\" \\\"Z\\\"])\n  ;; => \\\"X, Y, and Z\\\"\"\n  [conjunction coll]\n  (when (seq coll)\n    (if (= (count coll) 1)\n      (first coll)\n      (let [conjunction (str \\space (str/trim conjunction) \\space)]\n        (if (= (count coll) 2)\n          ;; exactly 2 args: X and Y\n          (str (first coll) conjunction (second coll))\n          ;; > 2 args: X, Y, and Z\n          (str\n           (str/join \", \" (butlast coll))\n           \",\"\n           conjunction\n           (last coll)))))))\n\n(mu/defn ^:private string-byte-count :- [:int {:min 0}]\n  \"Number of bytes in a string using UTF-8 encoding.\"\n  [s :- :string]\n  #?(:clj (count (.getBytes (str s) \"UTF-8\"))\n     :cljs (.. (js/TextEncoder.) (encode s) -length)))\n\n#?(:clj\n   (mu/defn ^:private string-character-at :- [:string {:min 0, :max 1}]\n     [s :- :string\n      i :-[:int {:min 0}]]\n     (str (.charAt ^String s i))))\n\n(mu/defn ^:private truncate-string-to-byte-count :- :string\n  \"Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n  *characters*).\"\n  [s                :- :string\n   max-length-bytes :- [:int {:min 1}]]\n  #?(:clj\n     (loop [i 0, cumulative-byte-count 0]\n       (cond\n         (= cumulative-byte-count max-length-bytes) (subs s 0 i)\n         (> cumulative-byte-count max-length-bytes) (subs s 0 (dec i))\n         (>= i (count s))                           s\n         :else                                      (recur (inc i)\n                                                           (long (+\n                                                                  cumulative-byte-count\n                                                                  (string-byte-count (string-character-at s i)))))))\n\n     :cljs\n     (let [buf (js/Uint8Array. max-length-bytes)\n           result (.encodeInto (js/TextEncoder.) s buf)] ;; JS obj {read: chars_converted, write: bytes_written}\n       (subs s 0 (.-read result)))))\n\n(def ^:private truncate-alias-max-length-bytes\n  \"Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n  reasoning.\"\n  60)\n\n(def ^:private truncated-alias-hash-suffix-length\n  \"Length of the hash suffixed to truncated strings by [[truncate-alias]].\"\n  ;; 8 bytes for the CRC32 plus one for the underscore\n  9)\n\n(mu/defn ^:private crc32-checksum :- [:string {:min 8, :max 8}]\n  \"Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string.\"\n  [s :- :string]\n  (let [s #?(:clj (Long/toHexString (.getValue (doto (java.util.zip.CRC32.)\n                                                 (.update (.getBytes ^String s \"UTF-8\")))))\n             :cljs (-> (CRC32/str s 0)\n                       (unsigned-bit-shift-right 0) ; see https://github.com/SheetJS/js-crc32#signed-integers\n                       (.toString 16)))]\n    ;; pad to 8 characters if needed. Might come out as less than 8 if the first byte is `00` or `0x` or something.\n    (loop [s s]\n      (if (< (count s) 8)\n        (recur (str \\0 s))\n        s))))\n\n(mu/defn truncate-alias :- [:string {:min 1, :max 60}]\n  \"Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \\\"some_really_long_string\\\" 15) ;   -> \\\"some_r_8e0f9bc2\\\"\n    (truncate-alias \\\"some_really_long_string_2\\\" 15) ; -> \\\"some_r_2a3c73eb\\\"\"\n  ([s]\n   (truncate-alias s truncate-alias-max-length-bytes))\n\n  ([s         :- ::lib.schema.common/non-blank-string\n    max-bytes :- [:int {:min 0}]]\n   (if (<= (string-byte-count s) max-bytes)\n     s\n     (let [checksum  (crc32-checksum s)\n           truncated (truncate-string-to-byte-count s (- max-bytes truncated-alias-hash-suffix-length))]\n       (str truncated \\_ checksum)))))\n\n(mu/defn legacy-string-table-id->card-id :- [:maybe ::lib.schema.id/card]\n  \"If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`.\"\n  [table-id]\n  (when (string? table-id)\n    (when-let [[_match card-id-str] (re-find #\"^card__(\\d+)$\" table-id)]\n      (parse-long card-id-str))))\n\n(mu/defn source-table-id :- [:maybe ::lib.schema.id/table]\n  \"If this query has a `:source-table` ID, return it.\"\n  [query]\n  (-> query :stages first :source-table))\n\n(mu/defn source-card-id :- [:maybe ::lib.schema.id/card]\n  \"If this query has a `:source-card` ID, return it.\"\n  [query]\n  (-> query :stages first :source-card))\n\n(mu/defn unique-name-generator :- [:=>\n                                   [:cat ::lib.schema.common/non-blank-string]\n                                   ::lib.schema.common/non-blank-string]\n  \"Create a new function with the signature\n\n    (f str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash).\"\n  []\n  (comp truncate-alias\n        (mbql.u/unique-name-generator\n         ;; unique by lower-case name, e.g. `NAME` and `name` => `NAME` and `name_2`\n         :name-key-fn     u/lower-case-en\n         ;; truncate alias to 60 characters (actually 51 characters plus a hash).\n         :unique-alias-fn (fn [original suffix]\n                            (truncate-alias (str original \\_ suffix))))))\n\n(def ^:private strip-id-regex\n  #?(:cljs (js/RegExp. \" id$\" \"i\")\n     ;; `(?i)` is JVM-specific magic to turn on the `i` case-insensitive flag.\n     :clj  #\"(?i) id$\"))\n\n(mu/defn strip-id :- :string\n  \"Given a display name string like \\\"Product ID\\\", this will drop the trailing \\\"ID\\\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining.\"\n  [display-name :- :string]\n  (-> display-name\n      (str/replace strip-id-regex \"\")\n      str/trim))\n\n(mu/defn add-summary-clause :- ::lib.schema/query\n  \"If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages.\"\n  [query :- ::lib.schema/query\n   stage-number :- :int\n   location :- [:enum :breakout :aggregation]\n   a-summary-clause]\n  (let [query (pipeline query)\n        stage-number (or stage-number -1)\n        stage (query-stage query stage-number)\n        new-summary? (not (or (seq (:aggregation stage)) (seq (:breakout stage))))\n        new-query (update-query-stage\n                    query stage-number\n                    update location\n                    (fn [summary-clauses]\n                      (conj (vec summary-clauses) (lib.common/->op-arg a-summary-clause))))]\n    (if new-summary?\n      (-> new-query\n          (update-query-stage\n            stage-number\n            (fn [stage]\n              (-> stage\n                  (dissoc :order-by :fields)\n                  (m/update-existing :joins (fn [joins] (mapv #(dissoc % :fields) joins))))))\n          ;; subvec holds onto references, so create a new vector\n          (update :stages (comp #(into [] %) subvec) 0 (inc (canonical-stage-index query stage-number))))\n      new-query)))\n\n(defn with-default-effective-type\n  \"Adds a default :effective-type property if it does not exist and\n  :base-type is known.\n\n  This is needed only because we have to convert queries to the Legacy\n  form.\n  The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n  :effective-type property, but it should be present for the frontend\n  to work. It defaults to the :base-type property.\"\n  [clause]\n  (let [options (lib.options/options clause)\n        default-effective-type (when-not (:effective-type options)\n                                 (:base-type options))]\n    (cond-> clause\n      default-effective-type\n      (lib.options/update-options assoc :effective-type default-effective-type))))\n","~:reader-features",["^J",["~:cljs-release","~:cljs-dev","~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["metabase.lib.util/format","goog.string/format","metabase.lib.util/clause?","clause","cljs.core/vector?","cljs.core/count","cljs.core/Keyword","cljs.core/first","cljs.core/map?","cljs.core/second","cljs.core/contains?","metabase.lib.util/clause-of-type?","clause-type","cljs.core._EQ_","metabase.lib.util/field-clause?","metabase.lib.util/expression-name","cljs.core.get_in","metabase.lib.util/named-expression-clause","a-name","cljs.core/assoc-in","cljs.core/random-uuid","metabase.lib.schema.expression/type-of","js/Error","metabase.lib.util/replace-clause","stage","location","target-clause","new-clause","p1__64440#","cljs.core.some_fn","medley.core/update-existing-in","clause-or-clauses","iter__5523__auto__","s__64442","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","b__64444","cljs.core/chunk-buffer","i__64443","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__64441","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","metabase.lib.options/uuid","cljs.core/vec","metabase.lib.util/remove-clause","temp__5802__auto__","target","vec__64446","cljs.core.nth","target-uuid","first-loc","last-loc","cljs.core/last","result","cljs.core.into","cljs.core.remove","cljs.core.comp","p1__64445#","cljs.core/every?","cljs.core.ex_info","metabase.shared.util.i18n/js-i18n","cljs.core.update_in","cljs.core/pop","cljs.core/dissoc","medley.core.dissoc_in","metabase.lib.util/native-query->pipeline","query","cljs.core.merge","clojure.set/rename-keys","cljs.core.dissoc","metabase.lib.util/update-legacy-boolean-expression->list","m","legacy-key","pMBQL-key","G__64467","p1__64466#","cljs.core.update","cljs.core.drop","metabase.lib.util/join->pipeline","join","source","cljs.core/select-keys","stages","metabase.lib.util/inner-query->stages","cljs.core.assoc","metabase.lib.options/ensure-uuid","metabase.lib.util/joins->pipeline","joins","cljs.core.mapv","metabase.lib.util/->stage-metadata","source-metadata","cljs.core/seqable?","columns","column","cljs.core/update-keys","metabase.util/->kebab-case-en","p__64501","map__64502","cljs.core/--destructure-map","cljs.core.get","source-query","inner-query","previous-stages","previous-stage","G__64510","and__5043__auto__","stage-type","this-stage","G__64513","cljs.core.conj","metabase.lib.util/mbql-query->pipeline","metabase.lib.util/LegacyOrPMBQLQuery","metabase.lib.util/pipeline","G__64522","p__64524","map__64525","metabase.lib.util/canonical-stage-index","_query","stage-number","stage-number'","metabase.shared.util.i18n.js_i18n","metabase.lib.util/previous-stage-number","metabase.lib.util/first-stage?","cljs.core/not","p__64527","map__64528","metabase.lib.util/next-stage-number","metabase.lib.util/query-stage","map__64530","metabase.lib.util/previous-stage","stage-num","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","metabase.lib.util/update-query-stage","seq64535","G__64536","cljs.core/next","G__64537","G__64538","self__5754__auto__","f","args","map__64539","stages'","cljs.core.apply","cljs.core/update","metabase.lib.util/ensure-mbql-final-stage","G__64541","cljs.core/conj","metabase.lib.util/join-strings-with-conjunction","conjunction","coll","clojure.string/trim","clojure.string.join","cljs.core/butlast","metabase.lib.util/string-byte-count","s","js/TextEncoder","metabase.lib.util/truncate-string-to-byte-count","max-length-bytes","buf","js/Uint8Array","cljs.core.subs","metabase.lib.util/truncate-alias-max-length-bytes","metabase.lib.util/truncated-alias-hash-suffix-length","metabase.lib.util/crc32-checksum","js/shadow.js.shim.module$crc_32.str","G__64631","metabase.lib.util/truncate-alias","metabase.lib.util.truncate_alias","max-bytes","checksum","truncated","metabase.lib.util/legacy-string-table-id->card-id","table-id","vec__64669","_match","card-id-str","cljs.core/re-find","cljs.core/parse-long","metabase.lib.util/source-table-id","metabase.lib.util/source-card-id","metabase.lib.util/unique-name-generator","metabase.mbql.util.unique_name_generator","metabase.util/lower-case-en","original","suffix","metabase.lib.util/strip-id-regex","js/RegExp","metabase.lib.util/strip-id","display-name","clojure.string/replace","metabase.lib.util/add-summary-clause","a-summary-clause","or__5045__auto__","new-summary?","new-query","metabase.lib.util.update_query_stage","summary-clauses","metabase.lib.common/->op-arg","medley.core.update_existing","p1__64708#","p1__64709#","cljs.core/subvec","metabase.lib.util/with-default-effective-type","options","metabase.lib.options/options","default-effective-type","G__64754","metabase.lib.options.update_options","cljs.core/assoc","cljs.core/chunk-first"]],"~:used-vars",["^J",["~$metabase.lib.util/legacy-string-table-id->card-id","~$cljs.core/--destructure-map","~$clojure.string/join","~$metabase.lib.util/replace-clause","~$metabase.lib.util/pipeline","~$cljs.core/comp","~$cljs.core/rest","~$metabase.lib.util/string-byte-count","~$metabase.lib.util/join-strings-with-conjunction","~$metabase.lib.util/native-query->pipeline","~$metabase.lib.util/source-table-id","~$metabase.lib.util/ensure-mbql-final-stage","~$metabase.lib.util/next-stage-number","~$js/RegExp","~$metabase.lib.options/options","~$metabase.mbql.util/unique-name-generator","~$metabase.lib.util/unique-name-generator","~$cljs.core/vector?","~$cljs.core/=","~$metabase.util/lower-case-en","~$metabase.lib.util/query-stage","~$cljs.core/IndexedSeq","~$metabase.lib.util/remove-clause","~$cljs.core/update-keys","~$cljs.core/count","~$metabase.lib.options/ensure-uuid","~$cljs.core/seq","~$cljs.core/chunk-first","~$metabase.lib.common/->op-arg","~$cljs.core/apply","~$metabase.lib.options/update-options","~$metabase.lib.util/clause-of-type?","~$cljs.core/Keyword","~$medley.core/dissoc-in","~$goog.string/format","~$metabase.lib.util/canonical-stage-index","~$metabase.lib.util/truncate-string-to-byte-count","~$cljs.core/last","~$cljs.core/chunk","~$cljs.core/mapv","~$metabase.lib.util/truncate-alias","~$js/shadow.js.shim.module$crc_32.str","~$cljs.core/dissoc","~$cljs.core/LazySeq","~$cljs.core/chunk-rest","~$metabase.util/->kebab-case-en","~$metabase.lib.util/join->pipeline","~$metabase.lib.util/named-expression-clause","~$cljs.core/pop","~$metabase.lib.schema.expression/type-of","~$js/TextEncoder","~$js/Uint8Array","~$metabase.lib.util/format","~$metabase.lib.util/update-query-stage","~$cljs.core/contains?","~$cljs.core/into","~$cljs.core/map?","~$cljs.core/conj","~$cljs.core/update","~$medley.core/update-existing","~$cljs.core/get-in","~$metabase.lib.util/clause?","~$clojure.set/rename-keys","~$cljs.core/get","~$metabase.lib.util/field-clause?","~$cljs.core/chunk-append","~$metabase.lib.util/truncated-alias-hash-suffix-length","~$cljs.core/-nth","~$cljs.core/remove","~$metabase.lib.util/LegacyOrPMBQLQuery","~$cljs.core/re-find","~$cljs.core/subvec","~$metabase.lib.util/crc32-checksum","~$metabase.shared.util.i18n/js-i18n","~$medley.core/update-existing-in","~$cljs.core/nth","~$cljs.core/ex-info","~$cljs.core/second","~$clojure.string/replace","~$cljs.core/next","~$cljs.core/vec","~$metabase.lib.util/expression-name","~$cljs.core/select-keys","~$cljs.core/chunk-cons","~$metabase.lib.util/inner-query->stages","~$cljs.core/not","~$metabase.lib.util/previous-stage-number","~$cljs.core/cons","~$cljs.core/assoc","~$cljs.core/assoc-in","~$cljs.core/chunk-buffer","~$cljs.core/seqable?","~$cljs.core/parse-long","~$metabase.lib.util/->stage-metadata","~$clojure.string/trim","~$metabase.lib.util/mbql-query->pipeline","~$cljs.core/some-fn","~$metabase.lib.util/strip-id","~$metabase.lib.util/update-legacy-boolean-expression->list","~$cljs.core/first","~$cljs.core/butlast","~$metabase.lib.util/add-summary-clause","~$metabase.lib.util/previous-stage","~$metabase.lib.util/with-default-effective-type","~$metabase.lib.util/joins->pipeline","~$cljs.core/subs","~$cljs.core/merge","~$cljs.core/every?","~$metabase.lib.util/strip-id-regex","~$cljs.core/update-in","~$js/Error","~$cljs.core/random-uuid","~$metabase.lib.util/source-card-id","~$cljs.core/drop","~$metabase.lib.util/first-stage?","~$metabase.lib.options/uuid","~$cljs.core/chunked-seq?","~$metabase.lib.util/truncate-alias-max-length-bytes"]]],"~:cache-keys",["~#cmap",[["^1V","camel_snake_kebab/internals/misc.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^1<","^C","~$camel-snake-kebab.internals.string-separator","^1E"]]],["^1V","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.dom.HtmlElement"]]],["^1V","metabase/shared/util/i18n.cljs"],["6c3c8615004b349dae9851ed547d516d45e04bd0","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$shadow.js.shim.module$ttag","^1E"]]],["^1V","goog/labs/useragent/platform.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.string.internal","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^1V","metabase/types.cljc"],["00232bf78b259e26a21c218c8f2d746ba7003a15","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Z","~$metabase.types.coercion-hierarchies","^15"]]],["^1V","cljs/spec/gen/alpha.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$goog.Uri"]]],["^1V","metabase/lib/util.cljc"],["11c3262368d876979e323f3e646aab21fbf9b86e","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Q","^10","^1B","^Z","^1E","^1A","^1;","^1?","^V","^14","^17","^1@","^18","^12","^15","^X"]]],["^1V","lambdaisland/glogi.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$goog.log","~$goog.debug.Console","~$goog.array","^1E","~$goog.object","~$goog.debug.FancyWindow","~$goog.debug.DivConsole"]]],["^1V","goog/math/math.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.asserts"]]],["^1V","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/string/stringformat.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^10"]]],["^1V","malli/registry.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^54","^55","^5@","^53","^56","^57"]]],["^1V","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^53"]]],["^1V","goog/style/style.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","~$goog.dom","~$goog.dom.NodeType","~$goog.dom.TagName","~$goog.dom.safe","~$goog.dom.vendor","~$goog.html.SafeStyleSheet","~$goog.math.Box","~$goog.math.Coordinate","~$goog.math.Rect","~$goog.math.Size","^5=","~$goog.reflect","^10","~$goog.userAgent"]]],["^1V","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@"]]],["~:shadow.build.js-support/require","moment"],["~$shadow.js.shim.module$moment","shadow.js.shim.module$moment.js","require","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^5Q","moment-timezone"],["~$shadow.js.shim.module$moment_timezone","shadow.js.shim.module$moment_timezone.js","require","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","metabase/mbql/schema/macros.cljs"],["2af09bd42ffb1e15b66723cf7ba15db7dc75d10b","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","metabase/lib/schema/mbql_clause.cljc"],["e5bdd00c58db706b1219843528fd3cd9dd8ab728","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^14","^17","~$metabase.types","^X","~$metabase.util.malli.registry"]]],["^1V","goog/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.labs.userAgent.browser","~$goog.labs.userAgent.engine","~$goog.labs.userAgent.platform","^54","^5O","^53"]]],["^1V","malli/generator.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^E","^1E","~$clojure.test.check","~$clojure.test.check.generators","~$clojure.test.check.properties","~$clojure.test.check.random","~$clojure.test.check.rose-tree","~$malli.core","~$malli.registry"]]],["^1V","clojure/test/check/properties.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^5Z","~$clojure.test.check.results"]]],["^1V","clojure/test/check/generators.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","^60","^61","^10"]]],["^1V","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","metabase/lib/common.cljc"],["a3bc6343077ef13a3da77612b68f23f9b2a3d890","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$metabase.lib.dispatch","~$metabase.lib.hierarchy","^1?","~$metabase.lib.ref","^14","^X"]]],["^1V","metabase/lib/schema/util.cljc"],["14a9e8a90c56f5e44b4ecd361e962722fd97aecf","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1?"]]],["^1V","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","malli/util.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^C","^62"]]],["^1V","clojure/test/check/random/doubles.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$clojure.test.check.random.longs"]]],["^1V","net/cgrand/macrovich.cljc"],["abcb26cbfe0f8eef363b25525210c0fe1eb1f693","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","malli/destructure.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$clojure.walk","^62","~$malli.impl.util"]]],["^1V","schema/spec/variant.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$schema.utils","~$schema.spec.core"]]],["^1V","goog/structs/circularbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","weavejester/dependency.cljc"],["7fd7f8879313f6a7e295f7447e668bdf492c42c1","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Z"]]],["^1V","metabase/lib/schema/common.cljc"],["3f51a06335a7cb84c835d859c422919499874414","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","^5T","^5U"]]],["^1V","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^54","^53"]]],["^1V","cljs/pprint.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","^10","~$goog.string.StringBuffer"]]],["^1V","metabase/lib/schema/template_tag.cljc"],["f1b6289b8e576857fe667aed3da134e4ad1ea26a","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^62","^14","^1@","~$metabase.mbql.schema","^5U"]]],["^1V","metabase/lib/schema/ref.cljc"],["5037a60b3d2f427702cf5cedf23f02bcc394d051","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","^65","^66","^14","^17","^1@","~$metabase.lib.schema.mbql-clause","~$metabase.lib.schema.temporal-bucketing","^5T","^5U"]]],["^1V","clojure/test/check/rose_tree.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","clojure/test/check/impl.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","camel_snake_kebab/internals/string_separator.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E"]]],["^1V","clojure/test/check/random.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$clojure.test.check.random.doubles","^68"]]],["^1V","metabase/lib/schema/expression/arithmetic.cljc"],["e6936a3e0b11bc3cd40d4e396c708af4622c21cb","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^62","^1A","^66","^14","^17","^6?","^6@","^5T","^5U"]]],["^1V","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","metabase/lib/schema/expression/string.cljc"],["b2d7de575aaaa880fdc88dfc31642c8e002c3669","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^17","^6?"]]],["^1V","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","metabase/lib/schema/filter.cljc"],["0147dea423ebfd097bf1edb97f0325c9e2908a85","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^14","^17","^6?","^6@","^5U"]]],["^1V","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@"]]],"~:SHADOW-TIMESTAMP",[1689947046000,1689947046000,1689947050000],["^1V","metabase/lib/ref.cljc"],["86a9fbeddec3e58f7bb54e61f5342658b370fb3b","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^65","~$metabase.lib.schema.ref","^X"]]],["^1V","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","^5O"]]],["^1V","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","~$goog.fs.blob","^5A","~$goog.html.SafeScript","~$goog.html.trustedtypes","^5C","^5D"]]],["^1V","schema/spec/leaf.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^6<"]]],["^1V","metabase/util/format.cljc"],["875f86a08288cb3ad5a6f15df988897eaf8613af","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^10"]]],["^1V","goog/math/irect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/math/box.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","^5L"]]],["^1V","metabase/lib/options.cljc"],["1870276153adf026e09a3e9ed1ba8beaad80e1c8","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^14","^12","^15","^X"]]],["^1V","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","clojure/test/check.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^5Z","^60","^64","^61","~$clojure.test.check.impl"]]],["^1V","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5C","~$goog.html.SafeUrl","^5D","^5@","^53"]]],["^1V","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^6E","~$goog.html.SafeStyle","^6H","^5B","~$goog.html.uncheckedconversions","^5C","^53"]]],["^1V","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5G","^5@","~$goog.dom.element"]]],["^1V","medley/core.cljc"],["f5117fa4c15ff14c4a0ab7db414b0f102afb0b8a","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","metabase/lib/schema/expression/conditional.cljc"],["226c4623394b90853fcb014e9a95e84ffc8bd6db","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Z","^17","^6?","^5T","^5U"]]],["^1V","lambdaisland/glogi/console.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$lambdaisland.glogi","~$lambdaisland.glogi.print","^5=","^5;"]]],["^1V","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5C","^6E","^6M","^5J","^6H","^5G","^5B","^5D","^5@","^5V","^5<","^5=","^53","~$goog.dom.tags","^6F"]]],["^1V","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5="]]],["^1V","goog/math/size.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","malli/error.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","^62","~$malli.util"]]],["^1V","metabase/lib/dispatch.cljc"],["914208cd51b78412eff1b402519bbb422845497a","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^15"]]],["^1V","metabase/util/malli.cljc"],["0f9ba23be6bb9fa629617001e985b988d2322b17","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^C","^62","~$malli.destructure","~$malli.error","~$malli.generator","^6S","^12","^15"]]],["^1V","goog/labs/useragent/engine.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5<","^53","^54"]]],["^1V","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","metabase/mbql/schema/helpers.cljc"],["b1f6002b97b59423b504abb666e13c9b0228b768","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","^5T","~$schema.core"]]],["^1V","goog/dom/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5<","^5@","^6I","~$goog.dom.BrowserFeature","^5F","^5G","^5H","^6L","^6N","^5L","^5N","^5=","^10","^5C","~$goog.string.Unicode","^5P"]]],["^1V","borkdude/dynaload.cljc"],["accd696ba364b850b4d92e38f5a34d0e828a0ad1","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","metabase/util/log.cljs"],["7d8a3bf01eb27c2ba7269dc90dc218e46bcc1d3a","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^5:","^10","^1B","^6P","~$lambdaisland.glogi.console"]]],["^1V","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.debug.Error","^5F"]]],["^1V","goog/debug/relativetimeprovider.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","malli/sci.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$borkdude.dynaload"]]],["^1V","metabase/lib/schema/expression.cljc"],["f5c5c3ff3dc0f9a8b407cd7d06a68c6787061991","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^65","^66","^14","^12","^5T","^X","^5U"]]],["^1V","goog/math/rect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","^5K","^5L","~$goog.math.IRect","^5N"]]],["^1V","flatland/ordered/map.cljs"],["3a9cb9d79e47d77ecd4f4d550371ecf01464c461","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5<","^5@","~$goog.collections.maps","^10","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1V","metabase/util/malli/registry.cljc"],["921d4f259bbe54cbeb6b88ae56937df492bdfb5e","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^62","^63","^6S"]]],["^1V","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^55"]]],["^1V","metabase/types/coercion_hierarchies.cljc"],["c3d70ef6080e044d61f13ff6bfd76490e2dcd0ac","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Z"]]],["^1V","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/debug/divconsole.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.debug.HtmlFormatter","~$goog.dom.DomHelper","^5G","^5H","^6L","^5J","^5:","^5C","~$goog.style"]]],["^1V","schema/spec/collection.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^6;","^6<"]]],["^1V","malli/impl/util.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","metabase/lib/schema/order_by.cljc"],["3f577f71e4ecba1aa1061f2228f6026ab45312ff","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^17","^6?","^5U"]]],["^1V","schema/utils.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1B","^5=","^10","^1E"]]],["^1V","metabase/lib/schema/aggregation.cljc"],["ea4a70903cfc3ffeaa60ebdedb5ea00892da4dbe","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^66","^17","^6?","^12","^5U"]]],["^1V","cljs/core/match.cljs"],["f419c02deee501e9f4b29f81215ba81ffcefe9b6","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","goog/debug/fancywindow.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5<","^5@","~$goog.debug.DebugWindow","^78","^5G","^5H","^6L","^5J","^5:","^5=","^10","^5C","^5P"]]],["^1V","goog/debug/formatter.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.debug","~$goog.debug.RelativeTimeProvider","^6L","^6H","^6N","^5:","^5C"]]],["^1V","metabase/shared/util/namespaces.cljs"],["00687008abd6eb291bc9d5ff1fff73210e0bbe6e","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","metabase/mbql/util/match/impl.cljc"],["4150e01975339d308f5cfedda77875eda19c030d","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",[]]],["^1V","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5<","^5="]]],["^1V","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^10","^6="]]],["^1V","metabase/lib/schema/temporal_bucketing.cljc"],["9cb7bba3e46e1de2fbb37d61df332336da6d9f66","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Z","^5U"]]],["^1V","metabase/util.cljc"],["2eb945a6741f1450ecac08a9087b862ce52b9e3a","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$camel-snake-kebab.internals.macros","~$clojure.data","^?","^Z","^1E","^69","~$flatland.ordered.map","^1A","^12","~$metabase.shared.util.namespaces","~$metabase.util.format","~$metabase.util.log","~$net.cgrand.macrovich","~$weavejester.dependency"]]],["^1V","clojure/test/check/random/longs/bit_count_impl.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","malli/impl/regex.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^6:"]]],["^1V","camel_snake_kebab/internals/macros.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$camel-snake-kebab.internals.alter-name","~$camel-snake-kebab.internals.misc"]]],["^1V","metabase/lib/schema/expression/temporal.cljc"],["f1f22c1655e7d335b884a22b010f2b8b08ad1e94","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Z","^62","^66","^14","^17","~$metabase.lib.schema.literal","^6?","^6@","^5U","^5R","^5S"]]],["^1V","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5H","^6N","^5C","^53"]]],["^1V","schema/core.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","^6;","^6<","~$schema.spec.leaf","~$schema.spec.variant","~$schema.spec.collection"]]],["^1V","metabase/mbql/schema.cljc"],["c51bf2a180ecbc12d6a1cd42a4049323f46a0085","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^5R","^5S","^C","^Z","~$metabase.mbql.schema.helpers","~$metabase.mbql.schema.macros","^6W"]]],["^1V","metabase/mbql/util/match.cljs"],["d65aaa9fbcb7960b90ba7ca97258b1dc8a40be2b","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^G","~$metabase.mbql.util.match.impl"]]],["^1V","malli/core.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^C","~$malli.impl.regex","^6:","^63","~$malli.sci"]]],["^1V","metabase/lib/schema.cljc"],["122fe4013d55087fc7287141eb7dc6f630436424","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$metabase.lib.schema.aggregation","^14","^17","~$metabase.lib.schema.expression.arithmetic","~$metabase.lib.schema.expression.conditional","~$metabase.lib.schema.expression.string","~$metabase.lib.schema.expression.temporal","~$metabase.lib.schema.filter","^1@","~$metabase.lib.schema.join","^7G","~$metabase.lib.schema.order-by","^6C","~$metabase.lib.schema.template-tag","~$metabase.lib.schema.util","~$metabase.mbql.util.match","^5U"]]],["^1V","clojure/data.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^Z"]]],["^1V","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^53","^57"]]],["^1V","goog/debug/debug.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5<","~$goog.debug.errorcontext"]]],["^1V","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","schema/spec/core.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^6;"]]],["^5Q","ttag"],["^52","shadow.js.shim.module$ttag.js","require","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/math/coordinate.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.math"]]],["^1V","goog/debug/errorcontext.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.flags"]]],["^1V","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5F","^5G"]]],["^1V","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","^6L","^6E","^6M","^5J","^6H","^5B","^5C","^53"]]],["^1V","goog/debug/debugwindow.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^77","^5H","^6L","^5J","^5:","^5C","~$goog.structs.CircularBuffer","^5P"]]],["^1V","metabase/mbql/util.cljc"],["2532d5faa94d2a89dd06e529c641d594e298e2aa","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^1E","~$metabase.mbql.predicates","^6>","^7K","^7Z","^12","^6W"]]],["^1V","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.math.Long","~$goog.math.Integer","^10","^5=","^5<","^59","^6="]]],["^1V","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5C","^5D","^6F","^5@"]]],["^1V","clojure/test/check/random/longs.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","~$clojure.test.check.random.longs.bit-count-impl","^84","^C"]]],["^1V","goog/log/log.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","^7;"]]],["^1V","camel_snake_kebab/internals/alter_name.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5C","^6M","^5D","^5=","^5@","^53"]]],["^1V","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5O"]]],["^1V","goog/debug/console.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","~$goog.debug.TextFormatter","^5:"]]],["^1V","lambdaisland/glogi/print.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^6P","^5="]]],["^1V","goog/dom/browserfeature.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5P"]]],["^1V","clojure/set.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","^10"]]],["^1V","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^5@","^5D"]]],["^1V","metabase/lib/schema/id.cljc"],["7cdfc70702a9a9e04b75ca7c9dc898ddf546f99d","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^14","^6>","^5U"]]],["^1V","goog/dom/vendor.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^10","^5P"]]],["^1V","metabase/lib/schema/literal.cljc"],["f8f31bfaef820ab25b896b49fd404b937d0df64e","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^62","^14","^17","^6?","^5U"]]],["^1V","metabase/lib/hierarchy.cljc"],["c9d228603522de5c85546fb645c59736d4eb94d2","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^1V","metabase/mbql/predicates.cljc"],["20ab1a5ccd943c35c646c5f7396ea40f9bfa7ac4","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^6>","^6W"]]],["^1V","clojure/test/check/results.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C"]]],["^5Q","crc-32"],["^Q","shadow.js.shim.module$crc_32.js","require","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<"]]],["^1V","metabase/lib/schema/join.cljc"],["924e0ca4abbab776fa05357d6d22bafb8a596648","^4X",["^ ","^4Y",null,"^4Z",["^J",[]],"^4[",["^1<","^C","^14","^17","^12","^5U"]]]]],"~:clj-info",["^ ","jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/line_col.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/viz.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/parse.cljc",1689946139000,"jar:file:/root/.m2/repository/weavejester/dependency/0.2.1/dependency-0.2.1.jar!/weavejester/dependency.cljc",1689946093000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/transform.clj",1689946146000,"jar:file:/root/.m2/repository/ring/ring-codec/1.2.0/ring-codec-1.2.0.jar!/ring/util/codec.clj",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/hierarchy.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/pprint.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema/helpers.cljc",1692013156305,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/core.cljc",1689946172000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/shared/util/i18n.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1689947050000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/macros.clj",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n/plural.clj",1690286813000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/core.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/util.cljc",1690286813000,"jar:file:/root/.m2/repository/nano-id/nano-id/1.0.0/nano-id-1.0.0.jar!/nano_id/core.cljc",1689946171000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/dispatch.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/common.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/plugins/classloader.clj",1692013156125,"jar:file:/root/.m2/repository/medley/medley/1.4.0/medley-1.4.0.jar!/medley/core.cljc",1689946185000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/random.clj",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/util/format.cljc",1690286813000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1689947050000,"jar:file:/root/.m2/repository/riddley/riddley/0.2.0/riddley-0.2.0.jar!/riddley/walk.clj",1689946160000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/ref.cljc",1690286812000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/reduction.clj",1689946146000,"jar:file:/root/.m2/repository/org/tcrawley/dynapath/1.1.0/dynapath-1.1.0.jar!/dynapath/util.clj",1689946174000,"jar:file:/root/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.3/camel-snake-kebab-0.4.3.jar!/camel_snake_kebab/internals/macros.cljc",1689946178000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match/impl.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/auto_flatten_seq.clj",1689946146000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/core.clj",1689946146000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/generator.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/id.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/core.cache/1.0.225/core.cache-1.0.225.jar!/clojure/core/cache.clj",1689946183000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/expression.cljc",1690286812000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/sci.cljc",1689946170000,"jar:file:/root/.m2/repository/potemkin/potemkin/0.4.6/potemkin-0.4.6.jar!/potemkin/types.clj",1689946176000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/properties.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/math.numeric-tower/0.0.5/math.numeric-tower-0.0.5.jar!/clojure/math/numeric_tower.clj",1689946148000,"jar:file:/root/.m2/repository/net/cgrand/macrovich/0.2.1/macrovich-0.2.1.jar!/net/cgrand/macrovich.cljc",1689946165000,"jar:file:/root/.m2/repository/colorize/colorize/0.1.1/colorize-0.1.1.jar!/colorize/core.clj",1689946104000,"jar:file:/root/.m2/repository/borkdude/dynaload/0.3.5/dynaload-0.3.5.jar!/borkdude/dynaload.cljc",1689946165000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/options.cljc",1692013156125,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1689946092000,"jar:file:/root/.m2/repository/potemkin/potemkin/0.4.6/potemkin-0.4.6.jar!/potemkin.clj",1689946176000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/failure.clj",1689946146000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/variant.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1689946092000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n/impl.clj",1692013156125,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/dependency.cljc",1689946139000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/leaf.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check.cljc",1689946177000,"jar:file:/root/.m2/repository/riddley/riddley/0.2.0/riddley-0.2.0.jar!/riddley/compiler.clj",1689946160000,"jar:file:/root/.m2/repository/org/clojure/core.memoize/1.0.257/core.memoize-1.0.257.jar!/clojure/core/memoize.clj",1689946178000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/destructure.cljc",1689946170000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/print.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/track.cljc",1689946139000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/java.classpath/1.0.0/java.classpath-1.0.0.jar!/clojure/java/classpath.clj",1689946162000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1689947050000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/impl/regex.cljc",1689946170000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/factory.clj",1689946173000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1689946174000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/experimental.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/walk.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1689946174000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/common.cljc",1690286812000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/core.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/generators.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1689947050000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/generate.clj",1689946173000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/experimental/time.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1689946174000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema.cljc",1692013156305,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/parse.clj",1689946173000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n.clj",1692013156125,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/cfg.clj",1689946146000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/core.clj",1689946173000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/impl/util.cljc",1689946170000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/registry.cljc",1689946170000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/gll.clj",1689946146000,"jar:file:/root/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1689947054000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/instrument.clj",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/spec/gen/alpha.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/ref.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1689946092000,"jar:file:/root/.m2/repository/nano-id/nano-id/1.0.0/nano-id-1.0.0.jar!/nano_id/random.cljc",1689946171000,"jar:file:/root/.m2/repository/environ/environ/1.2.0/environ-1.2.0.jar!/environ/core.cljc",1689946163000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/collection.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/repeat.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/results.cljc",1689946177000,"jar:file:/root/.m2/repository/com/lambdaisland/glogi/1.2.164/glogi-1.2.164.jar!/lambdaisland/glogi.clj",1689947043000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1689946092000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/shared/util/namespaces.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/file.clj",1689946139000,"jar:file:/root/.m2/repository/org/clojure/core.match/1.0.1/core.match-1.0.1.jar!/cljs/core/match.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/spec.alpha/0.3.218/spec.alpha-0.3.218.jar!/clojure/spec/gen/alpha.clj",1689946117000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/error.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema/macros.clj",1690286812000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/utils.cljc",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/util/malli/registry.cljc",1690286813000,"file:/home/gmrworkspace/dashboard/src/metabase/config.clj",1692013154929,"file:/home/gmrworkspace/dashboard/src/metabase/util/log.clj",1690286813000,"file:/home/gmrworkspace/dashboard/src/metabase/util/malli.cljc",1690286813000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/rose_tree.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1689946174000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/combinators_source.clj",1689946146000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/abnf.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/find.clj",1689946139000,"jar:file:/root/.m2/repository/org/tcrawley/dynapath/1.1.0/dynapath-1.1.0.jar!/dynapath/dynamic_classpath.clj",1689946174000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/temporal_bucketing.cljc",1690286812000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/generate_seq.clj",1689946173000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/mbql_clause.cljc",1690286812000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/util.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/src/metabase/util/jvm.clj",1692013156125],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","metabase/lib/util.cljc","^7",1,"^8",5,"^9",1,"^:",22],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",["^K"]],"~:shadow/js-access-properties",["^J",["str"]],"^L","^M","^N",["^ "],"^O",["^ ","^P","^Q"],"^T",null,"^U",["^ ","^V","^V","^W","^X","^Y","^Z","^[","^10","^11","^12","^13","^14","~$u","^15","^16","^17","^18","^18","^10","^10","^19","^18","^1:","^1;","^C","^C","^1<","^1<","^1=","^V","^14","^14","^1>","^1?","^17","^17","^1@","^1@","^Z","^Z","~$m","^1A","^15","^15","^1;","^1;","^12","^12","^Q","^Q","^1B","^1B","^X","^X","^1C","^1B","^1D","^1E","^1F","^1@","^1?","^1?","^1E","^1E","^1A","^1A","^1G","^Q"],"^1H",["^J",["^1I"]],"~:shadow/js-access-global",["^J",["Uint8Array","RegExp","TextEncoder","Error"]],"^1J",null,"~:defs",["^ ","~$query-stage",["^ ","~:schema",["~:=>",["~:cat","~$LegacyOrPMBQLQuery","~:int"],"~:metabase.lib.schema/stage"],"~:validate!","id64529","~:protocol-inline",null,"^5",["^ ","^;E",["^;F",["^;G","^;H","^;I"],"^;J"],"^;K","id64529","^6","metabase/lib/util.cljc","^:",21,"^8",10,"~:raw-arglists",["^1M",["~$quote",["^1M",[["~$query","~:-","^;H","~$stage-number","~:-","^;I"]]]]],"^7",270,"^9",270,"~:arglists",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"~:doc","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int]\n  Return: :metabase.lib.schema/stage\n          \n\n  Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query."],"^L","^2L","^6","metabase/lib/util.cljc","^:",21,"~:method-params",["^1M",[["^;O","^;P"]]],"~:protocol-impl",null,"~:arglists-meta",["^1M",[null,null]],"^8",1,"~:variadic?",false,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^;H","^;P","~:-","^;I"]]]]],"^7",270,"~:ret-tag",["^J",["~$any","~$clj-nil"]],"^9",270,"~:max-fixed-arity",2,"~:fn-var",true,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"^;R","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int]\n  Return: :metabase.lib.schema/stage\n          \n\n  Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query."],"~$string-byte-count",["^ ","^;E",["^;F",["^;G","~:string"],["^;I",["^ ","~:min",0]]],"^;K","id64569","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<1"],["^;I",["^ ","^<2",0]]],"^;K","id64569","~:private",true,"^6","metabase/lib/util.cljc","^:",37,"^8",20,"^;M",["^1M",["^;N",["^1M",[["~$s","~:-","^<1"]]]]],"^7",327,"^9",327,"^;Q",["^1M",["^;N",["^1M",[["~$s"]]]]],"^;R","Inputs: [s :- :string]\n  Return: [:int {:min 0}]\n          \n\n  Number of bytes in a string using UTF-8 encoding."],"^<3",true,"^L","^2?","^6","metabase/lib/util.cljc","^:",37,"^;S",["^1M",[["~$s"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["~$s","~:-","^<1"]]]]],"^7",327,"^;W","~$js","^9",327,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["~$s"]]]]],"^;R","Inputs: [s :- :string]\n  Return: [:int {:min 0}]\n          \n\n  Number of bytes in a string using UTF-8 encoding."],"~$source-table-id",["^ ","^;E",["^;F",["^;G","~:any"],["~:maybe","~:metabase.lib.schema.id/table"]],"^;K","id64673","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<6"],["^<7","^<8"]],"^;K","id64673","^6","metabase/lib/util.cljc","^:",25,"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O"]]]]],"^7",413,"^9",413,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/table]\n          \n\n  If this query has a `:source-table` ID, return it."],"^L","^2B","^6","metabase/lib/util.cljc","^:",25,"^;S",["^1M",[["^;O"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^;O"]]]]],"^7",413,"^;W","^;X","^9",413,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/table]\n          \n\n  If this query has a `:source-table` ID, return it."],"~$clause-of-type?",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",47,"^8",7,"^9",47,"^:",22,"^;Q",["^1M",["^;N",["^1M",[["~$clause","~$clause-type"]]]]],"^;R","Returns true if this is a clause."],"^L","^2W","^6","metabase/lib/util.cljc","^:",22,"^;S",["^1M",[["^<:","^<;"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",47,"^;W","~$boolean","^9",47,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<:","^<;"]]]]],"^;R","Returns true if this is a clause."],"~$remove-clause",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",94,"^8",7,"^9",94,"^:",20,"^;Q",["^1M",["^;N",["^1M",[["~$stage","~$location","~$target-clause"]]]]],"^;R","Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage."],"^L","^2N","^6","metabase/lib/util.cljc","^:",20,"^;S",["^1M",[["^<>","^<?","^<@"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",94,"^;W",["^J",[null,"~$clj","^;X","^;Y"]],"^9",94,"^;Z",3,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<>","^<?","^<@"]]]]],"^;R","Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage."],"~$legacy-string-table-id->card-id",["^ ","^;E",["^;F",["^;G","^<6"],["^<7","~:metabase.lib.schema.id/card"]],"^;K","id64667","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<6"],["^<7","^<C"]],"^;K","id64667","^6","metabase/lib/util.cljc","^:",41,"^8",10,"^;M",["^1M",["^;N",["^1M",[["~$table-id"]]]]],"^7",404,"^9",404,"^;Q",["^1M",["^;N",["^1M",[["^<D"]]]]],"^;R","Inputs: [table-id]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`."],"^L","^28","^6","metabase/lib/util.cljc","^:",41,"^;S",["^1M",[["^<D"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^<D"]]]]],"^7",404,"^;W",["^J",["~$number","^;Y"]],"^9",404,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<D"]]]]],"^;R","Inputs: [table-id]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`."],"~$replace-clause",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",75,"^8",7,"^9",75,"^:",21,"^;Q",["^1M",["^;N",["^1M",[["^<>","^<?","^<@","~$new-clause"]]]]],"^;R","Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens."],"^L","^2;","^6","metabase/lib/util.cljc","^:",21,"^;S",["^1M",[["^<>","^<?","^<@","^<G"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",75,"^;W",["^J",[null,"^<A","^;X"]],"^9",75,"^;Z",4,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<>","^<?","^<@","^<G"]]]]],"^;R","Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens."],"~$previous-stage-number",["^ ","^;E",["^;F",["^;G","~:map","^;I"],["^<7",["^;I",["^ ","^<2",0]]]],"^;K","id64526","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<I","^;I"],["^<7",["^;I",["^ ","^<2",0]]]],"^;K","id64526","^6","metabase/lib/util.cljc","^:",31,"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^<I","^;P","~:-","^;I"]]]]],"^7",248,"^9",248,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"^;R","Inputs: [query :- :map stage-number :- :int]\n  Return: [:maybe [:int {:min 0}]]\n          \n\n  The index of the previous stage, if there is one. `nil` if there is no previous stage."],"^L","^46","^6","metabase/lib/util.cljc","^:",31,"^;S",["^1M",[["^;O","^;P"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^<I","^;P","~:-","^;I"]]]]],"^7",248,"^;W",["^J",["^<E","^;Y"]],"^9",248,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"^;R","Inputs: [query :- :map stage-number :- :int]\n  Return: [:maybe [:int {:min 0}]]\n          \n\n  The index of the previous stage, if there is one. `nil` if there is no previous stage."],"~$ensure-mbql-final-stage",["^ ","^;E",["^;F",["^;G","^<6"],"~:metabase.lib.schema/query"],"^;K","id64540","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<6"],"^<K"],"^;K","id64540","^6","metabase/lib/util.cljc","^:",33,"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O"]]]]],"^7",298,"^9",298,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query]\n  Return: :metabase.lib.schema/query\n          \n\n  Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one."],"^L","^2C","^6","metabase/lib/util.cljc","^:",33,"^;S",["^1M",[["^;O"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^;O"]]]]],"^7",298,"^;W",["^J",["^<A","^;X"]],"^9",298,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query]\n  Return: :metabase.lib.schema/query\n          \n\n  Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one."],"~$next-stage-number",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",261,"^8",7,"^9",261,"^:",24,"^;Q",["^1M",["^;N",["^1M",[[["^ ","~:keys",["~$stages"],"^1Q","~$_query"],"^;P"]]]]],"^;R","The index of the next stage, if there is one. `nil` if there is no next stage."],"^L","^2D","^6","metabase/lib/util.cljc","^:",24,"^;S",["^1M",[["~$p__64527","^;P"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",261,"^;W",["^J",["^<E","^;Y"]],"^9",261,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[[["^ ","^<M",["^<N"],"^1Q","^<O"],"^;P"]]]]],"^;R","The index of the next stage, if there is one. `nil` if there is no next stage."],"~$native-query->pipeline",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",127,"^8",8,"^9",127,"^:",30,"^<3",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means."],"^<3",true,"^L","^2A","^6","metabase/lib/util.cljc","^:",30,"^;S",["^1M",[["^;O"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",127,"^;W",["^J",["^;X","^;Y"]],"^9",127,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means."],"~$named-expression-clause",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",64,"^8",7,"^9",64,"^:",30,"^;Q",["^1M",["^;N",["^1M",[["^<:","~$a-name"]]]]],"^;R","Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value."],"^L","^3;","^6","metabase/lib/util.cljc","^:",30,"^;S",["^1M",[["^<:","^<S"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",64,"^;W",["^J",["^<A","^;X"]],"^9",64,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<:","^<S"]]]]],"^;R","Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value."],"^K",["^ ","^L","^3@","^6","metabase/lib/util.cljc","^7",36,"^8",4,"^9",36,"^:",15,"^5",["^ ","^6","metabase/lib/util.cljc","^7",36,"^8",9,"^9",36,"^:",15],"^;R","Exactly like [[clojure.core/format]] but ClojureScript-friendly."],"~$truncate-string-to-byte-count",["^ ","^;E",["^;F",["^;G","^<1",["^;I",["^ ","^<2",1]]],"^<1"],"^;K","id64585","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<1",["^;I",["^ ","^<2",1]]],"^<1"],"^;K","id64585","^<3",true,"^6","metabase/lib/util.cljc","^:",49,"^8",20,"^;M",["^1M",["^;N",["^1M",[["~$s","~:-","^<1","~$max-length-bytes","~:-",["^;I",["^ ","^<2",1]]]]]]],"^7",339,"^9",339,"^;Q",["^1M",["^;N",["^1M",[["~$s","^<U"]]]]],"^;R","Inputs: [s :- :string max-length-bytes :- [:int {:min 1}]]\n  Return: :string\n          \n\n  Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n  *characters*)."],"^<3",true,"^L","^30","^6","metabase/lib/util.cljc","^:",49,"^;S",["^1M",[["~$s","^<U"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["~$s","~:-","^<1","^<U","~:-",["^;I",["^ ","^<2",1]]]]]]],"^7",339,"^;W","~$string","^9",339,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["~$s","^<U"]]]]],"^;R","Inputs: [s :- :string max-length-bytes :- [:int {:min 1}]]\n  Return: :string\n          \n\n  Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n  *characters*)."],"~$join-strings-with-conjunction",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",306,"^8",7,"^9",306,"^:",36,"^;Q",["^1M",["^;N",["^1M",[["~$conjunction","~$coll"]]]]],"^;R","This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \"and\" [\"X\" \"Y\" \"Z\"])\n  ;; => \"X, Y, and Z\""],"^L","^2@","^6","metabase/lib/util.cljc","^:",36,"^;S",["^1M",[["^<X","^<Y"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",306,"^;W",["^J",["^;X","^<V","^;Y"]],"^9",306,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<X","^<Y"]]]]],"^;R","This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \"and\" [\"X\" \"Y\" \"Z\"])\n  ;; => \"X, Y, and Z\""],"~$join->pipeline",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",150,"^8",8,"^9",150,"^:",22,"^<3",true,"^;Q",["^1M",["^;N",["^1M",[["~$join"]]]]]],"^<3",true,"^L","^3:","^6","metabase/lib/util.cljc","^:",22,"^;S",["^1M",[["^<["]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",150,"^;W",["^J",[null,"^<A","^;X","^;Y"]],"^9",150,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<["]]]]]],"~$pipeline",["^ ","^;E",["^;F",["^;G","^;H"],"^<6"],"^;K","id64521","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^;H"],"^<6"],"^;K","id64521","^6","metabase/lib/util.cljc","^:",18,"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^;H"]]]]],"^7",222,"^9",222,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query :- LegacyOrPMBQLQuery]\n  Return: :any\n          \n\n  Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)"],"^L","^2<","^6","metabase/lib/util.cljc","^:",18,"^;S",["^1M",[["^;O"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^;H"]]]]],"^7",222,"^9",222,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query :- LegacyOrPMBQLQuery]\n  Return: :any\n          \n\n  Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)"],"~$update-query-stage",["^ ","^;E",["^;F",["^;G","^;H","^;I","^<6",["~:*","^<6"]],"^<K"],"^;K","id64534","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^;H","^;I","^<6",["~:*","^<6"]],"^<K"],"^;K","id64534","^6","metabase/lib/util.cljc","^:",28,"~:top-fn",["^ ","^;V",true,"~:fixed-arity",3,"^;Z",3,"^;S",[["^1M",["^;O","^;P","~$f","~$args"]]],"^;Q",["^1M",[["^;O","^;P","~$f","~$&","^=4"]]],"^;U",["^1M",[null]]],"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^;H","^;P","~:-","^;I","~$f","~$&","^=4"]]]]],"^7",284,"^9",284,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P","~$f","~$&","^=4"]]]]],"^;R","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int f & args]\n  Return: :metabase.lib.schema/query\n          \n\n  Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query."],"^L","^3A","^6","metabase/lib/util.cljc","^:",28,"^=2",["^ ","^;V",true,"^=3",3,"^;Z",3,"^;S",[["^1M",["^;O","^;P","~$f","^=4"]]],"^;Q",["^1M",[["^;O","^;P","~$f","~$&","^=4"]]],"^;U",["^1M",[null]]],"^;S",[["^1M",["^;O","^;P","~$f","^=4"]]],"^;T",null,"^=3",3,"^;U",["^1M",[null]],"^8",1,"^;V",true,"~:methods",[["^ ","^=3",3,"^;V",true,"~:tag",["^J",["^<A","^;X"]]]],"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^;H","^;P","~:-","^;I","~$f","~$&","^=4"]]]]],"^7",284,"^;W","^;X","^9",284,"^;Z",3,"^;[",true,"^;Q",["^1M",[["^;O","^;P","~$f","~$&","^=4"]]],"^;R","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int f & args]\n  Return: :metabase.lib.schema/query\n          \n\n  Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query."],"~$crc32-checksum",["^ ","^;E",["^;F",["^;G","^<1"],["^<1",["^ ","^<2",8,"~:max",8]]],"^;K","id64600","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<1"],["^<1",["^ ","^<2",8,"^=8",8]]],"^;K","id64600","^<3",true,"^6","metabase/lib/util.cljc","^:",34,"^8",20,"^;M",["^1M",["^;N",["^1M",[["~$s","~:-","^<1"]]]]],"^7",370,"^9",370,"^;Q",["^1M",["^;N",["^1M",[["~$s"]]]]],"^;R","Inputs: [s :- :string]\n  Return: [:string {:min 8, :max 8}]\n          \n\n  Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string."],"^<3",true,"^L","^3T","^6","metabase/lib/util.cljc","^:",34,"^;S",["^1M",[["~$s"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["~$s","~:-","^<1"]]]]],"^7",370,"^;W","^;X","^9",370,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["~$s"]]]]],"^;R","Inputs: [s :- :string]\n  Return: [:string {:min 8, :max 8}]\n          \n\n  Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string."],"~$expression-name",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",58,"^8",7,"^9",58,"^:",22,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause."],"^L","^41","^6","metabase/lib/util.cljc","^:",22,"^;S",["^1M",[["^<:"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",58,"^;W",["^J",[null,"^;X","^;Y"]],"^9",58,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause."],"~$joins->pipeline",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",160,"^8",8,"^9",160,"^:",23,"^<3",true,"^;Q",["^1M",["^;N",["^1M",[["~$joins"]]]]]],"^<3",true,"^L","^4H","^6","metabase/lib/util.cljc","^:",23,"^;S",["^1M",[["^=;"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",160,"^;W","^<A","^9",160,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^=;"]]]]]],"~$update-legacy-boolean-expression->list",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",140,"^8",8,"^9",140,"^:",46,"^<3",true,"^;Q",["^1M",["^;N",["^1M",[["~$m","~$legacy-key","~$pMBQL-key"]]]]],"^;R","Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`"],"^<3",true,"^L","^4B","^6","metabase/lib/util.cljc","^:",46,"^;S",["^1M",[["~$m","^==","^=>"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",140,"^;W",["^J",[null,"^<A","^;X"]],"^9",140,"^;Z",3,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["~$m","^==","^=>"]]]]],"^;R","Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`"],"~$clause?",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",38,"^8",7,"^9",38,"^:",14,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Returns true if this is a clause."],"^L","^3I","^6","metabase/lib/util.cljc","^:",14,"^;S",["^1M",[["^<:"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",38,"^;W","^<<","^9",38,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Returns true if this is a clause."],"~$truncate-alias",["^ ","^;E",["~:function",["^;F",["^;G","^<6"],["^<1",["^ ","^<2",1,"^=8",60]]],["^;F",["^;G","~:metabase.lib.schema.common/non-blank-string",["^;I",["^ ","^<2",0]]],["^<1",["^ ","^<2",1,"^=8",60]]]],"^;K","id64623","^;L",null,"^5",["^ ","^;E",["^=A",["^;F",["^;G","^<6"],["^<1",["^ ","^<2",1,"^=8",60]]],["^;F",["^;G","^=B",["^;I",["^ ","^<2",0]]],["^<1",["^ ","^<2",1,"^=8",60]]]],"^;K","id64623","^6","metabase/lib/util.cljc","^:",24,"^=2",["^ ","^;V",false,"^=3",2,"^;Z",2,"^;S",[["~$s"],["~$s","~$max-bytes"]],"^;Q",["^1M",[["~$s"],["~$s","^=C"]]],"^;U",["^1M",[null,null]]],"^8",10,"^;M",["^1M",["^;N",["^1M",[["~$s"],["~$s","~:-","^=B","^=C","~:-",["^;I",["^ ","^<2",0]]]]]]],"^7",384,"^9",384,"^;Q",["^1M",["^;N",["^1M",[["~$s"],["~$s","^=C"]]]]],"^;R","Inputs: ([s]\n           [s :- :metabase.lib.schema.common/non-blank-string max-bytes :- [:int {:min 0}]])\n  Return: [:string {:min 1, :max 60}]\n          \n\n  Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \"some_really_long_string\" 15) ;   -> \"some_r_8e0f9bc2\"\n    (truncate-alias \"some_really_long_string_2\" 15) ; -> \"some_r_2a3c73eb\""],"^L","^34","^6","metabase/lib/util.cljc","^:",24,"^=2",["^ ","^;V",false,"^=3",2,"^;Z",2,"^;S",[["~$s"],["~$s","^=C"]],"^;Q",["^1M",[["~$s"],["~$s","^=C"]]],"^;U",["^1M",[null,null]]],"^;S",[["~$s"],["~$s","^=C"]],"^;T",null,"^=3",2,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^=5",[["^ ","^=3",1,"^;V",false,"^=6","^;X"],["^ ","^=3",2,"^;V",false,"^=6",["^J",[null,"^<V"]]]],"^;M",["^1M",["^;N",["^1M",[["~$s"],["~$s","~:-","^=B","^=C","~:-",["^;I",["^ ","^<2",0]]]]]]],"^7",384,"^9",384,"^;Z",2,"^;[",true,"^;Q",["^1M",[["~$s"],["~$s","^=C"]]],"^;R","Inputs: ([s]\n           [s :- :metabase.lib.schema.common/non-blank-string max-bytes :- [:int {:min 0}]])\n  Return: [:string {:min 1, :max 60}]\n          \n\n  Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \"some_really_long_string\" 15) ;   -> \"some_r_8e0f9bc2\"\n    (truncate-alias \"some_really_long_string_2\" 15) ; -> \"some_r_2a3c73eb\""],"~$canonical-stage-index",["^ ","^;E",["^;F",["^;G","^<I","^;I"],["^;I",["^ ","^<2",0]]],"^;K","id64523","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<I","^;I"],["^;I",["^ ","^<2",0]]],"^;K","id64523","^6","metabase/lib/util.cljc","^:",31,"^8",10,"^;M",["^1M",["^;N",["^1M",[[["^ ","^<M",["^<N"],"^1Q","^<O"],"~:-","^<I","^;P","~:-","^;I"]]]]],"^7",234,"^9",234,"^;Q",["^1M",["^;N",["^1M",[[["^ ","^<M",["^<N"],"^1Q","^<O"],"^;P"]]]]],"^;R","Inputs: [{:keys [stages], :as _query} :- :map stage-number :- :int]\n  Return: [:int {:min 0}]\n          \n\n  If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc."],"^L","^2[","^6","metabase/lib/util.cljc","^:",31,"^;S",["^1M",[["~$p__64524","^;P"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[[["^ ","^<M",["^<N"],"^1Q","^<O"],"~:-","^<I","^;P","~:-","^;I"]]]]],"^7",234,"^;W",["^J",[null,"^<E"]],"^9",234,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[[["^ ","^<M",["^<N"],"^1Q","^<O"],"^;P"]]]]],"^;R","Inputs: [{:keys [stages], :as _query} :- :map stage-number :- :int]\n  Return: [:int {:min 0}]\n          \n\n  If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc."],"~$field-clause?",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",53,"^8",7,"^9",53,"^:",20,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Returns true if this is a field clause."],"^L","^3L","^6","metabase/lib/util.cljc","^:",20,"^;S",["^1M",[["^<:"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",53,"^;W","^<<","^9",53,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Returns true if this is a field clause."],"~$->stage-metadata",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",163,"^8",7,"^9",163,"^:",23,"^;Q",["^1M",["^;N",["^1M",[["~$source-metadata"]]]]],"^;R","Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]]."],"^L","^4=","^6","metabase/lib/util.cljc","^:",23,"^;S",["^1M",[["^=H"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",163,"^;W",["^J",["^<A","^;X","^;Y"]],"^9",163,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^=H"]]]]],"^;R","Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]]."],"~$with-default-effective-type",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",482,"^8",7,"^9",482,"^:",34,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Adds a default :effective-type property if it does not exist and\n  :base-type is known.\n\n  This is needed only because we have to convert queries to the Legacy\n  form.\n  The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n  :effective-type property, but it should be present for the frontend\n  to work. It defaults to the :base-type property."],"^L","^4G","^6","metabase/lib/util.cljc","^:",34,"^;S",["^1M",[["^<:"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",482,"^;W",["^J",[null,"^<A","^;X","^;Y"]],"^9",482,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^<:"]]]]],"^;R","Adds a default :effective-type property if it does not exist and\n  :base-type is known.\n\n  This is needed only because we have to convert queries to the Legacy\n  form.\n  The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n  :effective-type property, but it should be present for the frontend\n  to work. It defaults to the :base-type property."],"~$add-summary-clause",["^ ","^;E",["^;F",["^;G","^<K","^;I",["~:enum","~:breakout","~:aggregation"],"^<6"],"^<K"],"^;K","id64718","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<K","^;I",["^=K","^=L","^=M"],"^<6"],"^<K"],"^;K","id64718","^6","metabase/lib/util.cljc","^:",28,"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^<K","^;P","~:-","^;I","^<?","~:-",["^=K","^=L","^=M"],"~$a-summary-clause"]]]]],"^7",454,"^9",454,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P","^<?","^=N"]]]]],"^;R","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int location :- [:enum :breakout :aggregation] a-summary-clause]\n  Return: :metabase.lib.schema/query\n          \n\n  If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages."],"^L","^4E","^6","metabase/lib/util.cljc","^:",28,"^;S",["^1M",[["^;O","^;P","^<?","^=N"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^;O","~:-","^<K","^;P","~:-","^;I","^<?","~:-",["^=K","^=L","^=M"],"^=N"]]]]],"^7",454,"^;W",["^J",["^<A","^;X"]],"^9",454,"^;Z",4,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P","^<?","^=N"]]]]],"^;R","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int location :- [:enum :breakout :aggregation] a-summary-clause]\n  Return: :metabase.lib.schema/query\n          \n\n  If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages."],"~$strip-id",["^ ","^;E",["^;F",["^;G","^<1"],"^<1"],"^;K","id64700","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<1"],"^<1"],"^;K","id64700","^6","metabase/lib/util.cljc","^:",18,"^8",10,"^;M",["^1M",["^;N",["^1M",[["~$display-name","~:-","^<1"]]]]],"^7",446,"^9",446,"^;Q",["^1M",["^;N",["^1M",[["^=P"]]]]],"^;R","Inputs: [display-name :- :string]\n  Return: :string\n          \n\n  Given a display name string like \"Product ID\", this will drop the trailing \"ID\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining."],"^L","^4A","^6","metabase/lib/util.cljc","^:",18,"^;S",["^1M",[["^=P"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^=P","~:-","^<1"]]]]],"^7",446,"^;W","^<V","^9",446,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^=P"]]]]],"^;R","Inputs: [display-name :- :string]\n  Return: :string\n          \n\n  Given a display name string like \"Product ID\", this will drop the trailing \"ID\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining."],"~$truncate-alias-max-length-bytes",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",360,"^8",16,"^9",360,"^:",47,"^<3",true],"^<3",true,"^L","^4U","^6","metabase/lib/util.cljc","^:",47,"^8",1,"^7",360,"^9",360,"^=6","^<E","^;R","Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n  reasoning."],"~$source-card-id",["^ ","^;E",["^;F",["^;G","^<6"],["^<7","^<C"]],"^;K","id64681","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<6"],["^<7","^<C"]],"^;K","id64681","^6","metabase/lib/util.cljc","^:",24,"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O"]]]]],"^7",418,"^9",418,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If this query has a `:source-card` ID, return it."],"^L","^4P","^6","metabase/lib/util.cljc","^:",24,"^;S",["^1M",[["^;O"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^;O"]]]]],"^7",418,"^;W","^;X","^9",418,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If this query has a `:source-card` ID, return it."],"~$inner-query->stages",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",178,"^8",8,"^9",178,"^:",27,"^<3",true,"^;Q",["^1M",["^;N",["^1M",[[["^ ","^<M",["~$source-query","^=H"],"^1Q","~$inner-query"]]]]]]],"^<3",true,"^L","^44","^6","metabase/lib/util.cljc","^:",27,"^;S",["^1M",[["~$p__64501"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",178,"^;W","^<A","^9",178,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[[["^ ","^<M",["^=T","^=H"],"^1Q","^=U"]]]]]]],"~$unique-name-generator",["^ ","^;E",["^;F","^;G",["^;F",["^;G","^=B"],"^=B"]],"^;K","id64689","^;L",null,"^5",["^ ","^;E",["^;F","^;G",["^;F",["^;G","^=B"],"^=B"]],"^;K","id64689","^6","metabase/lib/util.cljc","^:",31,"^8",10,"^;M",["^1M",["^;N",["^1M",[[]]]]],"^7",423,"^9",423,"^;Q",["^1M",["^;N",["^1M",[[]]]]],"^;R","Inputs: []\n  Return: [:=> [:cat :metabase.lib.schema.common/non-blank-string] :metabase.lib.schema.common/non-blank-string]\n          \n\n  Create a new function with the signature\n\n    (f str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash)."],"^L","^2H","^6","metabase/lib/util.cljc","^:",31,"^;S",["^1M",[[]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[[]]]]],"^7",423,"^;W","~$function","^9",423,"^;Z",0,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[[]]]]],"^;R","Inputs: []\n  Return: [:=> [:cat :metabase.lib.schema.common/non-blank-string] :metabase.lib.schema.common/non-blank-string]\n          \n\n  Create a new function with the signature\n\n    (f str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash)."],"~$mbql-query->pipeline",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",199,"^8",8,"^9",199,"^:",28,"^<3",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information."],"^<3",true,"^L","^4?","^6","metabase/lib/util.cljc","^:",28,"^;S",["^1M",[["^;O"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",199,"^;W",["^J",["^;X","^;Y"]],"^9",199,"^;Z",1,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O"]]]]],"^;R","Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information."],"~$first-stage?",["^ ","^;L",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",256,"^8",7,"^9",256,"^:",19,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"^;R","Whether a `stage-number` is referring to the first stage of a query or not."],"^L","^4R","^6","metabase/lib/util.cljc","^:",19,"^;S",["^1M",[["^;O","^;P"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^7",256,"^;W","^<<","^9",256,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"^;R","Whether a `stage-number` is referring to the first stage of a query or not."],"~$strip-id-regex",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",441,"^8",16,"^9",441,"^:",30,"^<3",true],"^<3",true,"^L","^4L","^6","metabase/lib/util.cljc","^:",30,"^8",1,"^7",441,"^9",441,"^=6","^<4"],"^;H",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",212,"^8",6,"^9",212,"^:",24],"^L","^3Q","^6","metabase/lib/util.cljc","^:",24,"^8",1,"^7",212,"^9",212,"^=6","~$cljs.core/IVector","^;R","Schema for a map that is either a legacy query OR a pMBQL query."],"~$previous-stage",["^ ","^;E",["^;F",["^;G","^<6","^;I"],["^<7","^;J"]],"^;K","id64532","^;L",null,"^5",["^ ","^;E",["^;F",["^;G","^<6","^;I"],["^<7","^;J"]],"^;K","id64532","^6","metabase/lib/util.cljc","^:",24,"^8",10,"^;M",["^1M",["^;N",["^1M",[["^;O","^;P","~:-","^;I"]]]]],"^7",278,"^9",278,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"^;R","Inputs: [query stage-number :- :int]\n  Return: [:maybe :metabase.lib.schema/stage]\n          \n\n  Return the previous stage of the query, if there is one; otherwise return `nil`."],"^L","^4F","^6","metabase/lib/util.cljc","^:",24,"^;S",["^1M",[["^;O","^;P"]]],"^;T",null,"^;U",["^1M",[null,null]],"^8",1,"^;V",false,"^;M",["^1M",["^;N",["^1M",[["^;O","^;P","~:-","^;I"]]]]],"^7",278,"^;W",["^J",["^;X","^;Y"]],"^9",278,"^;Z",2,"^;[",true,"^;Q",["^1M",["^;N",["^1M",[["^;O","^;P"]]]]],"^;R","Inputs: [query stage-number :- :int]\n  Return: [:maybe :metabase.lib.schema/stage]\n          \n\n  Return the previous stage of the query, if there is one; otherwise return `nil`."],"~$truncated-alias-hash-suffix-length",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",365,"^8",16,"^9",365,"^:",50,"^<3",true],"^<3",true,"^L","^3N","^6","metabase/lib/util.cljc","^:",50,"^8",1,"^7",365,"^9",365,"^=6","^<E","^;R","Length of the hash suffixed to truncated strings by [[truncate-alias]]."]],"^1K",["^ ","^W","^X","^11","^12","~$u","^15","^16","^17","^1:","^1;","^C","^C","^17","^17","^15","^15","^1;","^1;","^12","^12","^X","^X"],"~:cljs.analyzer/constants",["^ ","^1H",["^J",["^=K","~:lib/uuid","~:name-key-fn","~:lib/type","~:lib/expression-name","~:metadata/column","~:base-type","~:expression","~:stages","~:else","~:source-query","~:filters","~:columns","~:value","~:or","~:fields","~:mbql/query","~:lib/stage-metadata","~:joins","~:source-metadata","~:field","~:type","~:mbql/join","~:effective-type","~:metadata/results","~:mbql.stage/native","~:filter","~:native","~:conditions","~:condition","~:source-table","~:expressions","^=L","~:error/message","~:order-by","~:mbql.stage/mbql","~:and","^=M","~:source-card","~:query","~:unique-alias-fn","~:=","^<I","~:always","~:num-stages"]],"~:order",["^>4","^>G","^>7","^>@","^>J","^>6","^>I","^>R","^>B","^>:","^>E","^>O","^><","^>;","^>C","^>L","^>N","^>X","^>H","^>V","^>Q","^>=","^>P","^>?","^>8","^>K","^>F","^>D","^>U","^>Z","^>M","^>>","^>A","^<I","^>S","^=K","~:=","^>[","^>W","^>5","^>Y","^=M","^=L","^>T","^>9"]],"^1R",["^ ","^1I",["^J",[]]],"^1S",["^ ","^P",["^ ","^1Q","^1G"]],"^1T",["^1<","^C","^Q","^10","^1B","^Z","^1E","^1A","^1;","^1?","^V","^14","^17","^1@","^18","^12","^15","^X"]],"^S","^M","~:ns-specs",["^ "],"~:ns-spec-vars",["^J",[]],"~:compiler-options",["^4W",[["^?3","~:static-fns"],true,["^?3","~:shadow-tweaks"],null,["^?3","~:source-map-inline"],null,["^?3","~:elide-asserts"],false,["^?3","~:optimize-constants"],null,["^?3","^1Y"],null,["^?3","~:external-config"],null,["^?3","~:tooling-config"],null,["^?3","~:emit-constants"],null,["^?3","~:load-tests"],null,["^?3","~:form-size-threshold"],null,["^?3","~:global-goog-object&array"],null,["^?3","~:data-readers"],null,["^?3","~:infer-externs"],"~:auto",["^?3","^1["],["^J",["^20","^21"]],["~:js-options","~:js-provider"],"^1I",["~:mode"],"~:dev",["^?3","~:fn-invoke-direct"],null,["^?3","~:source-map"],"/dev/null"]]]