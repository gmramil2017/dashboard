["^ ","~:output",["^ ","~:js","goog.provide('metabase.lib.join');\n/**\n * A Join that may not yet have an `:alias`, which is normally required; [[join]] accepts this and will add a default\n *   alias if one is not present.\n */\nmetabase.lib.join.JoinWithOptionalAlias = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"merge\",\"merge\",-1804319409),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"ref\",\"ref\",1289896967),new cljs.core.Keyword(\"metabase.lib.schema.join\",\"join\",\"metabase.lib.schema.join/join\",1110197236)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"map\",\"map\",1371690461),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"optional\",\"optional\",2053951509),true], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"ref\",\"ref\",1289896967),new cljs.core.Keyword(\"metabase.lib.schema.join\",\"alias\",\"metabase.lib.schema.join/alias\",53862412)], null)], null)], null)], null);\n/**\n * A join that may not yet have an `:alias` or `:conditions`.\n */\nmetabase.lib.join.PartialJoin = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"merge\",\"merge\",-1804319409),metabase.lib.join.JoinWithOptionalAlias,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"map\",\"map\",1371690461),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"optional\",\"optional\",2053951509),true], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"ref\",\"ref\",1289896967),new cljs.core.Keyword(\"metabase.lib.schema.join\",\"conditions\",\"metabase.lib.schema.join/conditions\",118173612)], null)], null)], null)], null);\nmetabase.lib.join.FieldOrPartialJoin = new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"or\",\"or\",235744169),metabase.lib.metadata.ColumnMetadata,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"ref\",\"ref\",1289896967),new cljs.core.Keyword(\"mbql.clause\",\"field\",\"mbql.clause/field\",1497292735)], null),metabase.lib.join.PartialJoin], null);\n/**\n * Inputs: [field-or-join :- [:maybe FieldOrPartialJoin]]\n *   Return: [:maybe :metabase.lib.schema.common/non-blank-string]\n *        \n * \n *   Get the current join alias associated with something, if it has one.\n */\nmetabase.lib.join.current_join_alias = (function metabase$lib$join$current_join_alias(field_or_join){\n\nvar G__79982 = metabase.lib.dispatch.dispatch_value(field_or_join);\nvar G__79982__$1 = (((G__79982 instanceof cljs.core.Keyword))?G__79982.fqn:null);\nswitch (G__79982__$1) {\ncase \"dispatch-type/nil\":\nreturn null;\n\nbreak;\ncase \"field\":\nreturn new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794).cljs$core$IFn$_invoke$arity$1(metabase.lib.options.options(field_or_join));\n\nbreak;\ncase \"metadata/column\":\nreturn new cljs.core.Keyword(\"metabase.lib.join\",\"join-alias\",\"metabase.lib.join/join-alias\",1166233023).cljs$core$IFn$_invoke$arity$1(field_or_join);\n\nbreak;\ncase \"mbql/join\":\nreturn new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630).cljs$core$IFn$_invoke$arity$1(field_or_join);\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__79982__$1)].join('')));\n\n}\n});\n/**\n * Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for the `:field` refs inside `:fields`\n *   as needed.\n */\nmetabase.lib.join.with_join_alias_update_join_fields = (function metabase$lib$join$with_join_alias_update_join_fields(join,new_alias){\nvar G__79983 = join;\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230).cljs$core$IFn$_invoke$arity$1(join))){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(G__79983,new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230),(function (fields){\nif((!(cljs.core.sequential_QMARK_(fields)))){\nreturn fields;\n} else {\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (field_ref){\nreturn (metabase.lib.join.with_join_alias.cljs$core$IFn$_invoke$arity$2 ? metabase.lib.join.with_join_alias.cljs$core$IFn$_invoke$arity$2(field_ref,new_alias) : metabase.lib.join.with_join_alias.call(null,field_ref,new_alias));\n}),fields);\n}\n}));\n} else {\nreturn G__79983;\n}\n});\n/**\n * Inputs: [condition :- :metabase.lib.schema.expression/boolean]\n *   Return: :boolean\n *        \n * \n *   Whether this join condition is a binary condition with two `:field` references (a LHS and a RHS), as you'd produce\n *   in the frontend using functions like [[join-condition-operators]], [[join-condition-lhs-columns]],\n *   and [[join-condition-rhs-columns]].\n */\nmetabase.lib.join.standard_join_condition_QMARK_ = (function metabase$lib$join$standard_join_condition_QMARK_(condition){\n\nreturn cljs.core.first(cljs.core.seq(cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.some_QMARK_,(function metabase$lib$join$standard_join_condition_QMARK__$_match_79985(_AMPERSAND_parents,_AMPERSAND_match){\ntry{if(((cljs.core.vector_QMARK_(_AMPERSAND_match)) && ((cljs.core.count(_AMPERSAND_match) === 4)))){\ntry{var _AMPERSAND_match_0__79993 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(0));\nif((_AMPERSAND_match_0__79993 instanceof cljs.core.Keyword)){\ntry{var _AMPERSAND_match_2__79995 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(2));\nif(((cljs.core.vector_QMARK_(_AMPERSAND_match_2__79995)) && ((cljs.core.count(_AMPERSAND_match_2__79995) === 3)))){\ntry{var _AMPERSAND_match_2__79995_0__79997 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_2__79995,(0));\nif(cljs.core.keyword_identical_QMARK_(_AMPERSAND_match_2__79995_0__79997,new cljs.core.Keyword(null,\"field\",\"field\",-1302436500))){\ntry{var _AMPERSAND_match_3__79996 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(3));\nif(((cljs.core.vector_QMARK_(_AMPERSAND_match_3__79996)) && ((cljs.core.count(_AMPERSAND_match_3__79996) === 3)))){\ntry{var _AMPERSAND_match_3__79996_0__80000 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_3__79996,(0));\nif(cljs.core.keyword_identical_QMARK_(_AMPERSAND_match_3__79996_0__80000,new cljs.core.Keyword(null,\"field\",\"field\",-1302436500))){\nvar _rhs_opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_3__79996,(1));\nvar _rhs_id_or_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_3__79996,(2));\nvar _lhs_opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_2__79995,(1));\nvar _lhs_id_or_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_2__79995,(2));\nvar _operator = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(0));\nvar _opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(1));\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [true], null);\n} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80008){if((e80008 instanceof Error)){\nvar e__62528__auto__ = e80008;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80008;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80007){if((e80007 instanceof Error)){\nvar e__62528__auto__ = e80007;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80007;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80006){if((e80006 instanceof Error)){\nvar e__62528__auto__ = e80006;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80006;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80005){if((e80005 instanceof Error)){\nvar e__62528__auto__ = e80005;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80005;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80004){if((e80004 instanceof Error)){\nvar e__62528__auto__ = e80004;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80004;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80003){if((e80003 instanceof Error)){\nvar e__62528__auto__ = e80003;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [false], null);\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80003;\n\n}\n}})(cljs.core.PersistentVector.EMPTY,condition))));\n});\n/**\n * If `condition` is a [[standard-join-condition?]], return the RHS.\n */\nmetabase.lib.join.standard_join_condition_rhs = (function metabase$lib$join$standard_join_condition_rhs(condition){\nif(cljs.core.truth_(metabase.lib.join.standard_join_condition_QMARK_(condition))){\nvar vec__80009 = condition;\nvar _operator = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80009,(0),null);\nvar _opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80009,(1),null);\nvar _lhs = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80009,(2),null);\nvar rhs = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80009,(3),null);\nreturn rhs;\n} else {\nreturn null;\n}\n});\n/**\n * If `condition` is a [[standard-join-condition?]], update the RHS with `f` like\n * \n *  (apply f rhs args)\n */\nmetabase.lib.join.standard_join_condition_update_rhs = (function metabase$lib$join$standard_join_condition_update_rhs(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___80254 = arguments.length;\nvar i__5770__auto___80255 = (0);\nwhile(true){\nif((i__5770__auto___80255 < len__5769__auto___80254)){\nargs__5775__auto__.push((arguments[i__5770__auto___80255]));\n\nvar G__80258 = (i__5770__auto___80255 + (1));\ni__5770__auto___80255 = G__80258;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((2) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((2)),(0),null)):null);\nreturn metabase.lib.join.standard_join_condition_update_rhs.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5776__auto__);\n});\n\n(metabase.lib.join.standard_join_condition_update_rhs.cljs$core$IFn$_invoke$arity$variadic = (function (condition,f,args){\nif(cljs.core.not(metabase.lib.join.standard_join_condition_QMARK_(condition))){\nreturn condition;\n} else {\nvar vec__80018 = condition;\nvar operator = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80018,(0),null);\nvar opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80018,(1),null);\nvar lhs = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80018,(2),null);\nvar rhs = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80018,(3),null);\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [operator,opts,lhs,cljs.core.apply.cljs$core$IFn$_invoke$arity$3(f,rhs,args)], null);\n}\n}));\n\n(metabase.lib.join.standard_join_condition_update_rhs.cljs$lang$maxFixedArity = (2));\n\n/** @this {Function} */\n(metabase.lib.join.standard_join_condition_update_rhs.cljs$lang$applyTo = (function (seq80012){\nvar G__80013 = cljs.core.first(seq80012);\nvar seq80012__$1 = cljs.core.next(seq80012);\nvar G__80014 = cljs.core.first(seq80012__$1);\nvar seq80012__$2 = cljs.core.next(seq80012__$1);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__80013,G__80014,seq80012__$2);\n}));\n\n/**\n * Inputs: [join :- PartialJoin old-alias :- [:maybe :metabase.lib.schema.common/non-blank-string] new-alias :- [:maybe :metabase.lib.schema.common/non-blank-string]]\n *   Return: PartialJoin\n *        \n * \n *   Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for inside the `:conditions` of the\n *   join.\n * \n *   If `old-alias` is specified, uses [[metabase.mbql.util.match]] to update all the `:field` references using the old\n *   alias.\n * \n *   If `old-alias` is `nil`, updates the RHS of all 'standard' conditions (binary filter clauses with two `:field` refs as\n *   args, e.g. the kind you'd get if you were using [[join-condition-operators]] and the like to create them). This\n *   currently doesn't handle more complex filter clauses that were created without the 'normal' MLv2 functions used by\n *   the frontend; we can add this in the future if we need it.\n */\nmetabase.lib.join.with_join_alias_update_join_conditions = (function metabase$lib$join$with_join_alias_update_join_conditions(join,old_alias,new_alias){\n\nif(cljs.core.empty_QMARK_(new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270).cljs$core$IFn$_invoke$arity$1(join))){\nreturn join;\n} else {\nif(cljs.core.truth_(old_alias)){\nreturn metabase.mbql.util.match.impl.update_in_unless_empty(join,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270)], null),(function (x__63598__auto__){\nreturn (function metabase$lib$join$with_join_alias_update_join_conditions_$_replace_80036(_AMPERSAND_parents,_AMPERSAND_match){\ntry{if(((cljs.core.vector_QMARK_(_AMPERSAND_match)) && ((cljs.core.count(_AMPERSAND_match) === 3)))){\ntry{var _AMPERSAND_match_0__80047 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(0));\nif(cljs.core.keyword_identical_QMARK_(_AMPERSAND_match_0__80047,new cljs.core.Keyword(null,\"field\",\"field\",-1302436500))){\ntry{var _AMPERSAND_match_1__80048 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(1));\nif((((!((_AMPERSAND_match_1__80048 == null))))?(((((_AMPERSAND_match_1__80048.cljs$lang$protocol_mask$partition0$ & (256))) || ((cljs.core.PROTOCOL_SENTINEL === _AMPERSAND_match_1__80048.cljs$core$ILookup$))))?true:(((!_AMPERSAND_match_1__80048.cljs$lang$protocol_mask$partition0$))?cljs.core.native_satisfies_QMARK_(cljs.core.ILookup,_AMPERSAND_match_1__80048):false)):cljs.core.native_satisfies_QMARK_(cljs.core.ILookup,_AMPERSAND_match_1__80048))){\ntry{var _AMPERSAND_match_1__80048_join_alias__80052 = cljs.core.get.cljs$core$IFn$_invoke$arity$3(_AMPERSAND_match_1__80048,new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794),new cljs.core.Keyword(\"clojure.core.match\",\"not-found\",\"clojure.core.match/not-found\",1553053780));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_1__80048_join_alias__80052,old_alias)){\nvar _id_or_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(2));\nreturn (metabase.lib.join.with_join_alias.cljs$core$IFn$_invoke$arity$2 ? metabase.lib.join.with_join_alias.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,new_alias) : metabase.lib.join.with_join_alias.call(null,_AMPERSAND_match,new_alias));\n} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80057){if((e80057 instanceof Error)){\nvar e__62528__auto__ = e80057;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80057;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80055){if((e80055 instanceof Error)){\nvar e__62528__auto__ = e80055;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80055;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80054){if((e80054 instanceof Error)){\nvar e__62528__auto__ = e80054;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80054;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80053){if((e80053 instanceof Error)){\nvar e__62528__auto__ = e80053;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nreturn metabase.mbql.util.match.impl.replace_in_collection(metabase$lib$join$with_join_alias_update_join_conditions_$_replace_80036,_AMPERSAND_parents,_AMPERSAND_match);\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80053;\n\n}\n}})(cljs.core.PersistentVector.EMPTY,x__63598__auto__);\n}));\n} else {\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(join,new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270),(function (conditions){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (condition){\nreturn metabase.lib.join.standard_join_condition_update_rhs.cljs$core$IFn$_invoke$arity$variadic(condition,metabase.lib.join.with_join_alias,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new_alias], 0));\n}),conditions);\n}));\n\n}\n}\n});\n/**\n * Impl for [[with-join-alias]] for a join.\n */\nmetabase.lib.join.with_join_alias_update_join = (function metabase$lib$join$with_join_alias_update_join(join,new_alias){\nvar old_alias = metabase.lib.join.current_join_alias(join);\nreturn metabase.lib.join.with_join_alias_update_join_conditions(metabase.lib.join.with_join_alias_update_join_fields(metabase.util.assoc_dissoc(join,new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630),new_alias),new_alias),old_alias,new_alias);\n});\n/**\n * Inputs: [field-or-join :- FieldOrPartialJoin join-alias :- [:maybe :metabase.lib.schema.common/non-blank-string]]\n *   Return: FieldOrPartialJoin\n *        \n * \n *   Add OR REMOVE a specific `join-alias` to `field-or-join`, which is either a `:field`/Field metadata, or a join map.\n *   Does not recursively update other references (yet; we can add this in the future).\n */\nmetabase.lib.join.with_join_alias = (function metabase$lib$join$with_join_alias(field_or_join,join_alias){\n\nvar G__80059 = metabase.lib.dispatch.dispatch_value(field_or_join);\nvar G__80059__$1 = (((G__80059 instanceof cljs.core.Keyword))?G__80059.fqn:null);\nswitch (G__80059__$1) {\ncase \"field\":\nreturn metabase.lib.options.update_options.cljs$core$IFn$_invoke$arity$variadic(field_or_join,metabase.util.assoc_dissoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794),join_alias], 0));\n\nbreak;\ncase \"metadata/column\":\nreturn metabase.util.assoc_dissoc(field_or_join,new cljs.core.Keyword(\"metabase.lib.join\",\"join-alias\",\"metabase.lib.join/join-alias\",1166233023),join_alias);\n\nbreak;\ncase \"mbql/join\":\nreturn metabase.lib.join.with_join_alias_update_join(field_or_join,join_alias);\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__80059__$1)].join('')));\n\n}\n});\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int join-alias :- :metabase.lib.schema.common/non-blank-string]\n *   Return: :metabase.lib.schema.join/join\n *        \n * \n *   Resolve a join with a specific `join-alias`.\n */\nmetabase.lib.join.resolve_join = (function metabase$lib$join$resolve_join(query,stage_number,join_alias){\n\nvar map__80063 = metabase.lib.util.query_stage(query,stage_number);\nvar map__80063__$1 = cljs.core.__destructure_map(map__80063);\nvar joins = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80063__$1,new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699));\nvar or__5045__auto__ = medley.core.find_first.cljs$core$IFn$_invoke$arity$2((function (p1__80060_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630).cljs$core$IFn$_invoke$arity$1(p1__80060_SHARP_),join_alias);\n}),joins);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(metabase.shared.util.i18n.js_i18n.cljs$core$IFn$_invoke$arity$variadic(\"No join named {0}, found: {1}\",cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([join_alias], 0)),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630),joins)], 0))], 0)),new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794),join_alias,new cljs.core.Keyword(null,\"query\",\"query\",-1288509510),query,new cljs.core.Keyword(null,\"stage-number\",\"stage-number\",-1752729638),stage_number], null));\n}\n});\nmetabase.lib.metadata.calculation.display_name_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),(function (query,_stage_number,p__80068,_style){\nvar map__80069 = p__80068;\nvar map__80069__$1 = cljs.core.__destructure_map(map__80069);\nvar _join = map__80069__$1;\nvar vec__80070 = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80069__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nvar map__80073 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__80070,(0),null);\nvar map__80073__$1 = cljs.core.__destructure_map(map__80073);\nvar _first_stage = map__80073__$1;\nvar source_table = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80073__$1,new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692));\nvar source_card = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80073__$1,new cljs.core.Keyword(null,\"source-card\",\"source-card\",-1580820390));\nvar or__5045__auto__ = (cljs.core.truth_(source_table)?new cljs.core.Keyword(null,\"display-name\",\"display-name\",694513143).cljs$core$IFn$_invoke$arity$1(metabase.lib.metadata.table(query,source_table)):null);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nvar or__5045__auto____$1 = (cljs.core.truth_(source_card)?metabase.shared.util.i18n.js_i18n.cljs$core$IFn$_invoke$arity$variadic(\"Question {0}\",cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([source_card], 0)):null);\nif(cljs.core.truth_(or__5045__auto____$1)){\nreturn or__5045__auto____$1;\n} else {\nreturn metabase.shared.util.i18n.js_i18n(\"Native Query\");\n}\n}\n}));\nmetabase.lib.metadata.calculation.display_info_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),(function (query,stage_number,join){\nvar display_name = metabase.lib.metadata.calculation.display_name.cljs$core$IFn$_invoke$arity$3(query,stage_number,join);\nreturn new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"name\",\"name\",1843675177),(function (){var or__5045__auto__ = new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630).cljs$core$IFn$_invoke$arity$1(join);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn display_name;\n}\n})(),new cljs.core.Keyword(null,\"display-name\",\"display-name\",694513143),display_name], null);\n}));\nmetabase.lib.metadata.calculation.metadata_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),(function (_query,_stage_number,_query__$1){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"You can't calculate a metadata map for a join! Use lib.metadata.calculation/returned-columns-method instead.\",cljs.core.PersistentArrayMap.EMPTY);\n}));\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int column-metadata :- lib.metadata/ColumnMetadata join-alias :- :metabase.lib.schema.common/non-blank-string]\n *   Return: lib.metadata.calculation/ColumnMetadataWithSource\n *        \n * \n *   For a column that comes from a join `:fields` list, add or update metadata as needed, e.g. include join name in the\n *   display name.\n */\nmetabase.lib.join.column_from_join_fields = (function metabase$lib$join$column_from_join_fields(query,stage_number,column_metadata,join_alias){\n\nvar column_metadata__$1 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(column_metadata,new cljs.core.Keyword(null,\"source-alias\",\"source-alias\",1652088724),join_alias);\nvar col = metabase.lib.join.with_join_alias(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(column_metadata__$1,new cljs.core.Keyword(null,\"display-name\",\"display-name\",694513143),metabase.lib.metadata.calculation.display_name.cljs$core$IFn$_invoke$arity$3(query,stage_number,column_metadata__$1),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(\"lib\",\"source\",\"lib/source\",-434086550),new cljs.core.Keyword(\"source\",\"joins\",\"source/joins\",1225821486)], 0)),join_alias);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(metabase.lib.join.current_join_alias(col),join_alias)){\n} else {\nthrow (new Error(\"Assert failed: (= (current-join-alias col) join-alias)\"));\n}\n\nreturn col;\n});\nmetabase.lib.metadata.calculation.display_name_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"option\",\"join.strategy\",\"option/join.strategy\",1337097154),(function (_query,_stage_number,p__80075,_style){\nvar map__80076 = p__80075;\nvar map__80076__$1 = cljs.core.__destructure_map(map__80076);\nvar strategy = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80076__$1,new cljs.core.Keyword(null,\"strategy\",\"strategy\",-1471631918));\nvar G__80077 = strategy;\nvar G__80077__$1 = (((G__80077 instanceof cljs.core.Keyword))?G__80077.fqn:null);\nswitch (G__80077__$1) {\ncase \"left-join\":\nreturn metabase.shared.util.i18n.js_i18n(\"Left outer join\");\n\nbreak;\ncase \"right-join\":\nreturn metabase.shared.util.i18n.js_i18n(\"Right outer join\");\n\nbreak;\ncase \"inner-join\":\nreturn metabase.shared.util.i18n.js_i18n(\"Inner join\");\n\nbreak;\ncase \"full-join\":\nreturn metabase.shared.util.i18n.js_i18n(\"Full outer join\");\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__80077__$1)].join('')));\n\n}\n}));\nmetabase.lib.metadata.calculation.display_info_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"option\",\"join.strategy\",\"option/join.strategy\",1337097154),(function (query,stage_number,p__80078){\nvar map__80090 = p__80078;\nvar map__80090__$1 = cljs.core.__destructure_map(map__80090);\nvar option = map__80090__$1;\nvar strategy = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80090__$1,new cljs.core.Keyword(null,\"strategy\",\"strategy\",-1471631918));\nvar default$ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80090__$1,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328));\nvar G__80091 = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"short-name\",\"short-name\",-1767085022),metabase.util.qualified_name(strategy),new cljs.core.Keyword(null,\"display-name\",\"display-name\",694513143),metabase.lib.metadata.calculation.display_name.cljs$core$IFn$_invoke$arity$3(query,stage_number,option)], null);\nif(cljs.core.truth_(default$)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(G__80091,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328),true);\n} else {\nreturn G__80091;\n}\n}));\n/**\n * Inputs: [join-alias :- :metabase.lib.schema.common/non-blank-string field-name :- :metabase.lib.schema.common/non-blank-string]\n *   Return: :metabase.lib.schema.common/non-blank-string\n *        \n * \n *   Desired alias for a Field that comes from a join, e.g.\n * \n *  MyJoin__my_field\n * \n *   You should pass the results thru a unique name function.\n */\nmetabase.lib.join.joined_field_desired_alias = (function metabase$lib$join$joined_field_desired_alias(join_alias,field_name){\n\nreturn (metabase.lib.util.format.cljs$core$IFn$_invoke$arity$3 ? metabase.lib.util.format.cljs$core$IFn$_invoke$arity$3(\"%s__%s\",join_alias,field_name) : metabase.lib.util.format.call(null,\"%s__%s\",join_alias,field_name));\n});\n/**\n * Inputs: [join :- [:map [:alias {:error/message \"Join must have an alias to determine column aliases!\"} :metabase.lib.schema.common/non-blank-string]] unique-name-fn :- fn? col :- :map]\n *   Return: :map\n */\nmetabase.lib.join.add_source_and_desired_aliases = (function metabase$lib$join$add_source_and_desired_aliases(join,unique_name_fn,col){\n\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(col,new cljs.core.Keyword(\"lib\",\"source-column-alias\",\"lib/source-column-alias\",1494821386),cljs.core.some_fn.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"source-column-alias\",\"lib/source-column-alias\",1494821386),new cljs.core.Keyword(null,\"name\",\"name\",1843675177))(col),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(\"lib\",\"desired-column-alias\",\"lib/desired-column-alias\",-1998967402),(function (){var G__80101 = metabase.lib.join.joined_field_desired_alias(new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630).cljs$core$IFn$_invoke$arity$1(join),cljs.core.some_fn.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"source-column-alias\",\"lib/source-column-alias\",1494821386),new cljs.core.Keyword(null,\"name\",\"name\",1843675177))(col));\nreturn (unique_name_fn.cljs$core$IFn$_invoke$arity$1 ? unique_name_fn.cljs$core$IFn$_invoke$arity$1(G__80101) : unique_name_fn.call(null,G__80101));\n})()], 0));\n});\nmetabase.lib.metadata.calculation.returned_columns_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),(function (query,stage_number,p__80102,p__80103){\nvar map__80104 = p__80102;\nvar map__80104__$1 = cljs.core.__destructure_map(map__80104);\nvar join = map__80104__$1;\nvar join_alias = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80104__$1,new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630));\nvar fields = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__80104__$1,new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230),new cljs.core.Keyword(null,\"none\",\"none\",1333468478));\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80104__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nvar map__80105 = p__80103;\nvar map__80105__$1 = cljs.core.__destructure_map(map__80105);\nvar options = map__80105__$1;\nvar unique_name_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80105__$1,new cljs.core.Keyword(null,\"unique-name-fn\",\"unique-name-fn\",-755402870));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fields,new cljs.core.Keyword(null,\"none\",\"none\",1333468478))){\nreturn null;\n} else {\nvar ensure_previous_stages_have_metadata = (((typeof metabase !== 'undefined') && (typeof metabase.lib !== 'undefined') && (typeof metabase.lib.stage !== 'undefined') && (typeof metabase.lib.stage.ensure_previous_stages_have_metadata !== 'undefined'))?(new cljs.core.Var((function (){\nreturn metabase.lib.stage.ensure_previous_stages_have_metadata;\n}),cljs.core.with_meta(new cljs.core.Symbol(\"metabase.lib.stage\",\"ensure-previous-stages-have-metadata\",\"metabase.lib.stage/ensure-previous-stages-have-metadata\",2048342183,null),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"cljs.analyzer\",\"no-resolve\",\"cljs.analyzer/no-resolve\",-1872351017),true], null)),null)):null);\nvar join_query = (function (){var G__80128 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(query,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),stages);\nif(cljs.core.truth_(ensure_previous_stages_have_metadata)){\nreturn (ensure_previous_stages_have_metadata.cljs$core$IFn$_invoke$arity$2 ? ensure_previous_stages_have_metadata.cljs$core$IFn$_invoke$arity$2(G__80128,(-1)) : ensure_previous_stages_have_metadata.call(null,G__80128,(-1)));\n} else {\nreturn G__80128;\n}\n})();\nvar field_metadatas = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fields,new cljs.core.Keyword(null,\"all\",\"all\",892129742)))?metabase.lib.metadata.calculation.returned_columns.cljs$core$IFn$_invoke$arity$4(join_query,(-1),cljs.core.peek(stages),options):(function (){var iter__5523__auto__ = (function metabase$lib$join$iter__80130(s__80131){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s__80131__$1 = s__80131;\nwhile(true){\nvar temp__5804__auto__ = cljs.core.seq(s__80131__$1);\nif(temp__5804__auto__){\nvar s__80131__$2 = temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(s__80131__$2)){\nvar c__5521__auto__ = cljs.core.chunk_first(s__80131__$2);\nvar size__5522__auto__ = cljs.core.count(c__5521__auto__);\nvar b__80133 = cljs.core.chunk_buffer(size__5522__auto__);\nif((function (){var i__80132 = (0);\nwhile(true){\nif((i__80132 < size__5522__auto__)){\nvar field_ref = cljs.core._nth(c__5521__auto__,i__80132);\nvar join_field = metabase.lib.options.update_options.cljs$core$IFn$_invoke$arity$variadic(field_ref,cljs.core.dissoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794)], 0));\ncljs.core.chunk_append(b__80133,metabase.lib.metadata.calculation.metadata.cljs$core$IFn$_invoke$arity$3(join_query,(-1),join_field));\n\nvar G__80281 = (i__80132 + (1));\ni__80132 = G__80281;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__80133),metabase$lib$join$iter__80130(cljs.core.chunk_rest(s__80131__$2)));\n} else {\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__80133),null);\n}\n} else {\nvar field_ref = cljs.core.first(s__80131__$2);\nvar join_field = metabase.lib.options.update_options.cljs$core$IFn$_invoke$arity$variadic(field_ref,cljs.core.dissoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794)], 0));\nreturn cljs.core.cons(metabase.lib.metadata.calculation.metadata.cljs$core$IFn$_invoke$arity$3(join_query,(-1),join_field),metabase$lib$join$iter__80130(cljs.core.rest(s__80131__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n}),null,null));\n});\nreturn iter__5523__auto__(fields);\n})());\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (field_metadata){\nreturn metabase.lib.join.add_source_and_desired_aliases(join,unique_name_fn,metabase.lib.join.column_from_join_fields(query,stage_number,field_metadata,join_alias));\n}),field_metadatas);\n}\n}));\nmetabase.lib.metadata.calculation.visible_columns_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),(function (query,stage_number,join,options){\nreturn metabase.lib.metadata.calculation.returned_columns.cljs$core$IFn$_invoke$arity$4(query,stage_number,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(join,new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230),new cljs.core.Keyword(null,\"all\",\"all\",892129742)),options);\n}));\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int unique-name-fn :- fn?]\n *   Return: lib.metadata.calculation/ColumnsWithUniqueAliases\n *        \n * \n *   Convenience for calling [[lib.metadata.calculation/visible-columns]] on all of the joins in a query stage.\n */\nmetabase.lib.join.all_joins_visible_columns = (function metabase$lib$join$all_joins_visible_columns(query,stage_number,unique_name_fn){\n\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentVector.EMPTY,cljs.core.mapcat.cljs$core$IFn$_invoke$arity$1((function (join){\nreturn metabase.lib.metadata.calculation.visible_columns.cljs$core$IFn$_invoke$arity$4(query,stage_number,join,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"unique-name-fn\",\"unique-name-fn\",-755402870),unique_name_fn,new cljs.core.Keyword(null,\"include-implicitly-joinable?\",\"include-implicitly-joinable?\",-772701866),false], null));\n})),new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699).cljs$core$IFn$_invoke$arity$1(metabase.lib.util.query_stage(query,stage_number)));\n});\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int options :- lib.metadata.calculation/ReturnedColumnsOptions]\n *   Return: lib.metadata.calculation/ColumnsWithUniqueAliases\n *        \n * \n *   Convenience for calling [[lib.metadata.calculation/returned-columns-method]] on all the joins in a query stage.\n */\nmetabase.lib.join.all_joins_expected_columns = (function metabase$lib$join$all_joins_expected_columns(query,stage_number,options){\n\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentVector.EMPTY,cljs.core.mapcat.cljs$core$IFn$_invoke$arity$1((function (join){\nreturn metabase.lib.metadata.calculation.returned_columns.cljs$core$IFn$_invoke$arity$4(query,stage_number,join,options);\n})),new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699).cljs$core$IFn$_invoke$arity$1(metabase.lib.util.query_stage(query,stage_number)));\n});\nif((typeof metabase !== 'undefined') && (typeof metabase.lib !== 'undefined') && (typeof metabase.lib.join !== 'undefined') && (typeof metabase.lib.join.join_clause_method !== 'undefined')){\n} else {\n/**\n * Convert something to a join clause.\n */\nmetabase.lib.join.join_clause_method = (function (){var method_table__5642__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar prefer_table__5643__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar method_cache__5644__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar cached_hierarchy__5645__auto__ = cljs.core.atom.cljs$core$IFn$_invoke$arity$1(cljs.core.PersistentArrayMap.EMPTY);\nvar hierarchy__5646__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"hierarchy\",\"hierarchy\",-1053470341),metabase.lib.hierarchy.hierarchy], null),new cljs.core.Keyword(null,\"hierarchy\",\"hierarchy\",-1053470341),(function (){var fexpr__80148 = cljs.core.get_global_hierarchy;\nreturn (fexpr__80148.cljs$core$IFn$_invoke$arity$0 ? fexpr__80148.cljs$core$IFn$_invoke$arity$0() : fexpr__80148.call(null));\n})());\nreturn (new cljs.core.MultiFn(cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(\"metabase.lib.join\",\"join-clause-method\"),metabase.lib.dispatch.dispatch_value,new cljs.core.Keyword(null,\"default\",\"default\",-1987822328),hierarchy__5646__auto__,method_table__5642__auto__,prefer_table__5643__auto__,method_cache__5644__auto__,cached_hierarchy__5645__auto__));\n})();\n}\nmetabase.lib.join.join_clause_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),(function (a_join_clause){\nreturn a_join_clause;\n}));\nmetabase.lib.join.join_clause_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662),(function (another_query){\nreturn metabase.lib.options.ensure_uuid(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532).cljs$core$IFn$_invoke$arity$1(metabase.lib.util.pipeline(another_query))], null));\n}));\nmetabase.lib.join.join_clause_method.cljs$core$IMultiFn$_add_method$arity$3(null,new cljs.core.Keyword(\"mbql.stage\",\"mbql\",\"mbql.stage/mbql\",1578747798),(function (mbql_stage){\nreturn metabase.lib.options.ensure_uuid(new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [mbql_stage], null)], null));\n}));\n/**\n * Add `join-alias` to the RHS of all [[standard-join-condition?]] `conditions` that don't already have a `:join-alias`.\n *   If an RHS already has a `:join-alias`, don't second guess what was already explicitly specified.\n */\nmetabase.lib.join.with_join_conditions_add_alias_to_rhses = (function metabase$lib$join$with_join_conditions_add_alias_to_rhses(conditions,join_alias){\nif(cljs.core.not(join_alias)){\nreturn conditions;\n} else {\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (condition){\nvar or__5045__auto__ = (function (){var temp__5804__auto__ = metabase.lib.join.standard_join_condition_rhs(condition);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar rhs = temp__5804__auto__;\nif(cljs.core.truth_(metabase.lib.join.current_join_alias(rhs))){\nreturn null;\n} else {\nreturn metabase.lib.join.standard_join_condition_update_rhs.cljs$core$IFn$_invoke$arity$variadic(condition,metabase.lib.join.with_join_alias,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([join_alias], 0));\n}\n} else {\nreturn null;\n}\n})();\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn condition;\n}\n}),conditions);\n}\n});\n/**\n * Inputs: [a-join :- PartialJoin conditions :- [:maybe [:sequential [:or :metabase.lib.schema.expression/boolean :metabase.lib.schema.common/external-op]]]]\n *   Return: PartialJoin\n *        \n * \n *   Update the `:conditions` (filters) for a Join clause.\n */\nmetabase.lib.join.with_join_conditions = (function metabase$lib$join$with_join_conditions(a_join,conditions){\n\nvar conditions__$1 = metabase.lib.join.with_join_conditions_add_alias_to_rhses(cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(metabase.lib.common.__GT_op_arg,conditions),metabase.lib.join.current_join_alias(a_join));\nreturn metabase.util.assoc_dissoc(a_join,new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270),cljs.core.not_empty(conditions__$1));\n});\n/**\n * Inputs: ([joinable]\n *         [joinable conditions])\n *   Return: PartialJoin\n *        \n * \n *   Create an MBQL join map from something that can conceptually be joined against. A `Table`? An MBQL or native query? A\n *   Saved Question? You should be able to join anything, and this should return a sensible MBQL join map.\n */\nmetabase.lib.join.join_clause = (function metabase$lib$join$join_clause(var_args){\nvar G__80167 = arguments.length;\nswitch (G__80167) {\ncase 1:\nreturn metabase.lib.join.join_clause.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn metabase.lib.join.join_clause.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.join_clause.cljs$core$IFn$_invoke$arity$1 = (function (joinable){\n\nreturn metabase.util.assoc_default.cljs$core$IFn$_invoke$arity$3(metabase.lib.join.join_clause_method.cljs$core$IFn$_invoke$arity$1(joinable),new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230),new cljs.core.Keyword(null,\"all\",\"all\",892129742));\n}));\n\n(metabase.lib.join.join_clause.cljs$core$IFn$_invoke$arity$2 = (function (joinable,conditions){\n\nreturn metabase.lib.join.with_join_conditions(metabase.lib.join.join_clause.cljs$core$IFn$_invoke$arity$1(joinable),conditions);\n}));\n\n(metabase.lib.join.join_clause.cljs$lang$maxFixedArity = 2);\n\n/**\n * Inputs: [joinable :- PartialJoin fields :- [:maybe [:or [:enum :all :none] [:sequential some?]]]]\n *   Return: PartialJoin\n *        \n * \n *   Update a join (or a function that will return a join) to include `:fields`, either `:all`, `:none`, or a sequence of\n *   references.\n */\nmetabase.lib.join.with_join_fields = (function metabase$lib$join$with_join_fields(joinable,fields){\n\nvar fields__$1 = (((fields instanceof cljs.core.Keyword))?fields:((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fields,cljs.core.PersistentVector.EMPTY))?new cljs.core.Keyword(null,\"none\",\"none\",1333468478):cljs.core.not_empty(cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentVector.EMPTY,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$1(metabase.lib.ref.ref),(function (){var temp__5802__auto__ = metabase.lib.join.current_join_alias(joinable);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar current_alias = temp__5802__auto__;\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$1((function (p1__80169_SHARP_){\nreturn metabase.lib.join.with_join_alias(p1__80169_SHARP_,current_alias);\n}));\n} else {\nreturn cljs.core.identity;\n}\n})()),fields))\n));\nreturn metabase.util.assoc_dissoc(joinable,new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230),fields__$1);\n});\nmetabase.lib.join.select_home_column = (function metabase$lib$join$select_home_column(home_cols,cond_fields){\nvar cond__GT_home = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentArrayMap.EMPTY,cljs.core.keep.cljs$core$IFn$_invoke$arity$1((function (home_col){\nvar temp__5804__auto__ = metabase.lib.equality.find_closest_matching_ref.cljs$core$IFn$_invoke$arity$2(metabase.lib.ref.ref(home_col),cond_fields);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar cond_field = temp__5804__auto__;\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cond_field,home_col], null);\n} else {\nreturn null;\n}\n})),home_cols);\nvar cond_home_cols = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cond__GT_home,cond_fields);\nvar or__5045__auto__ = medley.core.find_first.cljs$core$IFn$_invoke$arity$2(cljs.core.some_fn.cljs$core$IFn$_invoke$arity$2(metabase.lib.types.isa.foreign_key_QMARK_,metabase.lib.types.isa.primary_key_QMARK_),cond_home_cols);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nvar or__5045__auto____$1 = cljs.core.first(cond_home_cols);\nif(cljs.core.truth_(or__5045__auto____$1)){\nreturn or__5045__auto____$1;\n} else {\nvar or__5045__auto____$2 = medley.core.find_first.cljs$core$IFn$_invoke$arity$2(metabase.lib.types.isa.foreign_key_QMARK_,home_cols);\nif(cljs.core.truth_(or__5045__auto____$2)){\nreturn or__5045__auto____$2;\n} else {\nvar or__5045__auto____$3 = medley.core.find_first.cljs$core$IFn$_invoke$arity$2(metabase.lib.types.isa.primary_key_QMARK_,home_cols);\nif(cljs.core.truth_(or__5045__auto____$3)){\nreturn or__5045__auto____$3;\n} else {\nreturn cljs.core.first(home_cols);\n}\n}\n}\n}\n});\nmetabase.lib.join.strip_id = (function metabase$lib$join$strip_id(s){\nif(typeof s === 'string'){\nreturn clojure.string.trim(clojure.string.replace(s,/ id$/i,\"\"));\n} else {\nreturn null;\n}\n});\n/**\n * Checks if `name0` and `name1` are similar.\n *   Two names are considered similar if they are the same, one is the plural of the other,\n *   or their plurals are equal.\n *   This is used to avoid repeating ourselves in situations like when we have a table called\n *   PRODUCTS and a field (presumably referring to that table) called PRODUCT.\n */\nmetabase.lib.join.similar_names_QMARK_ = (function metabase$lib$join$similar_names_QMARK_(name0,name1){\nvar and__5043__auto__ = typeof name0 === 'string';\nif(and__5043__auto__){\nvar and__5043__auto____$1 = typeof name1 === 'string';\nif(and__5043__auto____$1){\nvar plural1 = (new cljs.core.Delay((function (){\nreturn inflections.core.plural(name1);\n}),null));\nvar plural0 = (new cljs.core.Delay((function (){\nreturn inflections.core.plural(name0);\n}),null));\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(name0,name1)) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(name0,cljs.core.deref(plural1))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(plural0),name1)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(plural0),cljs.core.deref(plural1))))))));\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n});\nmetabase.lib.join.calculate_join_alias = (function metabase$lib$join$calculate_join_alias(query,joined,home_col){\nvar joined_name = metabase.lib.metadata.calculation.display_name.cljs$core$IFn$_invoke$arity$2(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801).cljs$core$IFn$_invoke$arity$1(joined),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662)))?joined:query),joined);\nvar home_name = (cljs.core.truth_(home_col)?metabase.lib.join.strip_id(metabase.lib.metadata.calculation.display_name.cljs$core$IFn$_invoke$arity$2(query,home_col)):null);\nvar similar = metabase.lib.join.similar_names_QMARK_(joined_name,home_name);\nvar join_alias = (function (){var or__5045__auto__ = (function (){var and__5043__auto__ = joined_name;\nif(cljs.core.truth_(and__5043__auto__)){\nvar and__5043__auto____$1 = home_name;\nif(cljs.core.truth_(and__5043__auto____$1)){\nvar and__5043__auto____$2 = cljs.core.not(cljs.core.re_matches(/id/i,home_name));\nif(and__5043__auto____$2){\nvar and__5043__auto____$3 = (!(similar));\nif(and__5043__auto____$3){\nreturn [cljs.core.str.cljs$core$IFn$_invoke$arity$1(joined_name),\" - \",home_name].join('');\n} else {\nreturn and__5043__auto____$3;\n}\n} else {\nreturn and__5043__auto____$2;\n}\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n})();\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nvar or__5045__auto____$1 = joined_name;\nif(cljs.core.truth_(or__5045__auto____$1)){\nreturn or__5045__auto____$1;\n} else {\nvar or__5045__auto____$2 = home_name;\nif(cljs.core.truth_(or__5045__auto____$2)){\nreturn or__5045__auto____$2;\n} else {\nreturn \"source\";\n}\n}\n}\n})();\nreturn join_alias;\n});\nmetabase.lib.join.add_alias_to_join_refs = (function metabase$lib$join$add_alias_to_join_refs(metadata_providerable,form,join_alias,join_refs){\nreturn (function metabase$lib$join$add_alias_to_join_refs_$_replace_80177(_AMPERSAND_parents,_AMPERSAND_match){\ntry{if((function (field_clause){\nreturn ((metabase.lib.util.field_clause_QMARK_(field_clause)) && (cljs.core.boolean$(metabase.lib.equality.find_closest_matching_ref.cljs$core$IFn$_invoke$arity$3(metadata_providerable,field_clause,join_refs))));\n})(_AMPERSAND_match)){\nvar field = _AMPERSAND_match;\nreturn metabase.lib.join.with_join_alias(field,join_alias);\n} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80179){if((e80179 instanceof Error)){\nvar e__62528__auto__ = e80179;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nreturn metabase.mbql.util.match.impl.replace_in_collection(metabase$lib$join$add_alias_to_join_refs_$_replace_80177,_AMPERSAND_parents,_AMPERSAND_match);\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80179;\n\n}\n}})(cljs.core.PersistentVector.EMPTY,form);\n});\nmetabase.lib.join.add_alias_to_condition = (function metabase$lib$join$add_alias_to_condition(metadata_providerable,condition,join_alias,home_refs,join_refs){\nvar condition__$1 = metabase.lib.join.add_alias_to_join_refs(metadata_providerable,condition,join_alias,join_refs);\nreturn (function metabase$lib$join$add_alias_to_condition_$_replace_80182(_AMPERSAND_parents,_AMPERSAND_match){\ntry{if(((cljs.core.vector_QMARK_(_AMPERSAND_match)) && ((cljs.core.count(_AMPERSAND_match) === 4)))){\ntry{var _AMPERSAND_match_2__80186 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(2));\nif(metabase.lib.util.field_clause_QMARK_(_AMPERSAND_match_2__80186)){\ntry{var _AMPERSAND_match_3__80187 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(3));\nif(metabase.lib.util.field_clause_QMARK_(_AMPERSAND_match_3__80187)){\nvar rhs = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(3));\nvar lhs = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(2));\nvar op = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(0));\nvar op_opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match,(1));\nvar lhs_aliased = cljs.core.contains_QMARK_(metabase.lib.options.options(lhs),new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794));\nvar rhs_aliased = cljs.core.contains_QMARK_(metabase.lib.options.options(rhs),new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794));\nif((!(((lhs_aliased) || (rhs_aliased))))){\nif(cljs.core.truth_(metabase.lib.equality.find_closest_matching_ref.cljs$core$IFn$_invoke$arity$3(metadata_providerable,rhs,home_refs))){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [op,op_opts,metabase.lib.join.with_join_alias(lhs,join_alias),rhs], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [op,op_opts,lhs,metabase.lib.join.with_join_alias(rhs,join_alias)], null);\n}\n} else {\nif(((lhs_aliased) && (rhs_aliased))){\nvar bare_lhs = metabase.lib.options.update_options.cljs$core$IFn$_invoke$arity$variadic(lhs,cljs.core.dissoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794)], 0));\nvar bare_rhs = metabase.lib.options.update_options.cljs$core$IFn$_invoke$arity$variadic(rhs,cljs.core.dissoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"join-alias\",\"join-alias\",1454206794)], 0));\nif(cljs.core.truth_((function (){var and__5043__auto__ = (metabase.lib.equality.find_closest_matching_ref.cljs$core$IFn$_invoke$arity$3(metadata_providerable,bare_lhs,home_refs) == null);\nif(and__5043__auto__){\nreturn metabase.lib.equality.find_closest_matching_ref.cljs$core$IFn$_invoke$arity$3(metadata_providerable,bare_rhs,home_refs);\n} else {\nreturn and__5043__auto__;\n}\n})())){\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [op,op_opts,lhs,bare_rhs], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [op,op_opts,bare_lhs,rhs], null);\n}\n} else {\nreturn _AMPERSAND_match;\n\n}\n}\n} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80190){if((e80190 instanceof Error)){\nvar e__62528__auto__ = e80190;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80190;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80189){if((e80189 instanceof Error)){\nvar e__62528__auto__ = e80189;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80189;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80188){if((e80188 instanceof Error)){\nvar e__62528__auto__ = e80188;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nreturn metabase.mbql.util.match.impl.replace_in_collection(metabase$lib$join$add_alias_to_condition_$_replace_80182,_AMPERSAND_parents,_AMPERSAND_match);\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80188;\n\n}\n}})(cljs.core.PersistentVector.EMPTY,condition__$1);\n});\nmetabase.lib.join.generate_unique_name = (function metabase$lib$join$generate_unique_name(base_name,taken_names){\nvar generator = metabase.lib.util.unique_name_generator();\ncljs.core.run_BANG_(generator,taken_names);\n\nreturn generator(base_name);\n});\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int a-join :- JoinWithOptionalAlias]\n *   Return: :metabase.lib.schema.join/join\n *        \n * \n *   Add a default generated `:alias` to a join clause that does not already have one.\n */\nmetabase.lib.join.add_default_alias = (function metabase$lib$join$add_default_alias(query,stage_number,a_join){\n\nif(cljs.core.contains_QMARK_(a_join,new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630))){\nreturn a_join;\n} else {\nvar stage = metabase.lib.util.query_stage(query,stage_number);\nvar home_cols = metabase.lib.metadata.calculation.visible_columns.cljs$core$IFn$_invoke$arity$3(query,stage_number,stage);\nvar cond_fields = cljs.core.seq(cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.some_QMARK_,(function metabase$lib$join$add_default_alias_$_match_80195(_AMPERSAND_parents,_AMPERSAND_match){\ntry{if(((cljs.core.vector_QMARK_(_AMPERSAND_match)) && ((cljs.core.count(_AMPERSAND_match) >= (1))))){\ntry{var _AMPERSAND_match_left__80198 = cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(_AMPERSAND_match,(0),(1));\nif(((cljs.core.vector_QMARK_(_AMPERSAND_match_left__80198)) && ((cljs.core.count(_AMPERSAND_match_left__80198) === (1))))){\ntry{var _AMPERSAND_match_left__80198_0__80200 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(_AMPERSAND_match_left__80198,(0));\nif(cljs.core.keyword_identical_QMARK_(_AMPERSAND_match_left__80198_0__80200,new cljs.core.Keyword(null,\"field\",\"field\",-1302436500))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [_AMPERSAND_match], null);\n} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80203){if((e80203 instanceof Error)){\nvar e__62528__auto__ = e80203;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80203;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80202){if((e80202 instanceof Error)){\nvar e__62528__auto__ = e80202;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nthrow cljs.core.match.backtrack;\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80202;\n\n}\n}} else {\nthrow cljs.core.match.backtrack;\n\n}\n}catch (e80201){if((e80201 instanceof Error)){\nvar e__62528__auto__ = e80201;\nif((e__62528__auto__ === cljs.core.match.backtrack)){\nreturn metabase.mbql.util.match.impl.match_in_collection(metabase$lib$join$add_default_alias_$_match_80195,_AMPERSAND_parents,_AMPERSAND_match);\n} else {\nthrow e__62528__auto__;\n}\n} else {\nthrow e80201;\n\n}\n}})(cljs.core.PersistentVector.EMPTY,new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270).cljs$core$IFn$_invoke$arity$1(a_join))));\nvar home_col = metabase.lib.join.select_home_column(home_cols,cond_fields);\nvar join_alias = metabase.lib.join.generate_unique_name(metabase.lib.join.calculate_join_alias(query,a_join,home_col),cljs.core.keep.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630),new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699).cljs$core$IFn$_invoke$arity$1(stage)));\nvar home_refs = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(metabase.lib.ref.ref,home_cols);\nvar join_refs = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(metabase.lib.ref.ref,metabase.lib.metadata.calculation.returned_columns.cljs$core$IFn$_invoke$arity$1(metabase.lib.query.query_with_stages.cljs$core$IFn$_invoke$arity$2(query,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532).cljs$core$IFn$_invoke$arity$1(a_join))));\nreturn metabase.lib.join.with_join_alias(cljs.core.update.cljs$core$IFn$_invoke$arity$3(a_join,new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270),(function (conditions){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__80193_SHARP_){\nreturn metabase.lib.join.add_alias_to_condition(query,p1__80193_SHARP_,join_alias,home_refs,join_refs);\n}),conditions);\n})),join_alias);\n}\n});\n/**\n * Inputs: ([query a-join]\n *         [query :- :metabase.lib.schema/query stage-number :- :int a-join :- PartialJoin])\n *   Return: :metabase.lib.schema/query\n *        \n * \n *   Add a join clause to a `query`.\n */\nmetabase.lib.join.join = (function metabase$lib$join$join(var_args){\nvar G__80206 = arguments.length;\nswitch (G__80206) {\ncase 2:\nreturn metabase.lib.join.join.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn metabase.lib.join.join.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.join.cljs$core$IFn$_invoke$arity$2 = (function (query,a_join){\n\nreturn metabase.lib.join.join.cljs$core$IFn$_invoke$arity$3(query,(-1),a_join);\n}));\n\n(metabase.lib.join.join.cljs$core$IFn$_invoke$arity$3 = (function (query,stage_number,a_join){\n\nvar a_join__$1 = metabase.lib.join.add_default_alias(query,stage_number,a_join);\nreturn metabase.lib.util.update_query_stage.cljs$core$IFn$_invoke$arity$variadic(query,stage_number,cljs.core.update,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),(function (joins){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(joins),a_join__$1);\n})], 0));\n}));\n\n(metabase.lib.join.join.cljs$lang$maxFixedArity = 3);\n\n/**\n * Inputs: ([query]\n *         [query :- :metabase.lib.schema/query stage-number :- :int])\n *   Return: [:maybe :metabase.lib.schema.join/joins]\n *        \n * \n *   Get all joins in a specific `stage` of a `query`. If `stage` is unspecified, returns joins in the final stage of the\n *   query.\n */\nmetabase.lib.join.joins = (function metabase$lib$join$joins(var_args){\nvar G__80209 = arguments.length;\nswitch (G__80209) {\ncase 1:\nreturn metabase.lib.join.joins.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn metabase.lib.join.joins.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.joins.cljs$core$IFn$_invoke$arity$1 = (function (query){\n\nreturn metabase.lib.join.joins.cljs$core$IFn$_invoke$arity$2(query,(-1));\n}));\n\n(metabase.lib.join.joins.cljs$core$IFn$_invoke$arity$2 = (function (query,stage_number){\n\nreturn cljs.core.not_empty(cljs.core.get.cljs$core$IFn$_invoke$arity$2(metabase.lib.util.query_stage(query,stage_number),new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699)));\n}));\n\n(metabase.lib.join.joins.cljs$lang$maxFixedArity = 2);\n\n/**\n * Inputs: [table-name :- :metabase.lib.schema.common/non-blank-string source-field-id-name :- :metabase.lib.schema.common/non-blank-string]\n *   Return: :metabase.lib.schema.common/non-blank-string\n *        \n * \n *   Name for an implicit join against `table-name` via an FK field, e.g.\n * \n *  CATEGORIES__via__CATEGORY_ID\n * \n *   You should make sure this gets ran thru a unique-name fn.\n */\nmetabase.lib.join.implicit_join_name = (function metabase$lib$join$implicit_join_name(table_name,source_field_id_name){\n\nreturn (metabase.lib.util.format.cljs$core$IFn$_invoke$arity$3 ? metabase.lib.util.format.cljs$core$IFn$_invoke$arity$3(\"%s__via__%s\",table_name,source_field_id_name) : metabase.lib.util.format.call(null,\"%s__via__%s\",table_name,source_field_id_name));\n});\n/**\n * Inputs: [a-join :- PartialJoin]\n *   Return: [:maybe :metabase.lib.schema.join/conditions]\n *        \n * \n *   Get all join conditions for the given join\n */\nmetabase.lib.join.join_conditions = (function metabase$lib$join$join_conditions(a_join){\n\nreturn new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270).cljs$core$IFn$_invoke$arity$1(a_join);\n});\n/**\n * Inputs: [a-join :- PartialJoin]\n *   Return: [:maybe :metabase.lib.schema.join/fields]\n *        \n * \n *   Get all join conditions for the given join\n */\nmetabase.lib.join.join_fields = (function metabase$lib$join$join_fields(a_join){\n\nreturn new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230).cljs$core$IFn$_invoke$arity$1(a_join);\n});\nmetabase.lib.join.raw_join_strategy__GT_strategy_option = (function metabase$lib$join$raw_join_strategy__GT_strategy_option(raw_strategy){\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"option\",\"join.strategy\",\"option/join.strategy\",1337097154),new cljs.core.Keyword(null,\"strategy\",\"strategy\",-1471631918),raw_strategy], null),((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(raw_strategy,new cljs.core.Keyword(null,\"left-join\",\"left-join\",-672831855)))?new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"default\",\"default\",-1987822328),true], null):null)], 0));\n});\n/**\n * Inputs: [a-join :- PartialJoin]\n *   Return: :metabase.lib.schema.join/strategy\n *        \n * \n *   Get the raw keyword strategy (type) of a given join, e.g. `:left-join` or `:right-join`. This is either the value\n *   of the optional `:strategy` key or the default, `:left-join`, if `:strategy` is not specified.\n */\nmetabase.lib.join.raw_join_strategy = (function metabase$lib$join$raw_join_strategy(a_join){\n\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(a_join,new cljs.core.Keyword(null,\"strategy\",\"strategy\",-1471631918),new cljs.core.Keyword(null,\"left-join\",\"left-join\",-672831855));\n});\n/**\n * Inputs: [a-join :- PartialJoin]\n *   Return: :metabase.lib.schema.join/strategy.option\n *        \n * \n *   Get the strategy (type) of a given join, as a `:option/join.strategy` map. If `:stategy` is unspecified, returns\n *   the default, left join.\n */\nmetabase.lib.join.join_strategy = (function metabase$lib$join$join_strategy(a_join){\n\nreturn metabase.lib.join.raw_join_strategy__GT_strategy_option(metabase.lib.join.raw_join_strategy(a_join));\n});\n/**\n * Inputs: [a-join :- PartialJoin strategy :- [:or :metabase.lib.schema.join/strategy :metabase.lib.schema.join/strategy.option]]\n *   Return: PartialJoin\n *        \n * \n *   Return a copy of `a-join` with its `:strategy` set to `strategy`.\n */\nmetabase.lib.join.with_join_strategy = (function metabase$lib$join$with_join_strategy(a_join,strategy){\n\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(a_join,new cljs.core.Keyword(null,\"strategy\",\"strategy\",-1471631918),(function (){var G__80218 = strategy;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(metabase.lib.dispatch.dispatch_value(strategy),new cljs.core.Keyword(\"option\",\"join.strategy\",\"option/join.strategy\",1337097154))){\nreturn new cljs.core.Keyword(null,\"strategy\",\"strategy\",-1471631918).cljs$core$IFn$_invoke$arity$1(G__80218);\n} else {\nreturn G__80218;\n}\n})());\n});\n/**\n * Inputs: ([query]\n *         [query :- :metabase.lib.schema/query _stage-number :- :int])\n *   Return: [:sequential :metabase.lib.schema.join/strategy.option]\n *        \n * \n *   Get available join strategies for the current Database (based on the Database's\n *   supported [[metabase.driver/driver-features]]) as raw keywords like `:left-join`.\n */\nmetabase.lib.join.available_join_strategies = (function metabase$lib$join$available_join_strategies(var_args){\nvar G__80221 = arguments.length;\nswitch (G__80221) {\ncase 1:\nreturn metabase.lib.join.available_join_strategies.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn metabase.lib.join.available_join_strategies.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.available_join_strategies.cljs$core$IFn$_invoke$arity$1 = (function (query){\n\nreturn metabase.lib.join.available_join_strategies.cljs$core$IFn$_invoke$arity$2(query,(-1));\n}));\n\n(metabase.lib.join.available_join_strategies.cljs$core$IFn$_invoke$arity$2 = (function (query,_stage_number){\n\nvar database = metabase.lib.metadata.database(query);\nvar features = new cljs.core.Keyword(null,\"features\",\"features\",-1146962336).cljs$core$IFn$_invoke$arity$1(database);\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentVector.EMPTY,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.filter.cljs$core$IFn$_invoke$arity$1(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.core.contains_QMARK_,features)),cljs.core.map.cljs$core$IFn$_invoke$arity$1(metabase.lib.join.raw_join_strategy__GT_strategy_option)),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"left-join\",\"left-join\",-672831855),new cljs.core.Keyword(null,\"right-join\",\"right-join\",-56349359),new cljs.core.Keyword(null,\"inner-join\",\"inner-join\",659431740),new cljs.core.Keyword(null,\"full-join\",\"full-join\",1305476385)], null));\n}));\n\n(metabase.lib.join.available_join_strategies.cljs$lang$maxFixedArity = 2);\n\n/**\n * Inputs: [columns :- [:sequential lib.metadata/ColumnMetadata]]\n *   Return: [:sequential lib.metadata/ColumnMetadata]\n *        \n * \n *   Sort potential join condition columns as returned by [[join-condition-lhs-columns]]\n *   or [[join-condition-rhs-columns]]. PK columns are returned first, followed by FK columns, followed by other columns.\n *   Otherwise original order is maintained.\n */\nmetabase.lib.join.sort_join_condition_columns = (function metabase$lib$join$sort_join_condition_columns(columns){\n\nvar map__80223 = cljs.core.group_by((function (column){\nif(metabase.lib.types.isa.primary_key_QMARK_(column)){\nreturn new cljs.core.Keyword(null,\"pk\",\"pk\",-771936732);\n} else {\nif(metabase.lib.types.isa.foreign_key_QMARK_(column)){\nreturn new cljs.core.Keyword(null,\"fk\",\"fk\",398442651);\n} else {\nreturn new cljs.core.Keyword(null,\"other\",\"other\",995793544);\n\n}\n}\n}),columns);\nvar map__80223__$1 = cljs.core.__destructure_map(map__80223);\nvar pk = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80223__$1,new cljs.core.Keyword(null,\"pk\",\"pk\",-771936732));\nvar fk = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80223__$1,new cljs.core.Keyword(null,\"fk\",\"fk\",398442651));\nvar other = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80223__$1,new cljs.core.Keyword(null,\"other\",\"other\",995793544));\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic(pk,fk,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([other], 0));\n});\n/**\n * Inputs: ([query existing-join-or-nil rhs-column-or-nil]\n *         [query :- :metabase.lib.schema/query stage-number :- :int existing-join-or-nil :- [:maybe :metabase.lib.schema.join/join] _rhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n *   Return: [:sequential lib.metadata/ColumnMetadata]\n *        \n * \n *   Get a sequence of columns that can be used as the left-hand-side (source column) in a join condition. This column\n *   is the one that comes from the source Table/Card/previous stage of the query or a previous join.\n * \n *   If you are changing the LHS of a condition for an existing join, pass in that existing join as\n *   `existing-join-or-nil` so we can filter out the columns added by it (it doesn't make sense to present the columns\n *   added by a join as options for its own LHS) or added by later joins (joins can only depend on things from previous\n *   joins). Otherwise pass `nil` when building a new join. See #32005 for more info.\n * \n *   If the right-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n *   pass in the chosen RHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n * \n *   Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns.\n * \n *   Unlike most other things that return columns, implicitly-joinable columns ARE NOT returned here.\n */\nmetabase.lib.join.join_condition_lhs_columns = (function metabase$lib$join$join_condition_lhs_columns(var_args){\nvar G__80227 = arguments.length;\nswitch (G__80227) {\ncase 3:\nreturn metabase.lib.join.join_condition_lhs_columns.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn metabase.lib.join.join_condition_lhs_columns.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.join_condition_lhs_columns.cljs$core$IFn$_invoke$arity$3 = (function (query,existing_join_or_nil,rhs_column_or_nil){\n\nreturn metabase.lib.join.join_condition_lhs_columns.cljs$core$IFn$_invoke$arity$4(query,(-1),existing_join_or_nil,rhs_column_or_nil);\n}));\n\n(metabase.lib.join.join_condition_lhs_columns.cljs$core$IFn$_invoke$arity$4 = (function (query,stage_number,existing_join_or_nil,_rhs_column_or_nil){\n\nvar existing_join_alias = metabase.lib.join.current_join_alias(existing_join_or_nil);\nvar join_aliases_to_ignore = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentHashSet.EMPTY,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.map.cljs$core$IFn$_invoke$arity$1(metabase.lib.join.current_join_alias),cljs.core.drop_while.cljs$core$IFn$_invoke$arity$1((function (p1__80224_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__80224_SHARP_,existing_join_alias);\n}))),metabase.lib.join.joins.cljs$core$IFn$_invoke$arity$2(query,stage_number));\nreturn metabase.lib.join.sort_join_condition_columns(cljs.core.remove.cljs$core$IFn$_invoke$arity$2((function (col){\nvar temp__5804__auto__ = metabase.lib.join.current_join_alias(col);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar col_join_alias = temp__5804__auto__;\nreturn cljs.core.contains_QMARK_(join_aliases_to_ignore,col_join_alias);\n} else {\nreturn null;\n}\n}),metabase.lib.metadata.calculation.visible_columns.cljs$core$IFn$_invoke$arity$4(query,stage_number,metabase.lib.util.query_stage(query,stage_number),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"include-implicitly-joinable?\",\"include-implicitly-joinable?\",-772701866),false], null))));\n}));\n\n(metabase.lib.join.join_condition_lhs_columns.cljs$lang$maxFixedArity = 4);\n\n/**\n * Inputs: ([query joinable lhs-column-or-nil]\n *         [query :- :metabase.lib.schema/query stage-number :- :int joinable _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n *   Return: [:sequential lib.metadata/ColumnMetadata]\n *        \n * \n *   Get a sequence of columns that can be used as the right-hand-side (target column) in a join condition. This column\n *   is the one that belongs to the thing being joined, `joinable`, which can be something like a\n *   Table ([[metabase.lib.metadata/TableMetadata]]), Saved Question/Model ([[metabase.lib.metadata/CardMetadata]]),\n *   another query, etc. -- anything you can pass to [[join-clause]].\n * \n *   If the lhs-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n *   pass in the chosen LHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n * \n *   Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns.\n */\nmetabase.lib.join.join_condition_rhs_columns = (function metabase$lib$join$join_condition_rhs_columns(var_args){\nvar G__80230 = arguments.length;\nswitch (G__80230) {\ncase 3:\nreturn metabase.lib.join.join_condition_rhs_columns.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn metabase.lib.join.join_condition_rhs_columns.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.join_condition_rhs_columns.cljs$core$IFn$_invoke$arity$3 = (function (query,joinable,lhs_column_or_nil){\n\nreturn metabase.lib.join.join_condition_rhs_columns.cljs$core$IFn$_invoke$arity$4(query,(-1),joinable,lhs_column_or_nil);\n}));\n\n(metabase.lib.join.join_condition_rhs_columns.cljs$core$IFn$_invoke$arity$4 = (function (query,stage_number,joinable,_lhs_column_or_nil){\n\nreturn metabase.lib.join.sort_join_condition_columns(metabase.lib.metadata.calculation.visible_columns.cljs$core$IFn$_invoke$arity$4(query,stage_number,joinable,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"include-implicitly-joinable?\",\"include-implicitly-joinable?\",-772701866),false], null)));\n}));\n\n(metabase.lib.join.join_condition_rhs_columns.cljs$lang$maxFixedArity = 4);\n\n/**\n * Inputs: ([query lhs-column-or-nil rhs-column-or-nil]\n *         [_query :- :metabase.lib.schema/query _stage-number :- :int _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata] _rhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n *   Return: [:sequential :metabase.lib.schema.filter/operator]\n *        \n * \n *   Return a sequence of valid filter clause operators that can be used to build a join condition. In the Query Builder\n *   UI, this can be chosen at any point before or after choosing the LHS and RHS. Invalid options are not currently\n *   filtered out based on values of the LHS or RHS, but in the future we can add this -- see #31174.\n */\nmetabase.lib.join.join_condition_operators = (function metabase$lib$join$join_condition_operators(var_args){\nvar G__80233 = arguments.length;\nswitch (G__80233) {\ncase 3:\nreturn metabase.lib.join.join_condition_operators.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 4:\nreturn metabase.lib.join.join_condition_operators.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.join_condition_operators.cljs$core$IFn$_invoke$arity$3 = (function (query,lhs_column_or_nil,rhs_column_or_nil){\n\nreturn metabase.lib.join.join_condition_operators.cljs$core$IFn$_invoke$arity$4(query,(-1),lhs_column_or_nil,rhs_column_or_nil);\n}));\n\n(metabase.lib.join.join_condition_operators.cljs$core$IFn$_invoke$arity$4 = (function (_query,_stage_number,_lhs_column_or_nil,_rhs_column_or_nil){\n\nreturn metabase.lib.filter.operator.join_operators;\n}));\n\n(metabase.lib.join.join_condition_operators.cljs$lang$maxFixedArity = 4);\n\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int x]\n *   Return: [:maybe lib.metadata/ColumnMetadata]\n *        \n * \n *   Given something `x` (e.g. a Table metadata) find the PK column.\n */\nmetabase.lib.join.pk_column = (function metabase$lib$join$pk_column(query,stage_number,x){\n\nreturn medley.core.find_first.cljs$core$IFn$_invoke$arity$2(metabase.lib.types.isa.primary_key_QMARK_,metabase.lib.metadata.calculation.visible_columns.cljs$core$IFn$_invoke$arity$3(query,stage_number,x));\n});\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int pk-col :- [:maybe lib.metadata/ColumnMetadata]]\n *   Return: [:maybe lib.metadata/ColumnMetadata]\n *        \n * \n *   Given a query stage find an FK column that points to the PK `pk-col`.\n */\nmetabase.lib.join.fk_column_for = (function metabase$lib$join$fk_column_for(query,stage_number,pk_col){\n\nvar temp__5804__auto__ = new cljs.core.Keyword(null,\"id\",\"id\",-1388402092).cljs$core$IFn$_invoke$arity$1(pk_col);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar pk_id = temp__5804__auto__;\nreturn medley.core.find_first.cljs$core$IFn$_invoke$arity$2((function (p__80236){\nvar map__80237 = p__80236;\nvar map__80237__$1 = cljs.core.__destructure_map(map__80237);\nvar col = map__80237__$1;\nvar fk_target_field_id = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__80237__$1,new cljs.core.Keyword(null,\"fk-target-field-id\",\"fk-target-field-id\",2019750287));\nreturn ((metabase.lib.types.isa.foreign_key_QMARK_(col)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fk_target_field_id,pk_id)));\n}),metabase.lib.metadata.calculation.visible_columns.cljs$core$IFn$_invoke$arity$3(query,stage_number,metabase.lib.util.query_stage(query,stage_number)));\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: ([query joinable]\n *         [query :- :metabase.lib.schema/query stage-number :- :int joinable])\n *   Return: [:maybe :metabase.lib.schema.expression/boolean]\n *        \n * \n *   Return a suggested default join condition when constructing a join against `joinable`, e.g. a Table, Saved\n *   Question, or another query. A suggested condition will be returned if the query stage has a foreign key to the\n *   primary key of the thing we're joining (see #31175 for more info); otherwise this will return `nil` if no default\n *   condition is suggested.\n */\nmetabase.lib.join.suggested_join_condition = (function metabase$lib$join$suggested_join_condition(var_args){\nvar G__80240 = arguments.length;\nswitch (G__80240) {\ncase 2:\nreturn metabase.lib.join.suggested_join_condition.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn metabase.lib.join.suggested_join_condition.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.suggested_join_condition.cljs$core$IFn$_invoke$arity$2 = (function (query,joinable){\n\nreturn metabase.lib.join.suggested_join_condition.cljs$core$IFn$_invoke$arity$3(query,(-1),joinable);\n}));\n\n(metabase.lib.join.suggested_join_condition.cljs$core$IFn$_invoke$arity$3 = (function (query,stage_number,joinable){\n\nvar temp__5804__auto__ = metabase.lib.join.pk_column(query,stage_number,joinable);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar pk_col = temp__5804__auto__;\nvar temp__5804__auto____$1 = metabase.lib.join.fk_column_for(query,stage_number,pk_col);\nif(cljs.core.truth_(temp__5804__auto____$1)){\nvar fk_col = temp__5804__auto____$1;\nreturn metabase.lib.filter.filter_clause.cljs$core$IFn$_invoke$arity$variadic(metabase.lib.filter.operator.operator_def.cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"=\",\"=\",1152933628)),fk_col,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([pk_col], 0));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n}));\n\n(metabase.lib.join.suggested_join_condition.cljs$lang$maxFixedArity = 3);\n\nmetabase.lib.join.Joinable = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"or\",\"or\",235744169),metabase.lib.metadata.TableMetadata,metabase.lib.metadata.CardMetadata], null);\n/**\n * Inputs: [metadata-providerable :- lib.metadata/MetadataProviderable a-join :- :metabase.lib.schema.join/join]\n *   Return: [:maybe Joinable]\n *        \n * \n *   Return metadata about the origin of `a-join` using `metadata-providerable` as the source of information.\n */\nmetabase.lib.join.joined_thing = (function metabase$lib$join$joined_thing(metadata_providerable,a_join){\n\nvar origin = cljs.core.first(new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532).cljs$core$IFn$_invoke$arity$1(a_join));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"source-card\",\"source-card\",-1580820390).cljs$core$IFn$_invoke$arity$1(origin))){\nreturn metabase.lib.metadata.card(metadata_providerable,new cljs.core.Keyword(null,\"source-card\",\"source-card\",-1580820390).cljs$core$IFn$_invoke$arity$1(origin));\n} else {\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692).cljs$core$IFn$_invoke$arity$1(origin))){\nreturn metabase.lib.metadata.table(metadata_providerable,new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692).cljs$core$IFn$_invoke$arity$1(origin));\n} else {\nreturn null;\n}\n}\n});\nmetabase.lib.join.add_join_alias_to_joinable_columns = (function metabase$lib$join$add_join_alias_to_joinable_columns(cols,a_join){\nvar join_alias = metabase.lib.join.current_join_alias(a_join);\nvar unique_name_fn = metabase.lib.util.unique_name_generator();\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (col){\nvar col__$1 = col;\nvar col__$2 = metabase.lib.join.with_join_alias(col__$1,join_alias);\nreturn metabase.lib.join.add_source_and_desired_aliases(a_join,unique_name_fn,col__$2);\n}),cols);\n});\n/**\n * Mark the column metadatas in `cols` as `:selected` if they appear in `a-join`'s `:fields`.\n */\nmetabase.lib.join.mark_selected_joinable_columns = (function metabase$lib$join$mark_selected_joinable_columns(cols,a_join){\nvar j_fields = metabase.lib.join.join_fields(a_join);\nvar G__80245 = j_fields;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"all\",\"all\",892129742),G__80245)){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__80242_SHARP_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(p1__80242_SHARP_,new cljs.core.Keyword(null,\"selected?\",\"selected?\",-742502788),true);\n}),cols);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"none\",\"none\",1333468478),G__80245)){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__80243_SHARP_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(p1__80243_SHARP_,new cljs.core.Keyword(null,\"selected?\",\"selected?\",-742502788),false);\n}),cols);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(null,G__80245)){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__80243_SHARP_){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(p1__80243_SHARP_,new cljs.core.Keyword(null,\"selected?\",\"selected?\",-742502788),false);\n}),cols);\n} else {\nvar selected_fields_refs = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(metabase.lib.ref.ref,j_fields);\nvar cols__$1 = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (col){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(col,new cljs.core.Keyword(\"metabase.lib.join\",\"ref\",\"metabase.lib.join/ref\",950805898),metabase.lib.ref.ref(col));\n}),cols);\nvar all_source_refs = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"metabase.lib.join\",\"ref\",\"metabase.lib.join/ref\",950805898),cols__$1);\nvar selected_source_refs = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentHashSet.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$1((function (p1__80244_SHARP_){\nreturn metabase.lib.equality.find_closest_matching_ref.cljs$core$IFn$_invoke$arity$2(p1__80244_SHARP_,all_source_refs);\n})),selected_fields_refs);\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (col){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(col,new cljs.core.Keyword(null,\"selected?\",\"selected?\",-742502788),cljs.core.contains_QMARK_(selected_source_refs,new cljs.core.Keyword(\"metabase.lib.join\",\"ref\",\"metabase.lib.join/ref\",950805898).cljs$core$IFn$_invoke$arity$1(col))),new cljs.core.Keyword(\"metabase.lib.join\",\"ref\",\"metabase.lib.join/ref\",950805898));\n}),cols__$1);\n\n}\n}\n}\n});\nmetabase.lib.join.JoinOrJoinable = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"or\",\"or\",235744169),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"ref\",\"ref\",1289896967),new cljs.core.Keyword(\"metabase.lib.schema.join\",\"join\",\"metabase.lib.schema.join/join\",1110197236)], null),metabase.lib.join.Joinable], null);\nmetabase.lib.join.join_QMARK_ = (function metabase$lib$join$join_QMARK_(x){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(metabase.lib.dispatch.dispatch_value(x),new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370));\n});\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int join-or-joinable :- JoinOrJoinable]\n *   Return: [:sequential lib.metadata/ColumnMetadata]\n *        \n * \n *   Return information about the fields that you can pass to [[with-join-fields]] when constructing a join against\n *   something [[Joinable]] (i.e., a Table or Card) or manipulating an existing join. When passing in a join, currently\n *   selected columns (those in the join's `:fields`) will include `:selected true` information.\n */\nmetabase.lib.join.joinable_columns = (function metabase$lib$join$joinable_columns(query,stage_number,join_or_joinable){\n\nvar a_join = ((metabase.lib.join.join_QMARK_(join_or_joinable))?join_or_joinable:null);\nvar source = (cljs.core.truth_(a_join)?metabase.lib.join.joined_thing(query,join_or_joinable):join_or_joinable);\nvar cols = metabase.lib.metadata.calculation.returned_columns.cljs$core$IFn$_invoke$arity$3(query,stage_number,source);\nvar G__80247 = cols;\nvar G__80247__$1 = (cljs.core.truth_(a_join)?metabase.lib.join.add_join_alias_to_joinable_columns(G__80247,a_join):G__80247);\nif(cljs.core.truth_(a_join)){\nreturn metabase.lib.join.mark_selected_joinable_columns(G__80247__$1,a_join);\n} else {\nreturn G__80247__$1;\n}\n});\n/**\n * Whether a `join-or-joinable` is (or will be) the first join in a stage of a query.\n * \n *   If a join is passed, we need to check whether it's the first join in the first stage of a source-table query or\n *   not.\n * \n *   New joins get appended after any existing ones, so it would be safe to assume that if there are any other joins in\n *   the current stage, this **will not** be the first join in the stage.\n */\nmetabase.lib.join.first_join_QMARK_ = (function metabase$lib$join$first_join_QMARK_(query,stage_number,join_or_joinable){\nvar existing_joins = metabase.lib.join.joins.cljs$core$IFn$_invoke$arity$2(query,stage_number);\nvar or__5045__auto__ = cljs.core.empty_QMARK_(existing_joins);\nif(or__5045__auto__){\nreturn or__5045__auto__;\n} else {\nif(metabase.lib.join.join_QMARK_(join_or_joinable)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630).cljs$core$IFn$_invoke$arity$1(join_or_joinable),new cljs.core.Keyword(null,\"alias\",\"alias\",-2039751630).cljs$core$IFn$_invoke$arity$1(cljs.core.first(existing_joins)));\n} else {\nreturn null;\n}\n}\n});\n/**\n * Inputs: ([query join-or-joinable]\n *         [query :- :metabase.lib.schema/query stage-number :- :int join-or-joinable :- [:maybe JoinOrJoinable]])\n *   Return: :metabase.lib.schema.common/non-blank-string\n *        \n * \n *   Get the display name for whatever we are joining. See #32015 for screenshot examples.\n * \n *   The rules, copied from MLv1, are as follows:\n * \n *   1. If this is the first join in the first stage of a query, and the query uses a `:source-table`, then use the\n *   display name for the source Table.\n * \n *   2. Otherwise use `Previous results`.\n * \n *   These rules do seem a little goofy -- why don't we use the name of a Saved Question or Model? But we can worry about\n *   that in the future. For now, let's just replicate MLv1 behavior.\n * \n *   This function needs to be usable while we are in the process of constructing a join in the context of a given stage,\n *   but also needs to work for rendering existing joins. Pass a join in for existing joins, or something [[Joinable]]\n *   for ones we are currently building.\n */\nmetabase.lib.join.join_lhs_display_name = (function metabase$lib$join$join_lhs_display_name(var_args){\nvar G__80250 = arguments.length;\nswitch (G__80250) {\ncase 2:\nreturn metabase.lib.join.join_lhs_display_name.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn metabase.lib.join.join_lhs_display_name.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.join.join_lhs_display_name.cljs$core$IFn$_invoke$arity$2 = (function (query,join_or_joinable){\n\nreturn metabase.lib.join.join_lhs_display_name.cljs$core$IFn$_invoke$arity$3(query,(-1),join_or_joinable);\n}));\n\n(metabase.lib.join.join_lhs_display_name.cljs$core$IFn$_invoke$arity$3 = (function (query,stage_number,join_or_joinable){\n\nif(cljs.core.truth_((function (){var and__5043__auto__ = (metabase.lib.util.canonical_stage_index(query,stage_number) === (0));\nif(and__5043__auto__){\nvar and__5043__auto____$1 = metabase.lib.join.first_join_QMARK_(query,stage_number,join_or_joinable);\nif(cljs.core.truth_(and__5043__auto____$1)){\nreturn metabase.lib.util.source_table_id(query);\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n})())){\nvar table_id = metabase.lib.util.source_table_id(query);\nvar table = metabase.lib.metadata.table(query,table_id);\nreturn metabase.lib.metadata.calculation.display_name.cljs$core$IFn$_invoke$arity$3(query,stage_number,table);\n} else {\nreturn metabase.shared.util.i18n.js_i18n(\"Previous results\");\n}\n}));\n\n(metabase.lib.join.join_lhs_display_name.cljs$lang$maxFixedArity = 3);\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","Functions related to manipulating EXPLICIT joins in MBQL.","~:file","metabase/lib/join.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",22],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.core","~$cljs.core","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.core.match","~$cljs.core.match"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$metabase.lib.join","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$metabase.lib.schema","^S","~$mu","~$metabase.util.malli","~$metabase.lib.metadata.calculation","^V","~$metabase.lib.equality","^W","~$metabase.lib.metadata","^X","~$lib.equality","^W","~$i18n","~$metabase.shared.util.i18n","~$lib.schema.join","~$metabase.lib.schema.join","~$lib.schema.common","~$metabase.lib.schema.common","~$metabase.mbql.util.match","^14","~$lib.filter.operator","~$metabase.lib.filter.operator","~$u","~$metabase.util","~$lib.schema.expression","~$metabase.lib.schema.expression","~$lib.metadata","^X","~$lib.common","~$metabase.lib.common","^D","^D","~$metabase.lib.ref","^1=","~$metabase.lib.util","^1>","~$goog","^1?","~$lib.query","~$metabase.lib.query","~$lib.schema","^S","^13","^13","^16","^16","~$lib.options","~$metabase.lib.options","^19","^19","~$lib.hierarchy","~$metabase.lib.hierarchy","~$m","~$medley.core","^17","^17","~$lib.ref","^1=","~$lib.filter","~$metabase.lib.filter","^1<","^1<","^[","^[","~$lib.util","^1>","~$lib.dispatch","~$metabase.lib.dispatch","~$metabase.lib.types.isa","^1N","^1A","^1A","^U","^U","~$lib.schema.filter","~$metabase.lib.schema.filter","~$inflections.core","^1Q","~$lib.metadata.calculation","^V","~$lib.types.isa","^1N","~$str","~$clojure.string","^1F","^1F","^1D","^1D","^1U","^1U","^11","^11","~$mbql.u.match","^14","^1M","^1M","^1P","^1P","^1J","^1J","^1G","^1G","~$inflections","^1Q"],"~:seen",["^K",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^T","^U","^Z","^[","^14","^14","~$u","^17","^18","^19","^1;","^1<","^D","^D","^19","^19","^17","^17","^1I","^1J","^1<","^1<","^[","^[","^U","^U","^1V","^14","^1J","^1J"],"~:form",["~#list",["~$ns","^M","Functions related to manipulating EXPLICIT joins in MBQL.",["^21",["^1Y",["^1U","~:as","^1T"],["^1Q","^23","^1W"],["^1G","^23","~$m"],["^1<","^23","^1;"],["^1M","^23","^1L"],["^W","^23","^Y"],["^1J","^23","^1I"],["^16","^23","^15"],["^1F","^23","^1E"],["^X","^23","^1:"],["^V","^23","^1R"],["^1D","^23","^1C"],["^1A","^23","^1@"],["^1=","^23","^1H"],["^S","^23","^1B"],["^13","^23","^12"],["^19","^23","^18"],["^1P","^23","^1O"],["^11","^23","^10"],["^1N","^23","^1S"],["^1>","^23","^1K"],["^14","^23","^1V"],["^[","^23","^Z"],["^17","^23","~$u"],["^U","^23","^T"]]]]],"~:flags",["^ ","^1Y",["^K",[]]],"~:js-deps",["^ "],"~:deps",["^1?","^D","^1U","^1Q","^1G","^1<","^1M","^W","^1J","^16","^1F","^X","^V","^1D","^1A","^1=","^S","^13","^19","^1P","^11","^1N","^1>","^14","^[","^17","^U"]],"^P","^M","~:resource-id",["~:shadow.build.classpath/resource","metabase/lib/join.cljc"],"~:compiled-at",1692014630525,"^N",["^ ","^S","^S","^T","^U","^V","^V","^W","^W","^X","^X","^Y","^W","^Z","^[","^10","^11","^12","^13","^14","^14","^15","^16","~$u","^17","^18","^19","^1:","^X","^1;","^1<","^D","^D","^1=","^1=","^1>","^1>","^1?","^1?","^1@","^1A","^1B","^S","^13","^13","^16","^16","^1C","^1D","^19","^19","^1E","^1F","~$m","^1G","^17","^17","^1H","^1=","^1I","^1J","^1<","^1<","^[","^[","^1K","^1>","^1L","^1M","^1N","^1N","^1A","^1A","^U","^U","^1O","^1P","^1Q","^1Q","^1R","^V","^1S","^1N","^1T","^1U","^1F","^1F","^1D","^1D","^1U","^1U","^11","^11","^1V","^14","^1M","^1M","^1P","^1P","^1J","^1J","^1G","^1G","^1W","^1Q"],"~:resource-name","metabase/lib/join.cljc","~:warnings",[],"~:source","(ns metabase.lib.join\n  \"Functions related to manipulating EXPLICIT joins in MBQL.\"\n  (:require\n   [clojure.string :as str]\n   [inflections.core :as inflections]\n   [medley.core :as m]\n   [metabase.lib.common :as lib.common]\n   [metabase.lib.dispatch :as lib.dispatch]\n   [metabase.lib.equality :as lib.equality]\n   [metabase.lib.filter :as lib.filter]\n   [metabase.lib.filter.operator :as lib.filter.operator]\n   [metabase.lib.hierarchy :as lib.hierarchy]\n   [metabase.lib.metadata :as lib.metadata]\n   [metabase.lib.metadata.calculation :as lib.metadata.calculation]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.query :as lib.query]\n   [metabase.lib.ref :as lib.ref]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.expression :as lib.schema.expression]\n   [metabase.lib.schema.filter :as lib.schema.filter]\n   [metabase.lib.schema.join :as lib.schema.join]\n   [metabase.lib.types.isa :as lib.types.isa]\n   [metabase.lib.util :as lib.util]\n   [metabase.mbql.util.match :as mbql.u.match]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util :as u]\n   [metabase.util.malli :as mu]))\n\n(def ^:private JoinWithOptionalAlias\n  \"A Join that may not yet have an `:alias`, which is normally required; [[join]] accepts this and will add a default\n  alias if one is not present.\"\n  [:merge\n   [:ref ::lib.schema.join/join]\n   [:map\n    [:alias {:optional true} [:ref ::lib.schema.join/alias]]]])\n\n(def ^:private PartialJoin\n  \"A join that may not yet have an `:alias` or `:conditions`.\"\n  [:merge\n   JoinWithOptionalAlias\n   [:map\n    [:conditions {:optional true} [:ref ::lib.schema.join/conditions]]]])\n\n(def ^:private FieldOrPartialJoin\n  [:or\n   lib.metadata/ColumnMetadata\n   [:ref :mbql.clause/field]\n   PartialJoin])\n\n(mu/defn current-join-alias :- [:maybe ::lib.schema.common/non-blank-string]\n  \"Get the current join alias associated with something, if it has one.\"\n  [field-or-join :- [:maybe FieldOrPartialJoin]]\n  (case (lib.dispatch/dispatch-value field-or-join)\n    :dispatch-type/nil nil\n    :field             (:join-alias (lib.options/options field-or-join))\n    :metadata/column   (::join-alias field-or-join)\n    :mbql/join         (:alias field-or-join)))\n\n(declare with-join-alias)\n\n(defn- with-join-alias-update-join-fields\n  \"Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for the `:field` refs inside `:fields`\n  as needed.\"\n  [join new-alias]\n  (cond-> join\n    (:fields join) (update :fields (fn [fields]\n                                     (if-not (sequential? fields)\n                                       fields\n                                       (mapv (fn [field-ref]\n                                               (with-join-alias field-ref new-alias))\n                                             fields))))))\n\n(mu/defn ^:private standard-join-condition? :- :boolean\n  \"Whether this join condition is a binary condition with two `:field` references (a LHS and a RHS), as you'd produce\n  in the frontend using functions like [[join-condition-operators]], [[join-condition-lhs-columns]],\n  and [[join-condition-rhs-columns]].\"\n  [condition  :- ::lib.schema.expression/boolean]\n  (mbql.u.match/match-one condition\n    [(_operator :guard keyword?)\n     _opts\n     [:field _lhs-opts _lhs-id-or-name]\n     [:field _rhs-opts _rhs-id-or-name]]\n    true\n    _\n    false))\n\n(defn- standard-join-condition-rhs\n  \"If `condition` is a [[standard-join-condition?]], return the RHS.\"\n  [condition]\n  (when (standard-join-condition? condition)\n    (let [[_operator _opts _lhs rhs] condition]\n      rhs)))\n\n(defn- standard-join-condition-update-rhs\n  \"If `condition` is a [[standard-join-condition?]], update the RHS with `f` like\n\n    (apply f rhs args)\"\n  [condition f & args]\n  (if-not (standard-join-condition? condition)\n    condition\n    (let [[operator opts lhs rhs] condition]\n      [operator opts lhs (apply f rhs args)])))\n\n(mu/defn ^:private with-join-alias-update-join-conditions :- PartialJoin\n  \"Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for inside the `:conditions` of the\n  join.\n\n  If `old-alias` is specified, uses [[metabase.mbql.util.match]] to update all the `:field` references using the old\n  alias.\n\n  If `old-alias` is `nil`, updates the RHS of all 'standard' conditions (binary filter clauses with two `:field` refs as\n  args, e.g. the kind you'd get if you were using [[join-condition-operators]] and the like to create them). This\n  currently doesn't handle more complex filter clauses that were created without the 'normal' MLv2 functions used by\n  the frontend; we can add this in the future if we need it.\"\n  [join      :- PartialJoin\n   old-alias :- [:maybe ::lib.schema.common/non-blank-string]\n   new-alias :- [:maybe ::lib.schema.common/non-blank-string]]\n  (cond\n    (empty? (:conditions join))\n    join\n\n    ;; if we've specified `old-alias`, then update ANY `:field` clause using it to `new-alias` instead.\n    old-alias\n    (mbql.u.match/replace-in join [:conditions]\n      [:field {:join-alias old-alias} _id-or-name]\n      (with-join-alias &match new-alias))\n\n    ;; otherwise if `old-alias` is `nil`, then add (or remove!) `new-alias` to the RHS of any binary\n    ;; filter clauses that don't already have a `:join-alias`.\n    :else\n    (update join :conditions (fn [conditions]\n                               (mapv (fn [condition]\n                                       (standard-join-condition-update-rhs condition with-join-alias new-alias))\n                                     conditions)))))\n\n(defn- with-join-alias-update-join\n  \"Impl for [[with-join-alias]] for a join.\"\n  [join new-alias]\n  (let [old-alias (current-join-alias join)]\n    (-> join\n        (u/assoc-dissoc :alias new-alias)\n        (with-join-alias-update-join-fields new-alias)\n        (with-join-alias-update-join-conditions old-alias new-alias))))\n\n(mu/defn with-join-alias :- FieldOrPartialJoin\n  \"Add OR REMOVE a specific `join-alias` to `field-or-join`, which is either a `:field`/Field metadata, or a join map.\n  Does not recursively update other references (yet; we can add this in the future).\"\n  {:style/indent [:form]}\n  [field-or-join :- FieldOrPartialJoin\n   join-alias    :- [:maybe ::lib.schema.common/non-blank-string]]\n  (case (lib.dispatch/dispatch-value field-or-join)\n    :field\n    (lib.options/update-options field-or-join u/assoc-dissoc :join-alias join-alias)\n\n    :metadata/column\n    (u/assoc-dissoc field-or-join ::join-alias join-alias)\n\n    :mbql/join\n    (with-join-alias-update-join field-or-join join-alias)))\n\n(mu/defn resolve-join :- ::lib.schema.join/join\n  \"Resolve a join with a specific `join-alias`.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   join-alias   :- ::lib.schema.common/non-blank-string]\n  (let [{:keys [joins]} (lib.util/query-stage query stage-number)]\n    (or (m/find-first #(= (:alias %) join-alias)\n                      joins)\n        (throw (ex-info (i18n/tru \"No join named {0}, found: {1}\"\n                                  (pr-str join-alias)\n                                  (pr-str (mapv :alias joins)))\n                        {:join-alias   join-alias\n                         :query        query\n                         :stage-number stage-number})))))\n\n(defmethod lib.metadata.calculation/display-name-method :mbql/join\n  [query _stage-number {[{:keys [source-table source-card], :as _first-stage}] :stages, :as _join} _style]\n  (or\n   (when source-table\n     (:display-name (lib.metadata/table query source-table)))\n   (when source-card\n     (i18n/tru \"Question {0}\" source-card))\n   (i18n/tru \"Native Query\")))\n\n(defmethod lib.metadata.calculation/display-info-method :mbql/join\n  [query stage-number join]\n  (let [display-name (lib.metadata.calculation/display-name query stage-number join)]\n    {:name (or (:alias join) display-name), :display-name display-name}))\n\n(defmethod lib.metadata.calculation/metadata-method :mbql/join\n  [_query _stage-number _query]\n  ;; not i18n'ed because this shouldn't be developer-facing.\n  (throw (ex-info \"You can't calculate a metadata map for a join! Use lib.metadata.calculation/returned-columns-method instead.\"\n                  {})))\n\n(mu/defn ^:private column-from-join-fields :- lib.metadata.calculation/ColumnMetadataWithSource\n  \"For a column that comes from a join `:fields` list, add or update metadata as needed, e.g. include join name in the\n  display name.\"\n  [query           :- ::lib.schema/query\n   stage-number    :- :int\n   column-metadata :- lib.metadata/ColumnMetadata\n   join-alias      :- ::lib.schema.common/non-blank-string]\n  (let [column-metadata (assoc column-metadata :source-alias join-alias)\n        col             (-> (assoc column-metadata\n                                   :display-name (lib.metadata.calculation/display-name query stage-number column-metadata)\n                                   :lib/source   :source/joins)\n                            (with-join-alias join-alias))]\n    (assert (= (current-join-alias col) join-alias))\n    col))\n\n(defmethod lib.metadata.calculation/display-name-method :option/join.strategy\n  [_query _stage-number {:keys [strategy]} _style]\n  (case strategy\n    :left-join  (i18n/tru \"Left outer join\")\n    :right-join (i18n/tru \"Right outer join\")\n    :inner-join (i18n/tru \"Inner join\")\n    :full-join  (i18n/tru \"Full outer join\")))\n\n(defmethod lib.metadata.calculation/display-info-method :option/join.strategy\n  [query stage-number {:keys [strategy default], :as option}]\n  (cond-> {:short-name   (u/qualified-name strategy)\n           :display-name (lib.metadata.calculation/display-name query stage-number option)}\n    default (assoc :default true)))\n\n(mu/defn joined-field-desired-alias :- ::lib.schema.common/non-blank-string\n  \"Desired alias for a Field that comes from a join, e.g.\n\n    MyJoin__my_field\n\n  You should pass the results thru a unique name function.\"\n  [join-alias :- ::lib.schema.common/non-blank-string\n   field-name :- ::lib.schema.common/non-blank-string]\n  (lib.util/format \"%s__%s\" join-alias field-name))\n\n(mu/defn ^:private add-source-and-desired-aliases :- :map\n  [join           :- [:map\n                      [:alias\n                       {:error/message \"Join must have an alias to determine column aliases!\"}\n                       ::lib.schema.common/non-blank-string]]\n   unique-name-fn :- fn?\n   col            :- :map]\n  (assoc col\n         :lib/source-column-alias  ((some-fn :lib/source-column-alias :name) col)\n         :lib/desired-column-alias (unique-name-fn (joined-field-desired-alias\n                                                    (:alias join)\n                                                    ((some-fn :lib/source-column-alias :name) col)))))\n\n(defmethod lib.metadata.calculation/returned-columns-method :mbql/join\n  [query\n   stage-number\n   {:keys [fields stages], join-alias :alias, :or {fields :none}, :as join}\n   {:keys [unique-name-fn], :as options}]\n  (when-not (= fields :none)\n    (let [ensure-previous-stages-have-metadata (resolve 'metabase.lib.stage/ensure-previous-stages-have-metadata)\n          join-query (cond-> (assoc query :stages stages)\n                       ensure-previous-stages-have-metadata\n                       (ensure-previous-stages-have-metadata -1))\n          field-metadatas (if (= fields :all)\n                            (lib.metadata.calculation/returned-columns join-query -1 (peek stages) options)\n                            (for [field-ref fields\n                                  :let [join-field (lib.options/update-options field-ref dissoc :join-alias)]]\n                              (lib.metadata.calculation/metadata join-query -1 join-field)))]\n      (mapv (fn [field-metadata]\n              (->> (column-from-join-fields query stage-number field-metadata join-alias)\n                   (add-source-and-desired-aliases join unique-name-fn)))\n            field-metadatas))))\n\n(defmethod lib.metadata.calculation/visible-columns-method :mbql/join\n  [query stage-number join options]\n  (lib.metadata.calculation/returned-columns query stage-number (assoc join :fields :all) options))\n\n(mu/defn all-joins-visible-columns :- lib.metadata.calculation/ColumnsWithUniqueAliases\n  \"Convenience for calling [[lib.metadata.calculation/visible-columns]] on all of the joins in a query stage.\"\n  [query          :- ::lib.schema/query\n   stage-number   :- :int\n   unique-name-fn :- fn?]\n  (into []\n        (mapcat (fn [join]\n                  (lib.metadata.calculation/visible-columns query\n                                                            stage-number\n                                                            join\n                                                            {:unique-name-fn               unique-name-fn\n                                                             :include-implicitly-joinable? false})))\n        (:joins (lib.util/query-stage query stage-number))))\n\n(mu/defn all-joins-expected-columns :- lib.metadata.calculation/ColumnsWithUniqueAliases\n  \"Convenience for calling [[lib.metadata.calculation/returned-columns-method]] on all the joins in a query stage.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   options      :- lib.metadata.calculation/ReturnedColumnsOptions]\n  (into []\n        (mapcat (fn [join]\n                  (lib.metadata.calculation/returned-columns query stage-number join options)))\n        (:joins (lib.util/query-stage query stage-number))))\n\n(defmulti join-clause-method\n  \"Convert something to a join clause.\"\n  {:arglists '([joinable])}\n  lib.dispatch/dispatch-value\n  :hierarchy lib.hierarchy/hierarchy)\n\n;; TODO -- should the default implementation call [[metabase.lib.query/query]]? That way if we implement a method to\n;; create an MBQL query from a `Table`, then we'd also get [[join]] support for free?\n\n(defmethod join-clause-method :mbql/join\n  [a-join-clause]\n  a-join-clause)\n\n;;; TODO -- this probably ought to live in [[metabase.lib.query]]\n(defmethod join-clause-method :mbql/query\n  [another-query]\n  (-> {:lib/type :mbql/join\n       :stages   (:stages (lib.util/pipeline another-query))}\n      lib.options/ensure-uuid))\n\n;;; TODO -- this probably ought to live in [[metabase.lib.stage]]\n(defmethod join-clause-method :mbql.stage/mbql\n  [mbql-stage]\n  (-> {:lib/type :mbql/join\n       :stages   [mbql-stage]}\n      lib.options/ensure-uuid))\n\n(defn- with-join-conditions-add-alias-to-rhses\n  \"Add `join-alias` to the RHS of all [[standard-join-condition?]] `conditions` that don't already have a `:join-alias`.\n  If an RHS already has a `:join-alias`, don't second guess what was already explicitly specified.\"\n  [conditions join-alias]\n  (if-not join-alias\n    conditions\n    (mapv (fn [condition]\n            (or (when-let [rhs (standard-join-condition-rhs condition)]\n                  (when-not (current-join-alias rhs)\n                    (standard-join-condition-update-rhs condition with-join-alias join-alias)))\n                condition))\n          conditions)))\n\n(mu/defn with-join-conditions :- PartialJoin\n  \"Update the `:conditions` (filters) for a Join clause.\"\n  {:style/indent [:form]}\n  [a-join     :- PartialJoin\n   conditions :- [:maybe [:sequential [:or ::lib.schema.expression/boolean ::lib.schema.common/external-op]]]]\n  (let [conditions (-> (mapv lib.common/->op-arg conditions)\n                       (with-join-conditions-add-alias-to-rhses (current-join-alias a-join)))]\n    (u/assoc-dissoc a-join :conditions (not-empty conditions))))\n\n(mu/defn join-clause :- PartialJoin\n  \"Create an MBQL join map from something that can conceptually be joined against. A `Table`? An MBQL or native query? A\n  Saved Question? You should be able to join anything, and this should return a sensible MBQL join map.\"\n  ([joinable]\n   (-> (join-clause-method joinable)\n       (u/assoc-default :fields :all)))\n\n  ([joinable conditions]\n   (-> (join-clause joinable)\n       (with-join-conditions conditions))))\n\n(mu/defn with-join-fields :- PartialJoin\n  \"Update a join (or a function that will return a join) to include `:fields`, either `:all`, `:none`, or a sequence of\n  references.\"\n  [joinable :- PartialJoin\n   fields   :- [:maybe [:or [:enum :all :none] [:sequential some?]]]]\n  (let [fields (cond\n                 (keyword? fields) fields\n                 (= fields [])     :none\n                 :else             (not-empty\n                                    (into []\n                                          (comp (map lib.ref/ref)\n                                                (if-let [current-alias (current-join-alias joinable)]\n                                                  (map #(with-join-alias % current-alias))\n                                                  identity))\n                                          fields)))]\n    (u/assoc-dissoc joinable :fields fields)))\n\n(defn- select-home-column\n  [home-cols cond-fields]\n  (let [cond->home (into {}\n                         (keep  (fn [home-col]\n                                  (when-let [cond-field (lib.equality/find-closest-matching-ref\n                                                         (lib.ref/ref home-col)\n                                                         cond-fields)]\n                                    [cond-field home-col])))\n                         home-cols)\n        cond-home-cols (map cond->home cond-fields)]\n    ;; first choice: the leftmost FK or PK in the condition referring to a home column\n    (or (m/find-first (some-fn lib.types.isa/foreign-key? lib.types.isa/primary-key?) cond-home-cols)\n        ;; otherwise the leftmost home column in the condition\n        (first cond-home-cols)\n        ;; otherwise the first FK home column\n        (m/find-first lib.types.isa/foreign-key? home-cols)\n        ;; otherwise the first PK home column\n        (m/find-first lib.types.isa/primary-key? home-cols)\n        ;; otherwise the first home column\n        (first home-cols))))\n\n(defn- strip-id [s]\n  (when (string? s)\n    (str/trim (str/replace s #\"(?i) id$\" \"\"))))\n\n(defn- similar-names?\n  \"Checks if `name0` and `name1` are similar.\n  Two names are considered similar if they are the same, one is the plural of the other,\n  or their plurals are equal.\n  This is used to avoid repeating ourselves in situations like when we have a table called\n  PRODUCTS and a field (presumably referring to that table) called PRODUCT.\"\n  [name0 name1]\n  (and (string? name0) (string? name1)\n       (let [plural1 (delay (inflections/plural name1))\n             plural0 (delay (inflections/plural name0))]\n         (or (= name0 name1)\n             (= name0 @plural1)\n             (= @plural0 name1)\n             (= @plural0 @plural1)))))\n\n(defn- calculate-join-alias [query joined home-col]\n  (let [joined-name (lib.metadata.calculation/display-name\n                     (if (= (:lib/type joined) :mbql/query) joined query)\n                     joined)\n        home-name   (when home-col (strip-id (lib.metadata.calculation/display-name query home-col)))\n        similar     (similar-names? joined-name home-name)\n        join-alias  (or (and joined-name\n                             home-name\n                             (not (re-matches #\"(?i)id\" home-name))\n                             (not similar)\n                             (str joined-name \" - \" home-name))\n                        joined-name\n                        home-name\n                        \"source\")]\n    join-alias))\n\n(defn- add-alias-to-join-refs [metadata-providerable form join-alias join-refs]\n  (mbql.u.match/replace form\n    (field :guard (fn [field-clause]\n                    (and (lib.util/field-clause? field-clause)\n                         (boolean (lib.equality/find-closest-matching-ref\n                                   metadata-providerable field-clause join-refs)))))\n    (with-join-alias field join-alias)))\n\n(defn- add-alias-to-condition\n  [metadata-providerable condition join-alias home-refs join-refs]\n  (let [condition (add-alias-to-join-refs metadata-providerable condition join-alias join-refs)]\n    ;; Sometimes conditions have field references which cannot be unambigously\n    ;; assigned to one of the sides. The following code tries to deal with\n    ;; these cases, but only for conditions that look like the ones generated\n    ;; generated by the FE. These have the form home-field op join-field,\n    ;; so we break ties by looking at the poisition of the field reference.\n    (mbql.u.match/replace condition\n      [op op-opts (lhs :guard lib.util/field-clause?) (rhs :guard lib.util/field-clause?)]\n      (let [lhs-aliased (contains? (lib.options/options lhs) :join-alias)\n            rhs-aliased (contains? (lib.options/options rhs) :join-alias)]\n        (cond\n          ;; no sides obviously belong to joined\n          (not (or lhs-aliased rhs-aliased))\n          (if (lib.equality/find-closest-matching-ref metadata-providerable rhs home-refs)\n            [op op-opts (with-join-alias lhs join-alias) rhs]\n            [op op-opts lhs (with-join-alias rhs join-alias)])\n\n          ;; both sides seem to belong to joined assuming this resulted from\n          ;; overly fuzzy matching, we remove the join alias from the LHS\n          ;; unless the RHS seems to belong to home too while the LHS doen't\n          (and lhs-aliased rhs-aliased)\n          (let [bare-lhs (lib.options/update-options lhs dissoc :join-alias)\n                bare-rhs (lib.options/update-options rhs dissoc :join-alias)]\n            (if (and (nil? (lib.equality/find-closest-matching-ref metadata-providerable bare-lhs home-refs))\n                     (lib.equality/find-closest-matching-ref metadata-providerable bare-rhs home-refs))\n              [op op-opts lhs bare-rhs]\n              [op op-opts bare-lhs rhs]))\n\n          ;; we leave alone the condition otherwise\n          :else &match)))))\n\n(defn- generate-unique-name [base-name taken-names]\n  (let [generator (lib.util/unique-name-generator)]\n    (run! generator taken-names)\n    (generator base-name)))\n\n(mu/defn add-default-alias :- ::lib.schema.join/join\n  \"Add a default generated `:alias` to a join clause that does not already have one.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   a-join       :- JoinWithOptionalAlias]\n  (if (contains? a-join :alias)\n    ;; if the join clause comes with an alias, keep it and assume that the\n    ;; condition fields have the right join-aliases too\n    a-join\n    (let [stage       (lib.util/query-stage query stage-number)\n          home-cols   (lib.metadata.calculation/visible-columns query stage-number stage)\n          cond-fields (mbql.u.match/match (:conditions a-join) :field)\n          home-col    (select-home-column home-cols cond-fields)\n          join-alias  (-> (calculate-join-alias query a-join home-col)\n                          (generate-unique-name (keep :alias (:joins stage))))\n          home-refs   (mapv lib.ref/ref home-cols)\n          join-refs   (mapv lib.ref/ref\n                            (lib.metadata.calculation/returned-columns\n                              (lib.query/query-with-stages query (:stages a-join))))]\n      (-> a-join\n          (update :conditions\n                  (fn [conditions]\n                    (mapv #(add-alias-to-condition query % join-alias home-refs join-refs)\n                          conditions)))\n          (with-join-alias join-alias)))))\n\n(mu/defn join :- ::lib.schema/query\n  \"Add a join clause to a `query`.\"\n  ([query a-join]\n   (join query -1 a-join))\n\n  ([query        :- ::lib.schema/query\n    stage-number :- :int\n    a-join       :- PartialJoin]\n   (let [a-join (add-default-alias query stage-number a-join)]\n     (lib.util/update-query-stage query stage-number update :joins (fn [joins]\n                                                                     (conj (vec joins) a-join))))))\n\n(mu/defn joins :- [:maybe ::lib.schema.join/joins]\n  \"Get all joins in a specific `stage` of a `query`. If `stage` is unspecified, returns joins in the final stage of the\n  query.\"\n  ([query]\n   (joins query -1))\n  ([query        :- ::lib.schema/query\n    stage-number :- :int]\n   (not-empty (get (lib.util/query-stage query stage-number) :joins))))\n\n(mu/defn implicit-join-name :- ::lib.schema.common/non-blank-string\n  \"Name for an implicit join against `table-name` via an FK field, e.g.\n\n    CATEGORIES__via__CATEGORY_ID\n\n  You should make sure this gets ran thru a unique-name fn.\"\n  [table-name           :- ::lib.schema.common/non-blank-string\n   source-field-id-name :- ::lib.schema.common/non-blank-string]\n  (lib.util/format \"%s__via__%s\" table-name source-field-id-name))\n\n(mu/defn join-conditions :- [:maybe ::lib.schema.join/conditions]\n  \"Get all join conditions for the given join\"\n  [a-join :- PartialJoin]\n  (:conditions a-join))\n\n(mu/defn join-fields :- [:maybe ::lib.schema.join/fields]\n  \"Get all join conditions for the given join\"\n  [a-join :- PartialJoin]\n  (:fields a-join))\n\n(defn- raw-join-strategy->strategy-option [raw-strategy]\n  (merge\n   {:lib/type :option/join.strategy\n    :strategy raw-strategy}\n   (when (= raw-strategy :left-join)\n     {:default true})))\n\n(mu/defn raw-join-strategy :- ::lib.schema.join/strategy\n  \"Get the raw keyword strategy (type) of a given join, e.g. `:left-join` or `:right-join`. This is either the value\n  of the optional `:strategy` key or the default, `:left-join`, if `:strategy` is not specified.\"\n  [a-join :- PartialJoin]\n  (get a-join :strategy :left-join))\n\n(mu/defn join-strategy :- ::lib.schema.join/strategy.option\n  \"Get the strategy (type) of a given join, as a `:option/join.strategy` map. If `:stategy` is unspecified, returns\n  the default, left join.\"\n  [a-join :- PartialJoin]\n  (raw-join-strategy->strategy-option (raw-join-strategy a-join)))\n\n(mu/defn with-join-strategy :- PartialJoin\n  \"Return a copy of `a-join` with its `:strategy` set to `strategy`.\"\n  [a-join   :- PartialJoin\n   strategy :- [:or ::lib.schema.join/strategy ::lib.schema.join/strategy.option]]\n  ;; unwrap the strategy to a raw keyword if needed.\n  (assoc a-join :strategy (cond-> strategy\n                            (= (lib.dispatch/dispatch-value strategy) :option/join.strategy)\n                            :strategy)))\n\n(mu/defn available-join-strategies :- [:sequential ::lib.schema.join/strategy.option]\n  \"Get available join strategies for the current Database (based on the Database's\n  supported [[metabase.driver/driver-features]]) as raw keywords like `:left-join`.\"\n  ([query]\n   (available-join-strategies query -1))\n\n  ;; stage number is not currently used, but it is taken as a parameter for consistency with the rest of MLv2\n  ([query         :- ::lib.schema/query\n    _stage-number :- :int]\n   (let [database (lib.metadata/database query)\n         features (:features database)]\n     (into []\n           (comp (filter (partial contains? features))\n                 (map raw-join-strategy->strategy-option))\n           [:left-join :right-join :inner-join :full-join]))))\n\n;;; Building join conditions:\n;;;\n;;; The QB GUI needs to build a join condition before the join itself is attached to the query. There are three parts\n;;; to a join condition. Suppose we're building a query like\n;;;\n;;;    SELECT * FROM order JOIN user ON order.user_id = user.id\n;;;\n;;; The condition is\n;;;\n;;;    order.user_id  =  user.id\n;;;    ^^^^^^^^^^^^^  ^  ^^^^^^^\n;;;          1        2     3\n;;;\n;;; and the three parts are:\n;;;\n;;; 1. LHS/source column: the column in the left-hand side of the condition, e.g. the `order.user_id` in the example\n;;;    above. Either comes from the source Table, or a previous stage of the query, or a previously-joined\n;;;    Table/Model/Saved Question. `order.user_id` presumably is an FK to `user.id`, and while this is typical, is not\n;;;    required.\n;;;\n;;; 2. The operator: `=` in the example above. Corresponds to an `:=` MBQL clause. `=` is selected by default.\n;;;\n;;; 3. RHS/destination/target column: the column in the right-hand side of the condition e.g. `user.id` in the example\n;;;    above. `user.id` is a column in the Table/Model/Saved Question we are joining against.\n;;;\n;;; The Query Builder allows selecting any of these three parts in any order. The functions below return possible\n;;; options for each respective part. At the time of this writing, selecting one does not filter out incompatible\n;;; options for the other parts, but hopefully we can implement this in the future -- see #31174\n\n(mu/defn ^:private sort-join-condition-columns :- [:sequential lib.metadata/ColumnMetadata]\n  \"Sort potential join condition columns as returned by [[join-condition-lhs-columns]]\n  or [[join-condition-rhs-columns]]. PK columns are returned first, followed by FK columns, followed by other columns.\n  Otherwise original order is maintained.\"\n  [columns :- [:sequential lib.metadata/ColumnMetadata]]\n  (let [{:keys [pk fk other]} (group-by (fn [column]\n                                          (cond\n                                            (lib.types.isa/primary-key? column) :pk\n                                            (lib.types.isa/foreign-key? column) :fk\n                                            :else                               :other))\n                                        columns)]\n    (concat pk fk other)))\n\n(mu/defn join-condition-lhs-columns :- [:sequential lib.metadata/ColumnMetadata]\n  \"Get a sequence of columns that can be used as the left-hand-side (source column) in a join condition. This column\n  is the one that comes from the source Table/Card/previous stage of the query or a previous join.\n\n  If you are changing the LHS of a condition for an existing join, pass in that existing join as\n  `existing-join-or-nil` so we can filter out the columns added by it (it doesn't make sense to present the columns\n  added by a join as options for its own LHS) or added by later joins (joins can only depend on things from previous\n  joins). Otherwise pass `nil` when building a new join. See #32005 for more info.\n\n  If the right-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n  pass in the chosen RHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n\n  Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns.\n\n  Unlike most other things that return columns, implicitly-joinable columns ARE NOT returned here.\"\n  ([query existing-join-or-nil rhs-column-or-nil]\n   (join-condition-lhs-columns query -1 existing-join-or-nil rhs-column-or-nil))\n\n  ([query                :- ::lib.schema/query\n    stage-number         :- :int\n    existing-join-or-nil :- [:maybe ::lib.schema.join/join]\n    ;; not yet used, hopefully we will use in the future when present for filtering incompatible columns out.\n    _rhs-column-or-nil   :- [:maybe lib.metadata/ColumnMetadata]]\n   ;; calculate all the visible columns including the existing join; then filter out any columns that come from the\n   ;; existing join and any subsequent joins. The reason for doing things this way rather than removing the joins\n   ;; before calculating visible columns is that we don't want to either create possibly-invalid queries, or have to\n   ;; rely on the logic in [[metabase.lib.remove-replace/remove-join]] which would cause circular references; this is\n   ;; simpler as well.\n   ;;\n   ;; e.g. if we have joins [J1 J2 J3 J4] and current join = J2, then we want to ignore the visible columns from J2,\n   ;; J3, and J4.\n   (let [existing-join-alias    (current-join-alias existing-join-or-nil)\n         join-aliases-to-ignore (into #{}\n                                      (comp (map current-join-alias)\n                                            (drop-while #(not= % existing-join-alias)))\n                                      (joins query stage-number))]\n     (->> (lib.metadata.calculation/visible-columns query stage-number\n                                                    (lib.util/query-stage query stage-number)\n                                                    {:include-implicitly-joinable? false})\n          (remove (fn [col]\n                    (when-let [col-join-alias (current-join-alias col)]\n                      (contains? join-aliases-to-ignore col-join-alias))))\n          sort-join-condition-columns))))\n\n(mu/defn join-condition-rhs-columns :- [:sequential lib.metadata/ColumnMetadata]\n  \"Get a sequence of columns that can be used as the right-hand-side (target column) in a join condition. This column\n  is the one that belongs to the thing being joined, `joinable`, which can be something like a\n  Table ([[metabase.lib.metadata/TableMetadata]]), Saved Question/Model ([[metabase.lib.metadata/CardMetadata]]),\n  another query, etc. -- anything you can pass to [[join-clause]].\n\n  If the lhs-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n  pass in the chosen LHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n\n  Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns.\"\n  ([query joinable lhs-column-or-nil]\n   (join-condition-rhs-columns query -1 joinable lhs-column-or-nil))\n\n  ([query              :- ::lib.schema/query\n    stage-number       :- :int\n    joinable\n    ;; not yet used, hopefully we will use in the future when present for filtering incompatible columns out.\n    _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]]\n   ;; I was on the fence about whether these should get `:lib/source :source/joins` or not -- it seems like based on\n   ;; the QB UI they shouldn't. See screenshots in #31174\n   (sort-join-condition-columns\n    (lib.metadata.calculation/visible-columns query stage-number joinable {:include-implicitly-joinable? false}))))\n\n(mu/defn join-condition-operators :- [:sequential ::lib.schema.filter/operator]\n  \"Return a sequence of valid filter clause operators that can be used to build a join condition. In the Query Builder\n  UI, this can be chosen at any point before or after choosing the LHS and RHS. Invalid options are not currently\n  filtered out based on values of the LHS or RHS, but in the future we can add this -- see #31174.\"\n  ([query lhs-column-or-nil rhs-column-or-nil]\n   (join-condition-operators query -1 lhs-column-or-nil rhs-column-or-nil))\n\n  ([_query             :- ::lib.schema/query\n    _stage-number      :- :int\n    ;; not yet used, hopefully we will use in the future when present for filtering incompatible options out.\n    _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]\n    _rhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]]\n   ;; currently hardcoded to these six operators regardless of LHS and RHS.\n   lib.filter.operator/join-operators))\n\n(mu/defn ^:private pk-column :- [:maybe lib.metadata/ColumnMetadata]\n  \"Given something `x` (e.g. a Table metadata) find the PK column.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   x]\n  (m/find-first lib.types.isa/primary-key?\n                (lib.metadata.calculation/visible-columns query stage-number x)))\n\n(mu/defn ^:private fk-column-for :- [:maybe lib.metadata/ColumnMetadata]\n  \"Given a query stage find an FK column that points to the PK `pk-col`.\"\n  [query        :- ::lib.schema/query\n   stage-number :- :int\n   pk-col       :- [:maybe lib.metadata/ColumnMetadata]]\n  (when-let [pk-id (:id pk-col)]\n    (m/find-first (fn [{:keys [fk-target-field-id], :as col}]\n                    (and (lib.types.isa/foreign-key? col)\n                         (= fk-target-field-id pk-id)))\n                  (lib.metadata.calculation/visible-columns query stage-number (lib.util/query-stage query stage-number)))))\n\n(mu/defn suggested-join-condition :- [:maybe ::lib.schema.expression/boolean] ; i.e., a filter clause\n  \"Return a suggested default join condition when constructing a join against `joinable`, e.g. a Table, Saved\n  Question, or another query. A suggested condition will be returned if the query stage has a foreign key to the\n  primary key of the thing we're joining (see #31175 for more info); otherwise this will return `nil` if no default\n  condition is suggested.\"\n  ([query joinable]\n   (suggested-join-condition query -1 joinable))\n\n  ([query         :- ::lib.schema/query\n    stage-number  :- :int\n    joinable]\n   (when-let [pk-col (pk-column query stage-number joinable)]\n     (when-let [fk-col (fk-column-for query stage-number pk-col)]\n       (lib.filter/filter-clause (lib.filter.operator/operator-def :=) fk-col pk-col)))))\n\n(def ^:private Joinable\n  [:or lib.metadata/TableMetadata lib.metadata/CardMetadata])\n\n(mu/defn joined-thing :- [:maybe Joinable]\n  \"Return metadata about the origin of `a-join` using `metadata-providerable` as the source of information.\"\n  [metadata-providerable :- lib.metadata/MetadataProviderable\n   a-join                :- ::lib.schema.join/join]\n  (let [origin (-> a-join :stages first)]\n    (cond\n      (:source-card origin)  (lib.metadata/card metadata-providerable (:source-card origin))\n      (:source-table origin) (lib.metadata/table metadata-providerable (:source-table origin)))))\n\n(defn- add-join-alias-to-joinable-columns [cols a-join]\n  (let [join-alias     (current-join-alias a-join)\n        unique-name-fn (lib.util/unique-name-generator)]\n    (mapv (fn [col]\n            (as-> col col\n              (with-join-alias col join-alias)\n              (add-source-and-desired-aliases a-join unique-name-fn col)))\n          cols)))\n\n(defn- mark-selected-joinable-columns\n  \"Mark the column metadatas in `cols` as `:selected` if they appear in `a-join`'s `:fields`.\"\n  [cols a-join]\n  (let [j-fields (join-fields a-join)]\n    (case j-fields\n      :all        (mapv #(assoc % :selected? true)\n                        cols)\n      (:none nil) (mapv #(assoc % :selected? false)\n                        cols)\n      ;; figure out which columns are in `:fields`, and then match them to the closest match out of `all-source-refs`.\n      (let [selected-fields-refs (mapv lib.ref/ref j-fields)\n            ;; pre-calculate refs for all the cols so we can match them up to the ones in `:fields`.\n            cols                 (mapv (fn [col]\n                                         (assoc col ::ref (lib.ref/ref col)))\n                                       cols)\n            all-source-refs      (mapv ::ref cols)\n            selected-source-refs (into #{}\n                                       (map #(lib.equality/find-closest-matching-ref % all-source-refs))\n                                       selected-fields-refs)]\n        (mapv (fn [col]\n                (->  col\n                     (assoc :selected? (contains? selected-source-refs (::ref col)))\n                     (dissoc ::ref)))\n              cols)))))\n\n(def ^:private JoinOrJoinable\n  [:or\n   [:ref ::lib.schema.join/join]\n   Joinable])\n\n(defn- join? [x]\n  (= (lib.dispatch/dispatch-value x) :mbql/join))\n\n(mu/defn joinable-columns :- [:sequential lib.metadata/ColumnMetadata]\n  \"Return information about the fields that you can pass to [[with-join-fields]] when constructing a join against\n  something [[Joinable]] (i.e., a Table or Card) or manipulating an existing join. When passing in a join, currently\n  selected columns (those in the join's `:fields`) will include `:selected true` information.\"\n  [query            :- ::lib.schema/query\n   stage-number     :- :int\n   join-or-joinable :- JoinOrJoinable]\n  (let [a-join   (when (join? join-or-joinable)\n                   join-or-joinable)\n        source (if a-join\n                 (joined-thing query join-or-joinable)\n                 join-or-joinable)\n        cols   (lib.metadata.calculation/returned-columns query stage-number source)]\n    (cond-> cols\n      a-join (add-join-alias-to-joinable-columns a-join)\n      a-join (mark-selected-joinable-columns a-join))))\n\n(defn- first-join?\n  \"Whether a `join-or-joinable` is (or will be) the first join in a stage of a query.\n\n  If a join is passed, we need to check whether it's the first join in the first stage of a source-table query or\n  not.\n\n  New joins get appended after any existing ones, so it would be safe to assume that if there are any other joins in\n  the current stage, this **will not** be the first join in the stage.\"\n  [query stage-number join-or-joinable]\n  (let [existing-joins (joins query stage-number)]\n    (or\n     ;; if there are no existing joins, then this will be the first join regardless of what is passed in.\n     (empty? existing-joins)\n     ;; otherwise there ARE existing joins, so this is only the first join if it is the same thing as the first join\n     ;; in `existing-joins`.\n     (when (join? join-or-joinable)\n       (= (:alias join-or-joinable)\n          (:alias (first existing-joins)))))))\n\n(mu/defn join-lhs-display-name :- ::lib.schema.common/non-blank-string\n  \"Get the display name for whatever we are joining. See #32015 for screenshot examples.\n\n  The rules, copied from MLv1, are as follows:\n\n  1. If this is the first join in the first stage of a query, and the query uses a `:source-table`, then use the\n     display name for the source Table.\n\n  2. Otherwise use `Previous results`.\n\n  These rules do seem a little goofy -- why don't we use the name of a Saved Question or Model? But we can worry about\n  that in the future. For now, let's just replicate MLv1 behavior.\n\n  This function needs to be usable while we are in the process of constructing a join in the context of a given stage,\n  but also needs to work for rendering existing joins. Pass a join in for existing joins, or something [[Joinable]]\n  for ones we are currently building.\"\n  ([query join-or-joinable]\n   (join-lhs-display-name query -1 join-or-joinable))\n\n  ([query             :- ::lib.schema/query\n    stage-number      :- :int\n    join-or-joinable  :- [:maybe JoinOrJoinable]]\n   (if (and (zero? (lib.util/canonical-stage-index query stage-number)) ; first stage?\n            (first-join? query stage-number join-or-joinable)           ; first join?\n            (lib.util/source-table-id query))                           ; query ultimately uses source Table?\n     (let [table-id (lib.util/source-table-id query)\n           table    (lib.metadata/table query table-id)]\n       ;; I think `:default` is okay here, there shouldn't be a difference between `:default` and `:long` for a\n       ;; Table anyway\n       (lib.metadata.calculation/display-name query stage-number table))\n     (i18n/tru \"Previous results\"))))\n","~:reader-features",["^K",["~:cljs-release","~:cljs-dev","~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["metabase.lib.join/JoinWithOptionalAlias","metabase.lib.join/PartialJoin","metabase.lib.join/FieldOrPartialJoin","metabase.lib.metadata/ColumnMetadata","metabase.lib.join/current-join-alias","field-or-join","G__79982","cljs.core/Keyword","js/Error","metabase.lib.dispatch/dispatch-value","metabase.lib.options/options","metabase.lib.join/with-join-alias-update-join-fields","join","new-alias","G__79983","cljs.core.update","fields","cljs.core/sequential?","cljs.core.mapv","field-ref","metabase.lib.join/with-join-alias","metabase.lib.join/standard-join-condition?","condition","cljs.core/first","cljs.core/seq","cljs.core.filter","cljs.core/some?","&parents","&match","cljs.core/vector?","cljs.core/count","&match_0__79993","cljs.core.nth","&match_2__79995","&match_2__79995_0__79997","cljs.core/keyword-identical?","&match_3__79996","&match_3__79996_0__80000","cljs.core.match/backtrack","e80008","e__62528__auto__","e80007","e80006","e80005","e80004","e80003","_operator","_opts","_lhs-opts","_lhs-id-or-name","_rhs-opts","_rhs-id-or-name","metabase.lib.join/standard-join-condition-rhs","vec__80009","_lhs","rhs","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","metabase.lib.join/standard-join-condition-update-rhs","seq80012","G__80013","cljs.core/next","G__80014","self__5754__auto__","f","args","cljs.core/not","vec__80018","operator","opts","lhs","cljs.core.apply","metabase.lib.join/with-join-alias-update-join-conditions","old-alias","cljs.core/empty?","metabase.mbql.util.match.impl/update-in-unless-empty","x__63598__auto__","&match_0__80047","&match_1__80048","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","cljs.core/ILookup","&match_1__80048_join-alias__80052","cljs.core.get","cljs.core._EQ_","e80057","e80055","e80054","e80053","metabase.mbql.util.match.impl/replace-in-collection","replace-80036","_id-or-name","conditions","metabase.lib.join.standard_join_condition_update_rhs","metabase.lib.join/with-join-alias-update-join","metabase.util/assoc-dissoc","join-alias","G__80059","metabase.lib.options.update_options","metabase.lib.join/resolve-join","query","stage-number","map__80063","cljs.core/--destructure-map","joins","metabase.lib.util/query-stage","or__5045__auto__","p1__80060#","medley.core.find_first","cljs.core.ex_info","metabase.shared.util.i18n.js_i18n","cljs.core.pr_str","metabase.lib.metadata.calculation/display-name-method","p__80068","map__80069","vec__80070","map__80073","_stage-number","source-table","source-card","_first-stage","_join","_style","metabase.lib.metadata/table","metabase.shared.util.i18n/js-i18n","metabase.lib.metadata.calculation/display-info-method","display-name","metabase.lib.metadata.calculation.display_name","metabase.lib.metadata.calculation/metadata-method","_query","metabase.lib.join/column-from-join-fields","column-metadata","cljs.core.assoc","col","p__80075","map__80076","strategy","G__80077","p__80078","map__80090","default","option","G__80091","metabase.util/qualified-name","metabase.lib.join/joined-field-desired-alias","field-name","metabase.lib.util/format","metabase.lib.join/add-source-and-desired-aliases","unique-name-fn","cljs.core.some_fn","G__80101","metabase.lib.metadata.calculation/returned-columns-method","p__80102","p__80103","map__80104","map__80105","stages","options","ensure-previous-stages-have-metadata","js/metabase","js/metabase.lib","js/metabase.lib.stage","js/metabase.lib.stage.ensure-previous-stages-have-metadata","cljs.core/Var","metabase.lib.stage/ensure-previous-stages-have-metadata","join-query","G__80128","field-metadatas","metabase.lib.metadata.calculation.returned_columns","cljs.core/peek","iter__5523__auto__","s__80131","cljs.core/LazySeq","temp__5804__auto__","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","b__80133","cljs.core/chunk-buffer","i__80132","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__80130","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","join-field","cljs.core/dissoc","metabase.lib.metadata.calculation.metadata","field-metadata","metabase.lib.metadata.calculation/visible-columns-method","metabase.lib.join/all-joins-visible-columns","cljs.core.into","cljs.core.mapcat","metabase.lib.metadata.calculation.visible_columns","metabase.lib.join/all-joins-expected-columns","js/metabase.lib.join","js/metabase.lib.join.join-clause-method","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","fexpr__80148","cljs.core/MultiFn","cljs.core.symbol","metabase.lib.join/join-clause-method","metabase.lib.hierarchy/hierarchy","a-join-clause","another-query","metabase.lib.util/pipeline","metabase.lib.options/ensure-uuid","mbql-stage","metabase.lib.join/with-join-conditions-add-alias-to-rhses","metabase.lib.join/with-join-conditions","a-join","metabase.lib.common/->op-arg","cljs.core/not-empty","G__80167","metabase.lib.join/join-clause","joinable","metabase.util.assoc_default","metabase.lib.join.join_clause","metabase.lib.join/with-join-fields","cljs.core.comp","cljs.core.map","metabase.lib.ref/ref","temp__5802__auto__","current-alias","p1__80169#","cljs.core/identity","metabase.lib.join/select-home-column","home-cols","cond-fields","cond->home","cljs.core.keep","home-col","cond-field","metabase.lib.equality.find_closest_matching_ref","cond-home-cols","metabase.lib.types.isa/foreign-key?","metabase.lib.types.isa/primary-key?","metabase.lib.join/strip-id","s","clojure.string/trim","clojure.string/replace","metabase.lib.join/similar-names?","name0","name1","and__5043__auto__","plural1","cljs.core/Delay","inflections.core/plural","plural0","cljs.core/deref","metabase.lib.join/calculate-join-alias","joined","joined-name","home-name","similar","cljs.core/re-matches","metabase.lib.join/add-alias-to-join-refs","metadata-providerable","form","join-refs","e80179","replace-80177","field","field-clause","metabase.lib.util/field-clause?","cljs.core/boolean","metabase.lib.join/add-alias-to-condition","home-refs","&match_2__80186","&match_3__80187","e80190","e80189","e80188","replace-80182","op","op-opts","lhs-aliased","cljs.core/contains?","rhs-aliased","bare-lhs","bare-rhs","metabase.lib.join/generate-unique-name","base-name","taken-names","generator","metabase.lib.util/unique-name-generator","cljs.core/run!","metabase.lib.join/add-default-alias","stage","&match_left__80198","cljs.core.subvec","&match_left__80198_0__80200","e80203","e80202","e80201","metabase.mbql.util.match.impl/match-in-collection","match-80195","metabase.lib.query.query_with_stages","p1__80193#","G__80206","metabase.lib.join/join","metabase.lib.join.join","metabase.lib.util.update_query_stage","cljs.core/update","cljs.core.conj","cljs.core/vec","G__80209","metabase.lib.join/joins","metabase.lib.join.joins","metabase.lib.join/implicit-join-name","table-name","source-field-id-name","metabase.lib.join/join-conditions","metabase.lib.join/join-fields","metabase.lib.join/raw-join-strategy->strategy-option","raw-strategy","cljs.core.merge","metabase.lib.join/raw-join-strategy","metabase.lib.join/join-strategy","metabase.lib.join/with-join-strategy","G__80218","G__80221","metabase.lib.join/available-join-strategies","metabase.lib.join.available_join_strategies","database","metabase.lib.metadata/database","features","cljs.core.partial","metabase.lib.join/sort-join-condition-columns","columns","map__80223","pk","fk","other","cljs.core/group-by","column","cljs.core.concat","G__80227","metabase.lib.join/join-condition-lhs-columns","existing-join-or-nil","rhs-column-or-nil","metabase.lib.join.join_condition_lhs_columns","_rhs-column-or-nil","existing-join-alias","join-aliases-to-ignore","p1__80224#","cljs.core.drop_while","cljs.core.not_EQ_","cljs.core.remove","col-join-alias","G__80230","metabase.lib.join/join-condition-rhs-columns","lhs-column-or-nil","metabase.lib.join.join_condition_rhs_columns","_lhs-column-or-nil","G__80233","metabase.lib.join/join-condition-operators","metabase.lib.join.join_condition_operators","metabase.lib.filter.operator/join-operators","metabase.lib.join/pk-column","x","metabase.lib.join/fk-column-for","pk-col","pk-id","p__80236","map__80237","fk-target-field-id","G__80240","metabase.lib.join/suggested-join-condition","metabase.lib.join.suggested_join_condition","fk-col","metabase.lib.filter.filter_clause","metabase.lib.filter.operator.operator_def","metabase.lib.join/Joinable","metabase.lib.metadata/TableMetadata","metabase.lib.metadata/CardMetadata","metabase.lib.join/joined-thing","origin","metabase.lib.metadata/card","metabase.lib.join/add-join-alias-to-joinable-columns","cols","metabase.lib.join/mark-selected-joinable-columns","j-fields","G__80245","p1__80242#","p1__80243#","selected-fields-refs","all-source-refs","selected-source-refs","p1__80244#","cljs.core.dissoc","metabase.lib.join/JoinOrJoinable","metabase.lib.join/join?","metabase.lib.join/joinable-columns","join-or-joinable","source","G__80247","metabase.lib.join/first-join?","existing-joins","G__80250","metabase.lib.join/join-lhs-display-name","metabase.lib.join.join_lhs_display_name","metabase.lib.util/canonical-stage-index","metabase.lib.util/source-table-id","table-id","table","cljs.core/chunk-first"]],"~:used-vars",["^K",["~$metabase.lib.metadata.calculation/visible-columns","~$metabase.lib.join/JoinOrJoinable","~$cljs.core/mapcat","~$cljs.core/--destructure-map","~$cljs.core/keep","~$cljs.core/some?","~$cljs.core.match/backtrack","~$metabase.lib.util/pipeline","~$cljs.core/PROTOCOL_SENTINEL","~$cljs.core/comp","~$metabase.mbql.util.match.impl/update-in-unless-empty","~$metabase.lib.join/join-strategy","~$cljs.core/rest","~$js/metabase.lib.join.join-clause-method","~$metabase.lib.util/source-table-id","~$metabase.lib.metadata.calculation/returned-columns-method","~$metabase.lib.join/FieldOrPartialJoin","~$metabase.lib.metadata.calculation/visible-columns-method","~$metabase.lib.join/with-join-alias-update-join","~$cljs.core/MultiFn","~$cljs.core/sequential?","~$metabase.util/assoc-default","~$metabase.lib.types.isa/foreign-key?","~$metabase.lib.join/standard-join-condition-rhs","~$metabase.lib.metadata/CardMetadata","~$metabase.lib.options/options","~$metabase.lib.join/with-join-strategy","~$inflections.core/plural","~$metabase.lib.util/unique-name-generator","~$metabase.lib.join/joined-field-desired-alias","~$cljs.core/vector?","~$metabase.lib.join/strip-id","~$metabase.lib.join/implicit-join-name","~$metabase.lib.join/add-source-and-desired-aliases","~$cljs.core/filter","~$cljs.core/=","~$metabase.lib.join/join?","~$metabase.lib.join/pk-column","~$metabase.lib.join/raw-join-strategy","~$metabase.lib.join/join-clause","~$metabase.lib.join/raw-join-strategy->strategy-option","~$cljs.core/re-matches","~$cljs.core/partial","~$metabase.lib.join/joins","~$metabase.lib.util/query-stage","~$metabase.lib.filter.operator/operator-def","~$cljs.core/IndexedSeq","~$cljs.core/drop-while","~$metabase.lib.join/with-join-alias","~$cljs.core/count","~$metabase.lib.options/ensure-uuid","~$cljs.core/deref","~$metabase.lib.stage/ensure-previous-stages-have-metadata","~$cljs.core/seq","~$cljs.core/chunk-first","~$metabase.lib.common/->op-arg","~$metabase.lib.metadata/card","~$cljs.core/apply","~$metabase.lib.options/update-options","~$metabase.util/qualified-name","~$cljs.core/identity","~$metabase.lib.metadata/ColumnMetadata","~$cljs.core/Keyword","~$metabase.lib.util/canonical-stage-index","~$cljs.core/group-by","~$cljs.core/chunk","~$cljs.core/mapv","~$cljs.core/not=","~$cljs.core/dissoc","~$cljs.core/keyword-identical?","~$cljs.core/Delay","~$cljs.core/LazySeq","~$metabase.lib.join/similar-names?","~$cljs.core/chunk-rest","~$cljs.core/atom","~$metabase.lib.join/with-join-conditions","~$metabase.mbql.util.match.impl/replace-in-collection","~$metabase.lib.metadata.calculation/display-info-method","~$metabase.lib.join/sort-join-condition-columns","~$cljs.core/concat","~$cljs.core/pr-str","~$metabase.lib.join/add-default-alias","~$metabase.lib.join/fk-column-for","~$cljs.core/Var","~$metabase.lib.join/joined-thing","~$metabase.lib.metadata/TableMetadata","~$metabase.lib.join/add-join-alias-to-joinable-columns","~$metabase.lib.util/format","~$cljs.core/native-satisfies?","~$metabase.lib.join/all-joins-expected-columns","~$metabase.lib.join/resolve-join","~$metabase.lib.types.isa/primary-key?","~$cljs.core/empty?","~$metabase.lib.join/standard-join-condition-update-rhs","~$metabase.lib.util/update-query-stage","~$cljs.core/contains?","~$cljs.core/into","~$metabase.lib.metadata.calculation/returned-columns","~$metabase.lib.join/join-clause-method","~$cljs.core/conj","~$js/metabase.lib.stage.ensure-previous-stages-have-metadata","~$metabase.lib.filter.operator/join-operators","~$metabase.lib.join/with-join-alias-update-join-fields","~$metabase.lib.join/suggested-join-condition","~$cljs.core/update","~$metabase.lib.join/with-join-alias-update-join-conditions","~$cljs.core/run!","~$metabase.lib.metadata/database","~$metabase.lib.join/join-condition-operators","~$metabase.lib.join/joinable-columns","~$cljs.core/peek","~$cljs.core/map","~$js/metabase.lib.stage","~$metabase.lib.join/first-join?","~$medley.core/find-first","~$metabase.lib.join/join","~$metabase.lib.join/add-alias-to-join-refs","~$metabase.lib.join/join-lhs-display-name","~$cljs.core/-add-method","~$metabase.lib.metadata.calculation/metadata","~$metabase.lib.metadata.calculation/metadata-method","~$cljs.core/get","~$js/metabase.lib","~$metabase.lib.join/mark-selected-joinable-columns","~$metabase.lib.query/query-with-stages","~$metabase.lib.util/field-clause?","~$cljs.core/chunk-append","~$cljs.core/-nth","~$cljs.core/remove","~$cljs.core/not-empty","~$cljs.core/symbol","~$metabase.lib.join/join-conditions","~$metabase.lib.metadata.calculation/display-name","~$cljs.core/subvec","~$metabase.lib.join/with-join-conditions-add-alias-to-rhses","~$metabase.shared.util.i18n/js-i18n","~$cljs.core/nth","~$cljs.core/ex-info","~$metabase.lib.join/standard-join-condition?","~$metabase.lib.join/all-joins-visible-columns","~$metabase.lib.dispatch/dispatch-value","~$metabase.lib.hierarchy/hierarchy","~$clojure.string/replace","~$metabase.lib.join/join-fields","~$metabase.util/assoc-dissoc","~$js/metabase.lib.join","~$cljs.core/next","~$cljs.core/vec","~$metabase.lib.ref/ref","~$metabase.lib.join/generate-unique-name","~$cljs.core/chunk-cons","~$metabase.lib.filter/filter-clause","~$metabase.lib.join/join-condition-rhs-columns","~$cljs.core/not","~$metabase.lib.join/add-alias-to-condition","~$cljs.core/cons","~$cljs.core/assoc","~$metabase.lib.join/calculate-join-alias","~$js/metabase","~$cljs.core/chunk-buffer","~$metabase.lib.metadata/table","~$metabase.lib.join/join-condition-lhs-columns","~$clojure.string/trim","~$metabase.lib.equality/find-closest-matching-ref","~$metabase.lib.join/Joinable","~$cljs.core/some-fn","~$metabase.lib.join/JoinWithOptionalAlias","~$metabase.lib.join/select-home-column","~$metabase.lib.join/current-join-alias","~$cljs.core/first","~$cljs.core/merge","~$metabase.lib.join/with-join-fields","~$metabase.lib.metadata.calculation/display-name-method","~$metabase.lib.join/PartialJoin","~$js/Error","~$cljs.core/boolean","~$metabase.mbql.util.match.impl/match-in-collection","~$metabase.lib.join/available-join-strategies","~$cljs.core/ILookup","~$metabase.lib.join/column-from-join-fields","~$cljs.core/chunked-seq?"]]],"~:cache-keys",["~#cmap",[["^28","camel_snake_kebab/internals/misc.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^K",[]],"~:deps-syms",["^1?","^D","~$camel-snake-kebab.internals.string-separator","^1U"]]],["^28","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.dom.HtmlElement"]]],["^28","metabase/shared/util/i18n.cljs"],["6c3c8615004b349dae9851ed547d516d45e04bd0","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$shadow.js.shim.module$ttag","^1U"]]],["^28","goog/labs/useragent/platform.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.string.internal","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^28","goog/crypt/crypt.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.asserts","~$goog.async.throwException"]]],["^28","metabase/types.cljc"],["00232bf78b259e26a21c218c8f2d746ba7003a15","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$clojure.set","~$metabase.types.coercion-hierarchies","^17"]]],["^28","cljs/spec/gen/alpha.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$goog.Uri"]]],["^28","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","~$goog.string"]]],["^28","metabase/lib/util.cljc"],["11c3262368d876979e323f3e646aab21fbf9b86e","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$shadow.js.shim.module$crc_32","^72","~$goog.string.format","^6[","^1U","^1G","^1<","^1D","^S","^13","^19","~$metabase.lib.schema.id","~$metabase.mbql.util","^[","^17","^U"]]],["^28","lambdaisland/glogi.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$goog.log","~$goog.debug.Console","~$goog.array","^1U","~$goog.object","~$goog.debug.FancyWindow","~$goog.debug.DivConsole"]]],["^28","goog/math/math.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y"]]],["^28","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","goog/string/stringformat.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^72"]]],["^28","malli/registry.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6U","^6V","^6Y","^6T","^6W","^6X"]]],["^28","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^6T"]]],["^28","goog/style/style.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","~$goog.dom","~$goog.dom.NodeType","~$goog.dom.TagName","~$goog.dom.safe","~$goog.dom.vendor","~$goog.html.SafeStyleSheet","~$goog.math.Box","~$goog.math.Coordinate","~$goog.math.Rect","~$goog.math.Size","^7:","~$goog.reflect","^72","~$goog.userAgent"]]],["^28","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y"]]],["~:shadow.build.js-support/require","moment"],["~$shadow.js.shim.module$moment","shadow.js.shim.module$moment.js","require","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^7M","moment-timezone"],["~$shadow.js.shim.module$moment_timezone","shadow.js.shim.module$moment_timezone.js","require","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/mbql/schema/macros.cljs"],["2af09bd42ffb1e15b66723cf7ba15db7dc75d10b","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","metabase/lib/schema/mbql_clause.cljc"],["e5bdd00c58db706b1219843528fd3cd9dd8ab728","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^13","^19","~$metabase.types","^U","~$metabase.util.malli.registry"]]],["^28","goog/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.labs.userAgent.browser","~$goog.labs.userAgent.engine","~$goog.labs.userAgent.platform","^6U","^7K","^6T"]]],["^28","malli/generator.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^F","^1U","~$clojure.test.check","~$clojure.test.check.generators","~$clojure.test.check.properties","~$clojure.test.check.random","~$clojure.test.check.rose-tree","~$malli.core","~$malli.registry"]]],["^28","clojure/test/check/properties.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7V","~$clojure.test.check.results"]]],["^28","clojure/test/check/generators.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^7X","^7Y","^72"]]],["^28","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/lib/common.cljc"],["a3bc6343077ef13a3da77612b68f23f9b2a3d890","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1M","^1F","^1D","^1=","^13","^U"]]],["^28","metabase/lib/schema/util.cljc"],["14a9e8a90c56f5e44b4ecd361e962722fd97aecf","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1D"]]],["^28","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","malli/util.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^D","^7Z"]]],["^28","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$cljs.tools.reader.impl.errors","~$cljs.tools.reader.reader-types","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^72","~$goog.string.StringBuffer"]]],["^28","clojure/test/check/random/doubles.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$clojure.test.check.random.longs"]]],["^28","net/cgrand/macrovich.cljc"],["abcb26cbfe0f8eef363b25525210c0fe1eb1f693","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","malli/destructure.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$clojure.walk","^7Z","~$malli.impl.util"]]],["^28","schema/spec/variant.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$schema.utils","~$schema.spec.core"]]],["^28","goog/structs/circularbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","weavejester/dependency.cljc"],["7fd7f8879313f6a7e295f7447e668bdf492c42c1","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^6["]]],["^28","metabase/lib/schema/common.cljc"],["3f51a06335a7cb84c835d859c422919499874414","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^7P","^7Q"]]],["^28","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6U","^6T"]]],["^28","cljs/pprint.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^72","^86"]]],["^28","metabase/lib/schema/template_tag.cljc"],["f1b6289b8e576857fe667aed3da134e4ad1ea26a","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7Z","^13","^75","~$metabase.mbql.schema","^7Q"]]],["^28","metabase/lib/schema/ref.cljc"],["5037a60b3d2f427702cf5cedf23f02bcc394d051","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^1M","^1F","^13","^19","^75","~$metabase.lib.schema.mbql-clause","~$metabase.lib.schema.temporal-bucketing","^7P","^7Q"]]],["^28","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^82","^83","^84","^81","^79","^72","^86"]]],["^28","clojure/test/check/rose_tree.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","clojure/test/check/impl.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","camel_snake_kebab/internals/string_separator.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U"]]],["^28","clojure/test/check/random.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$clojure.test.check.random.doubles","^87"]]],["^28","metabase/lib/schema/expression/arithmetic.cljc"],["e6936a3e0b11bc3cd40d4e396c708af4622c21cb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7Z","^1G","^1F","^13","^19","^8=","^8>","^7P","^7Q"]]],["^28","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/lib/schema/expression/string.cljc"],["b2d7de575aaaa880fdc88dfc31642c8e002c3669","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^19","^8="]]],["^28","metabase/lib/types/constants.cljc"],["efb91045e39c9ec06192309589f82a778219a002","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7:"]]],["^28","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/lib/schema/filter.cljc"],["0147dea423ebfd097bf1edb97f0325c9e2908a85","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^13","^19","^8=","^8>","^7Q"]]],["^28","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y"]]],"~:SHADOW-TIMESTAMP",[1689947046000,1689947046000,1689947050000],["^28","metabase/lib/ref.cljc"],["86a9fbeddec3e58f7bb54e61f5342658b370fb3b","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1M","~$metabase.lib.schema.ref","^U"]]],["^28","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","^7K"]]],["^28","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","~$goog.fs.blob","^7=","~$goog.html.SafeScript","~$goog.html.trustedtypes","^7?","^7@"]]],["^28","schema/spec/leaf.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^8;"]]],["^28","metabase/util/format.cljc"],["875f86a08288cb3ad5a6f15df988897eaf8613af","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^72"]]],["^28","goog/math/irect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","goog/math/box.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","^7H"]]],["^28","metabase/lib/options.cljc"],["1870276153adf026e09a3e9ed1ba8beaad80e1c8","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^13","^[","^17","^U"]]],["^28","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","clojure/test/check.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7V","^7X","^80","^7Y","~$clojure.test.check.impl"]]],["^28","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/lib/metadata.cljc"],["a8652a185953ef0e0b1c77d5540a4aa7271c0c63","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$metabase.lib.metadata.protocols","^13","^75","^1>","^U","^7Q"]]],["^28","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7?","~$goog.html.SafeUrl","^7@","^6Y","^6T"]]],["^28","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^8C","~$goog.html.SafeStyle","^8G","^7>","~$goog.html.uncheckedconversions","^7?","^6T"]]],["^28","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7C","^6Y","~$goog.dom.element"]]],["^28","medley/core.cljc"],["f5117fa4c15ff14c4a0ab7db414b0f102afb0b8a","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/useragent/product.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7R","^7T","^7L"]]],["^28","metabase/lib/metadata/protocols.cljc"],["f5c81e2cab09f5dabb3cab711f7db1c5df1b398d","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","metabase/lib/schema/expression/conditional.cljc"],["226c4623394b90853fcb014e9a95e84ffc8bd6db","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^6[","^19","^8=","^7P","^7Q"]]],["^28","lambdaisland/glogi/console.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$lambdaisland.glogi","~$lambdaisland.glogi.print","^7:","^78"]]],["^28","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7?","^8C","^8L","^7F","^8G","^7C","^7>","^7@","^6Y","^7R","^79","^7:","^6T","~$goog.dom.tags","^8D"]]],["^28","metabase/lib/filter/operator.cljc"],["6b85a92dc1ffb19ca21aec66064d18564c2fbbc2","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^X","^V","^13","^1P","^1N","^[","^17","^U"]]],["^28","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7:"]]],["^28","goog/math/size.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/lib/temporal_bucket.cljc"],["22c08818f6579bd329ece9f6a337c75bf33381e2","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^1M","^1F","^V","^S","^13","^8>","^[","^U"]]],["^28","malli/error.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^7Z","~$malli.util"]]],["^28","metabase/lib/dispatch.cljc"],["914208cd51b78412eff1b402519bbb422845497a","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^17"]]],["^28","metabase/util/malli.cljc"],["0f9ba23be6bb9fa629617001e985b988d2322b17","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^D","^7Z","~$malli.destructure","~$malli.error","~$malli.generator","^8R","^[","^17"]]],["^28","goog/labs/useragent/engine.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^79","^6T","^6U"]]],["^28","metabase/lib/query.cljc"],["67977f5ae965e05008d2cb243d9e4898404cb75b","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$metabase.lib.convert","^1M","^1F","^X","^V","~$metabase.lib.normalize","^S","^75","^1>","^[","~$metabase.util.log","^U"]]],["^28","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","cljs/reader.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7:","^85","~$cljs.tools.reader.edn","^86"]]],["^28","metabase/mbql/schema/helpers.cljc"],["b1f6002b97b59423b504abb666e13c9b0228b768","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^7P","~$schema.core"]]],["^28","goog/dom/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^79","^6Y","^8H","~$goog.dom.BrowserFeature","^7B","^7C","^7D","^8K","^8M","^7H","^7J","^7:","^72","^7?","~$goog.string.Unicode","^7L"]]],["^28","borkdude/dynaload.cljc"],["accd696ba364b850b4d92e38f5a34d0e828a0ad1","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","metabase/util/log.cljs"],["7d8a3bf01eb27c2ba7269dc90dc218e46bcc1d3a","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^77","^72","^74","^8O","~$lambdaisland.glogi.console"]]],["^28","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.debug.Error","^7B"]]],["^28","goog/debug/relativetimeprovider.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","malli/sci.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$borkdude.dynaload"]]],["^28","metabase/lib/schema/expression.cljc"],["f5c5c3ff3dc0f9a8b407cd7d06a68c6787061991","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1M","^1F","^13","^[","^7P","^U","^7Q"]]],["^28","goog/math/rect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","^7G","^7H","~$goog.math.IRect","^7J"]]],["^28","flatland/ordered/map.cljs"],["3a9cb9d79e47d77ecd4f4d550371ecf01464c461","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^79","^6Y","~$goog.collections.maps","^72","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^28","metabase/util/malli/registry.cljc"],["921d4f259bbe54cbeb6b88ae56937df492bdfb5e","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7Z","^7[","^8R"]]],["^28","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6V"]]],["^28","metabase/types/coercion_hierarchies.cljc"],["c3d70ef6080e044d61f13ff6bfd76490e2dcd0ac","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^6["]]],["^28","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/lib/metadata/calculation.cljc"],["bbd3cc646a10312da5b543d7d353519f4c61f931","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^1M","^1F","^X","^1D","^S","^13","^19","^8>","^1>","^[","^17","^8X","^U","^7Q"]]],["^28","goog/debug/divconsole.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.debug.HtmlFormatter","~$goog.dom.DomHelper","^7C","^7D","^8K","^7F","^77","^7?","~$goog.style"]]],["^28","schema/spec/collection.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^8:","^8;"]]],["^28","malli/impl/util.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","metabase/lib/schema/order_by.cljc"],["3f577f71e4ecba1aa1061f2228f6026ab45312ff","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^19","^8=","^7Q"]]],["^28","schema/utils.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^74","^7:","^72","^1U"]]],["^28","metabase/lib/schema/aggregation.cljc"],["ea4a70903cfc3ffeaa60ebdedb5ea00892da4dbe","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1F","^19","^8=","^[","^7Q"]]],["^28","cljs/core/match.cljs"],["f419c02deee501e9f4b29f81215ba81ffcefe9b6","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/debug/fancywindow.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^79","^6Y","~$goog.debug.DebugWindow","^9;","^7C","^7D","^8K","^7F","^77","^7:","^72","^7?","^7L"]]],["^28","goog/debug/formatter.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.debug","~$goog.debug.RelativeTimeProvider","^8K","^8G","^8M","^77","^7?"]]],["^28","metabase/shared/util/namespaces.cljs"],["00687008abd6eb291bc9d5ff1fff73210e0bbe6e","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","metabase/mbql/util/match/impl.cljc"],["4150e01975339d308f5cfedda77875eda19c030d","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",[]]],["^28","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^79","^7:"]]],["^28","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^82","^1U","~$cljs.tools.reader.impl.inspect"]]],["^28","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^72","^86"]]],["^28","metabase/lib/schema/temporal_bucketing.cljc"],["9cb7bba3e46e1de2fbb37d61df332336da6d9f66","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^6[","^7Q"]]],["^28","metabase/lib/normalize.cljc"],["a044c97fb2dfb3e38178783d6a5d41777a3a9224","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1M","^1F"]]],["^28","metabase/util.cljc"],["2eb945a6741f1450ecac08a9087b862ce52b9e3a","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$camel-snake-kebab.internals.macros","~$clojure.data","^@","^6[","^1U","^88","~$flatland.ordered.map","^1G","^[","~$metabase.shared.util.namespaces","~$metabase.util.format","^8X","~$net.cgrand.macrovich","~$weavejester.dependency"]]],["^28","clojure/test/check/random/longs/bit_count_impl.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","no/en/core.cljc"],["46f67eeb6381165553708d8db01fec220d5f7054","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","~$cljs.reader","~$goog.crypt.base64"]]],["^28","malli/impl/regex.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^89"]]],["^28","camel_snake_kebab/internals/macros.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$camel-snake-kebab.internals.alter-name","~$camel-snake-kebab.internals.misc"]]],["^28","metabase/lib/schema/expression/temporal.cljc"],["f1f22c1655e7d335b884a22b010f2b8b08ad1e94","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^6[","^7Z","^1F","^13","^19","~$metabase.lib.schema.literal","^8=","^8>","^7Q","^7N","^7O"]]],["^28","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7D","^8M","^7?","^6T"]]],["^28","schema/core.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^8:","^8;","~$schema.spec.leaf","~$schema.spec.variant","~$schema.spec.collection"]]],["^28","metabase/mbql/schema.cljc"],["c51bf2a180ecbc12d6a1cd42a4049323f46a0085","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7N","^7O","^D","^6[","~$metabase.mbql.schema.helpers","~$metabase.mbql.schema.macros","^8Z"]]],["^28","metabase/mbql/util/match.cljs"],["d65aaa9fbcb7960b90ba7ca97258b1dc8a40be2b","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^H","~$metabase.mbql.util.match.impl"]]],["^28","malli/core.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^D","~$malli.impl.regex","^89","^7[","~$malli.sci"]]],["^28","metabase/lib/schema.cljc"],["122fe4013d55087fc7287141eb7dc6f630436424","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$metabase.lib.schema.aggregation","^13","^19","~$metabase.lib.schema.expression.arithmetic","~$metabase.lib.schema.expression.conditional","~$metabase.lib.schema.expression.string","~$metabase.lib.schema.expression.temporal","^1P","^75","^11","^9L","~$metabase.lib.schema.order-by","^8A","~$metabase.lib.schema.template-tag","~$metabase.lib.schema.util","^14","^7Q"]]],["^28","clojure/data.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^6["]]],["^28","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6T","^6X"]]],["^28","goog/debug/debug.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^79","~$goog.debug.errorcontext"]]],["^28","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","schema/spec/core.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^8:"]]],["^7M","ttag"],["^6S","shadow.js.shim.module$ttag.js","require","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","goog/math/coordinate.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.math"]]],["^28","goog/debug/errorcontext.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^83","^72","^86"]]],["^28","inflections/core.cljc"],["e6e3e2ec7855d2e49589935dde6e494c75e7673f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^88","~$no.en.core"]]],["^28","metabase/lib/convert.cljc"],["02b5f0cb2d10c8707d14831510e21c7d65dc15b4","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^9B","^6[","^1U","^7Z","^8T","^1G","^1M","^1F","^1D","^S","^19","^1>","^17","^8X"]]],["^28","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.flags"]]],["^28","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7B","^7C"]]],["^28","metabase/lib/join.cljc"],["239ae05e663e7e3d4aaba19cf702d125ffda0dc8","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^1Q","^1G","^1<","^1M","^W","^1J","^16","^1F","^X","^V","^1D","^1A","^1=","^S","^13","^19","^1P","^11","^1N","^1>","^14","^[","^17","^U"]]],["^28","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","^8K","^8C","^8L","^7F","^8G","^7>","^7?","^6T"]]],["^28","goog/debug/debugwindow.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^9:","^7D","^8K","^7F","^77","^7?","~$goog.structs.CircularBuffer","^7L"]]],["^28","metabase/mbql/util.cljc"],["2532d5faa94d2a89dd06e529c641d594e298e2aa","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","~$metabase.mbql.predicates","^8<","^9P","^14","^[","^8Z"]]],["^28","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^81","^82","^83"]]],["^28","metabase/lib/types/isa.cljc"],["e18ef4b76ca36474693ff48f933bf55296452722","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1G","~$metabase.lib.types.constants","^1>","^7P"]]],["^28","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.math.Long","~$goog.math.Integer","^72","^7:","^79","^71","^86"]]],["^28","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7?","^7@","^8D","^6Y"]]],["^28","clojure/test/check/random/longs.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","~$clojure.test.check.random.longs.bit-count-impl","^:8","^D"]]],["^28","goog/log/log.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","^9>"]]],["^28","goog/async/throwexception.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","camel_snake_kebab/internals/alter_name.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7?","^8L","^7@","^7:","^6Y","^6T"]]],["^28","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7K"]]],["^28","goog/debug/console.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","~$goog.debug.TextFormatter","^77"]]],["^28","lambdaisland/glogi/print.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^8O","^7:"]]],["^28","goog/dom/browserfeature.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^7L"]]],["^28","clojure/set.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","^72"]]],["^28","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","^7@"]]],["^28","metabase/lib/schema/id.cljc"],["7cdfc70702a9a9e04b75ca7c9dc898ddf546f99d","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^13","^8<","^7Q"]]],["^28","metabase/lib/equality.cljc"],["09e4ca6749d64c174c277a2b16f7ad15b5cf6870","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1G","^1M","^1F","^X","^1D","^1>","^14"]]],["^28","goog/dom/vendor.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^72","^7L"]]],["^28","metabase/lib/filter.cljc"],["9834af342c05e488751df884eca79c07eb56f0d2","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^1U","^1G","^1<","^W","^16","^1F","^X","^V","^1D","^1=","^S","^19","^1P","~$metabase.lib.temporal-bucket","^1>","^[","^U"]]],["^28","metabase/lib/schema/literal.cljc"],["f8f31bfaef820ab25b896b49fd404b937d0df64e","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^7Z","^13","^19","^8=","^7Q"]]],["^28","metabase/lib/hierarchy.cljc"],["c9d228603522de5c85546fb645c59736d4eb94d2","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^28","metabase/mbql/predicates.cljc"],["20ab1a5ccd943c35c646c5f7396ea40f9bfa7ac4","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^8<","^8Z"]]],["^28","clojure/test/check/results.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D"]]],["^7M","crc-32"],["^73","shadow.js.shim.module$crc_32.js","require","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?"]]],["^28","metabase/lib/schema/join.cljc"],["924e0ca4abbab776fa05357d6d22bafb8a596648","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^D","^13","^19","^[","^7Q"]]],["^28","goog/crypt/base64.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^6M",["^ ","^6N",null,"^6O",["^K",[]],"^6P",["^1?","^6Y","~$goog.crypt","^6T","^7L","~$goog.userAgent.product"]]]]],"~:clj-info",["^ ","jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/line_col.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/viz.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/parse.cljc",1689946139000,"jar:file:/root/.m2/repository/weavejester/dependency/0.2.1/dependency-0.2.1.jar!/weavejester/dependency.cljc",1689946093000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/transform.clj",1689946146000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/order_by.cljc",1690286812000,"jar:file:/root/.m2/repository/ring/ring-codec/1.2.0/ring-codec-1.2.0.jar!/ring/util/codec.clj",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/hierarchy.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1689946174000,"file:/home/gmrworkspace/dashboard/src/metabase/models/dispatch.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/pprint.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/filter.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util.cljc",1692013156305,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema/helpers.cljc",1692013156305,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/core.cljc",1689946172000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/shared/util/i18n.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/reader.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/metadata.cljc",1690286812000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/macros.clj",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n/plural.clj",1690286813000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/core.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/util.cljc",1690286813000,"jar:file:/root/.m2/repository/nano-id/nano-id/1.0.0/nano-id-1.0.0.jar!/nano_id/core.cljc",1689946171000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/dispatch.cljc",1690286812000,"jar:file:/root/.m2/repository/io/github/camsaul/toucan2/1.0.520/toucan2-1.0.520.jar!/toucan2/core.clj",1689946166000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/common.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/plugins/classloader.clj",1692013156125,"jar:file:/root/.m2/repository/medley/medley/1.4.0/medley-1.4.0.jar!/medley/core.cljc",1689946185000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/util.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/random.clj",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/util/format.cljc",1690286813000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/temporal_bucket.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1689947050000,"jar:file:/root/.m2/repository/riddley/riddley/0.2.0/riddley-0.2.0.jar!/riddley/walk.clj",1689946160000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/ref.cljc",1690286812000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/reduction.clj",1689946146000,"jar:file:/root/.m2/repository/org/tcrawley/dynapath/1.1.0/dynapath-1.1.0.jar!/dynapath/util.clj",1689946174000,"jar:file:/root/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.3/camel-snake-kebab-0.4.3.jar!/camel_snake_kebab/internals/macros.cljc",1689946178000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match/impl.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/auto_flatten_seq.clj",1689946146000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/core.clj",1689946146000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/generator.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/id.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/core.cache/1.0.225/core.cache-1.0.225.jar!/clojure/core/cache.clj",1689946183000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/expression.cljc",1690286812000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/sci.cljc",1689946170000,"jar:file:/root/.m2/repository/potemkin/potemkin/0.4.6/potemkin-0.4.6.jar!/potemkin/types.clj",1689946176000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/template_tag.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/properties.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/math.numeric-tower/0.0.5/math.numeric-tower-0.0.5.jar!/clojure/math/numeric_tower.clj",1689946148000,"jar:file:/root/.m2/repository/net/cgrand/macrovich/0.2.1/macrovich-0.2.1.jar!/net/cgrand/macrovich.cljc",1689946165000,"jar:file:/root/.m2/repository/colorize/colorize/0.1.1/colorize-0.1.1.jar!/colorize/core.clj",1689946104000,"jar:file:/root/.m2/repository/borkdude/dynaload/0.3.5/dynaload-0.3.5.jar!/borkdude/dynaload.cljc",1689946165000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/options.cljc",1692013156125,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1689946092000,"jar:file:/root/.m2/repository/potemkin/potemkin/0.4.6/potemkin-0.4.6.jar!/potemkin.clj",1689946176000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/failure.clj",1689946146000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/variant.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1689946092000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/metadata/protocols.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n/impl.clj",1692013156125,"file:/home/gmrworkspace/dashboard/src/metabase/lib/metadata/calculation.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/dependency.cljc",1689946139000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/leaf.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check.cljc",1689946177000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/util.cljc",1690286812000,"jar:file:/root/.m2/repository/riddley/riddley/0.2.0/riddley-0.2.0.jar!/riddley/compiler.clj",1689946160000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/predicates.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/types/constants.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/core.memoize/1.0.257/core.memoize-1.0.257.jar!/clojure/core/memoize.clj",1689946178000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/destructure.cljc",1689946170000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/print.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/track.cljc",1689946139000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/aggregation.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/java.classpath/1.0.0/java.classpath-1.0.0.jar!/clojure/java/classpath.clj",1689946162000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/equality.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1689947050000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/impl/regex.cljc",1689946170000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/factory.clj",1689946173000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1689946174000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/experimental.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/walk.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1689946174000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/common.cljc",1690286812000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/core.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/generators.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1689947050000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/generate.clj",1689946173000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/experimental/time.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1689946174000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema.cljc",1692013156305,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/parse.clj",1689946173000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n.clj",1692013156125,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/cfg.clj",1689946146000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/filter/operator.cljc",1690286812000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/core.clj",1689946173000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/impl/util.cljc",1689946170000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/registry.cljc",1689946170000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/gll.clj",1689946146000,"jar:file:/root/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1689947054000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/instrument.clj",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/spec/gen/alpha.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/ref.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/types/isa.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1689946092000,"jar:file:/root/.m2/repository/nano-id/nano-id/1.0.0/nano-id-1.0.0.jar!/nano_id/random.cljc",1689946171000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/filter.cljc",1690286812000,"jar:file:/root/.m2/repository/environ/environ/1.2.0/environ-1.2.0.jar!/environ/core.cljc",1689946163000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/collection.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema.cljc",1692013156125,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/repeat.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/results.cljc",1689946177000,"jar:file:/root/.m2/repository/com/lambdaisland/glogi/1.2.164/glogi-1.2.164.jar!/lambdaisland/glogi.clj",1689947043000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1689946092000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/shared/util/namespaces.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/file.clj",1689946139000,"jar:file:/root/.m2/repository/org/clojure/core.match/1.0.1/core.match-1.0.1.jar!/cljs/core/match.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/spec.alpha/0.3.218/spec.alpha-0.3.218.jar!/clojure/spec/gen/alpha.clj",1689946117000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/join.cljc",1690286812000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/error.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema/macros.clj",1690286812000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/utils.cljc",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/util/malli/registry.cljc",1690286813000,"file:/home/gmrworkspace/dashboard/src/metabase/config.clj",1692013154929,"file:/home/gmrworkspace/dashboard/src/metabase/util/log.clj",1690286813000,"file:/home/gmrworkspace/dashboard/src/metabase/util/malli.cljc",1690286813000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/rose_tree.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1689946174000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/combinators_source.clj",1689946146000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/abnf.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/find.clj",1689946139000,"jar:file:/root/.m2/repository/org/tcrawley/dynapath/1.1.0/dynapath-1.1.0.jar!/dynapath/dynamic_classpath.clj",1689946174000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/temporal_bucketing.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1689946174000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/generate_seq.clj",1689946173000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/mbql_clause.cljc",1690286812000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/util.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/src/metabase/util/jvm.clj",1692013156125],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Functions related to manipulating EXPLICIT joins in MBQL.","^7","metabase/lib/join.cljc","^8",1,"^9",5,"^:",1,"^;",22],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H"],"^I",null,"^J",["^K",[]],"^L","^M","^N",["^ "],"^Q",null,"^R",["^ ","^S","^S","^T","^U","^V","^V","^W","^W","^X","^X","^Y","^W","^Z","^[","^10","^11","^12","^13","^14","^14","^15","^16","~$u","^17","^18","^19","^1:","^X","^1;","^1<","^D","^D","^1=","^1=","^1>","^1>","^1?","^1?","^1@","^1A","^1B","^S","^13","^13","^16","^16","^1C","^1D","^19","^19","^1E","^1F","~$m","^1G","^17","^17","^1H","^1=","^1I","^1J","^1<","^1<","^[","^[","^1K","^1>","^1L","^1M","^1N","^1N","^1A","^1A","^U","^U","^1O","^1P","^1Q","^1Q","^1R","^V","^1S","^1N","^1T","^1U","^1F","^1F","^1D","^1D","^1U","^1U","^11","^11","^1V","^14","^1M","^1M","^1P","^1P","^1J","^1J","^1G","^1G","^1W","^1Q"],"^1X",["^K",["^1Y"]],"~:shadow/js-access-global",["^K",["Error"]],"^1Z",null,"~:defs",["^ ","~$join-clause-method",["^ ","^5",["^ ","^7","metabase/lib/join.cljc","^8",297,"^9",11,"^:",297,"^;",29,"~:arglists",["^21",["~$quote",["^21",[["~$joinable"]]]]],"^6","Convert something to a join clause."],"^L","^4P","^7","metabase/lib/join.cljc","^;",29,"^9",1,"^8",297,"^:",297,"~:tag","^2Y","^>6",["^21",["^>7",["^21",[["^>8"]]]]],"^6","Convert something to a join clause."],"~$current-join-alias",["^ ","~:schema",["~:=>",["~:cat",["~:maybe","~$FieldOrPartialJoin"]],["^>>","~:metabase.lib.schema.common/non-blank-string"]],"~:validate!","id79981","~:protocol-inline",null,"^5",["^ ","^>;",["^><",["^>=",["^>>","^>?"]],["^>>","^>@"]],"^>A","id79981","^7","metabase/lib/join.cljc","^;",28,"^9",10,"~:raw-arglists",["^21",["^>7",["^21",[["~$field-or-join","~:-",["^>>","^>?"]]]]]],"^8",51,"^:",51,"^>6",["^21",["^>7",["^21",[["^>D"]]]]],"^6","Inputs: [field-or-join :- [:maybe FieldOrPartialJoin]]\n  Return: [:maybe :metabase.lib.schema.common/non-blank-string]\n          \n\n  Get the current join alias associated with something, if it has one."],"^L","^6>","^7","metabase/lib/join.cljc","^;",28,"~:method-params",["^21",[["^>D"]]],"~:protocol-impl",null,"~:arglists-meta",["^21",[null,null]],"^9",1,"~:variadic?",false,"^>C",["^21",["^>7",["^21",[["^>D","~:-",["^>>","^>?"]]]]]],"^8",51,"^:",51,"~:max-fixed-arity",1,"~:fn-var",true,"^>6",["^21",["^>7",["^21",[["^>D"]]]]],"^6","Inputs: [field-or-join :- [:maybe FieldOrPartialJoin]]\n  Return: [:maybe :metabase.lib.schema.common/non-blank-string]\n          \n\n  Get the current join alias associated with something, if it has one."],"~$all-joins-expected-columns",["^ ","^>;",["^><",["^>=","~:metabase.lib.schema/query","~:int","~$lib.metadata.calculation/ReturnedColumnsOptions"],"~$lib.metadata.calculation/ColumnsWithUniqueAliases"],"^>A","id80142","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M","^>N"],"^>O"],"^>A","id80142","^7","metabase/lib/join.cljc","^;",36,"^9",10,"^>C",["^21",["^>7",["^21",[["~$query","~:-","^>L","~$stage-number","~:-","^>M","~$options","~:-","^>N"]]]]],"^8",287,"^:",287,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^>R"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int options :- lib.metadata.calculation/ReturnedColumnsOptions]\n  Return: lib.metadata.calculation/ColumnsWithUniqueAliases\n          \n\n  Convenience for calling [[lib.metadata.calculation/returned-columns-method]] on all the joins in a query stage."],"^L","^4G","^7","metabase/lib/join.cljc","^;",36,"^>E",["^21",[["^>P","^>Q","^>R"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^>R","~:-","^>N"]]]]],"^8",287,"~:ret-tag","~$any","^:",287,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^>R"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int options :- lib.metadata.calculation/ReturnedColumnsOptions]\n  Return: lib.metadata.calculation/ColumnsWithUniqueAliases\n          \n\n  Convenience for calling [[lib.metadata.calculation/returned-columns-method]] on all the joins in a query stage."],"~$all-joins-visible-columns",["^ ","^>;",["^><",["^>=","^>L","^>M","~$fn?"],"^>O"],"^>A","id80139","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M","^>V"],"^>O"],"^>A","id80139","^7","metabase/lib/join.cljc","^;",35,"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","~$unique-name-fn","~:-","^>V"]]]]],"^8",273,"^:",273,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^>W"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int unique-name-fn :- fn?]\n  Return: lib.metadata.calculation/ColumnsWithUniqueAliases\n          \n\n  Convenience for calling [[lib.metadata.calculation/visible-columns]] on all of the joins in a query stage."],"^L","^5M","^7","metabase/lib/join.cljc","^;",35,"^>E",["^21",[["^>P","^>Q","^>W"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^>W","~:-","^>V"]]]]],"^8",273,"^>S","^>T","^:",273,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^>W"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int unique-name-fn :- fn?]\n  Return: lib.metadata.calculation/ColumnsWithUniqueAliases\n          \n\n  Convenience for calling [[lib.metadata.calculation/visible-columns]] on all of the joins in a query stage."],"~$join-fields",["^ ","^>;",["^><",["^>=","~$PartialJoin"],["^>>","~:metabase.lib.schema.join/fields"]],"^>A","id80214","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y"],["^>>","^>Z"]],"^>A","id80214","^7","metabase/lib/join.cljc","^;",21,"^9",10,"^>C",["^21",["^>7",["^21",[["~$a-join","~:-","^>Y"]]]]],"^8",538,"^:",538,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: [:maybe :metabase.lib.schema.join/fields]\n          \n\n  Get all join conditions for the given join"],"^L","^5Q","^7","metabase/lib/join.cljc","^;",21,"^>E",["^21",[["^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y"]]]]],"^8",538,"^>S","^>T","^:",538,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: [:maybe :metabase.lib.schema.join/fields]\n          \n\n  Get all join conditions for the given join"],"~$join-conditions",["^ ","^>;",["^><",["^>=","^>Y"],["^>>","~:metabase.lib.schema.join/conditions"]],"^>A","id80213","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y"],["^>>","^?1"]],"^>A","id80213","^7","metabase/lib/join.cljc","^;",25,"^9",10,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y"]]]]],"^8",533,"^:",533,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: [:maybe :metabase.lib.schema.join/conditions]\n          \n\n  Get all join conditions for the given join"],"^L","^5E","^7","metabase/lib/join.cljc","^;",25,"^>E",["^21",[["^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y"]]]]],"^8",533,"^>S","^>T","^:",533,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: [:maybe :metabase.lib.schema.join/conditions]\n          \n\n  Get all join conditions for the given join"],"~$column-from-join-fields",["^ ","^>;",["^><",["^>=","^>L","^>M","~$lib.metadata/ColumnMetadata","^>@"],"~$lib.metadata.calculation/ColumnMetadataWithSource"],"^>A","id80074","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M","^?3","^>@"],"^?4"],"^>A","id80074","~:private",true,"^7","metabase/lib/join.cljc","^;",43,"^9",20,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","~$column-metadata","~:-","^?3","~$join-alias","~:-","^>@"]]]]],"^8",197,"^:",197,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?6","^?7"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int column-metadata :- lib.metadata/ColumnMetadata join-alias :- :metabase.lib.schema.common/non-blank-string]\n  Return: lib.metadata.calculation/ColumnMetadataWithSource\n          \n\n  For a column that comes from a join `:fields` list, add or update metadata as needed, e.g. include join name in the\n  display name."],"^?5",true,"^L","^6I","^7","metabase/lib/join.cljc","^;",43,"^>E",["^21",[["^>P","^>Q","^?6","^?7"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^?6","~:-","^?3","^?7","~:-","^>@"]]]]],"^8",197,"^>S","^>T","^:",197,"^>I",4,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?6","^?7"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int column-metadata :- lib.metadata/ColumnMetadata join-alias :- :metabase.lib.schema.common/non-blank-string]\n  Return: lib.metadata.calculation/ColumnMetadataWithSource\n          \n\n  For a column that comes from a join `:fields` list, add or update metadata as needed, e.g. include join name in the\n  display name."],"~$calculate-join-alias",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",414,"^9",8,"^:",414,"^;",28,"^?5",true,"^>6",["^21",["^>7",["^21",[["^>P","~$joined","~$home-col"]]]]]],"^?5",true,"^L","^63","^7","metabase/lib/join.cljc","^;",28,"^>E",["^21",[["^>P","^?9","^?:"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",414,"^>S",["^K",["^>T","~$string"]],"^:",414,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^?9","^?:"]]]]]],"~$with-join-alias-update-join-fields",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",62,"^9",8,"^:",62,"^;",42,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$join","~$new-alias"]]]]],"^6","Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for the `:field` refs inside `:fields`\n  as needed."],"^?5",true,"^L","^4T","^7","metabase/lib/join.cljc","^;",42,"^>E",["^21",[["^?=","^?>"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",62,"^>S",["^K",[null,"~$clj","^>T"]],"^:",62,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?=","^?>"]]]]],"^6","Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for the `:field` refs inside `:fields`\n  as needed."],"~$generate-unique-name",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",471,"^9",8,"^:",471,"^;",28,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$base-name","~$taken-names"]]]]]],"^?5",true,"^L","^5W","^7","metabase/lib/join.cljc","^;",28,"^>E",["^21",[["^?A","^?B"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",471,"^>S","^>T","^:",471,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?A","^?B"]]]]]],"~$suggested-join-condition",["^ ","^>;",["~:function",["^><",["^>=","~:any","^?E"],["^>>","~:metabase.lib.schema.expression/boolean"]],["^><",["^>=","^>L","^>M","^?E"],["^>>","^?F"]]],"^>A","id80238","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E"],["^>>","^?F"]],["^><",["^>=","^>L","^>M","^?E"],["^>>","^?F"]]],"^>A","id80238","^7","metabase/lib/join.cljc","^;",34,"~:top-fn",["^ ","^>H",false,"~:fixed-arity",3,"^>I",3,"^>E",[["^>P","^>8"],["^>P","^>Q","^>8"]],"^>6",["^21",[["^>P","^>8"],["^>P","^>Q","^>8"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","^>8"],["^>P","~:-","^>L","^>Q","~:-","^>M","^>8"]]]]],"^8",730,"^:",730,"^>6",["^21",["^>7",["^21",[["^>P","^>8"],["^>P","^>Q","^>8"]]]]],"^6","Inputs: ([query joinable]\n           [query :- :metabase.lib.schema/query stage-number :- :int joinable])\n  Return: [:maybe :metabase.lib.schema.expression/boolean]\n          \n\n  Return a suggested default join condition when constructing a join against `joinable`, e.g. a Table, Saved\n  Question, or another query. A suggested condition will be returned if the query stage has a foreign key to the\n  primary key of the thing we're joining (see #31175 for more info); otherwise this will return `nil` if no default\n  condition is suggested."],"^L","^4U","^7","metabase/lib/join.cljc","^;",34,"^?G",["^ ","^>H",false,"^?H",3,"^>I",3,"^>E",[["^>P","^>8"],["^>P","^>Q","^>8"]],"^>6",["^21",[["^>P","^>8"],["^>P","^>Q","^>8"]]],"^>G",["^21",[null,null]]],"^>E",[["^>P","^>8"],["^>P","^>Q","^>8"]],"^>F",null,"^?H",3,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"~:methods",[["^ ","^?H",2,"^>H",false,"^>9","^>T"],["^ ","^?H",3,"^>H",false,"^>9",["^K",[null,"^??","^>T","~$clj-nil"]]]],"^>C",["^21",["^>7",["^21",[["^>P","^>8"],["^>P","~:-","^>L","^>Q","~:-","^>M","^>8"]]]]],"^8",730,"^:",730,"^>I",3,"^>J",true,"^>6",["^21",[["^>P","^>8"],["^>P","^>Q","^>8"]]],"^6","Inputs: ([query joinable]\n           [query :- :metabase.lib.schema/query stage-number :- :int joinable])\n  Return: [:maybe :metabase.lib.schema.expression/boolean]\n          \n\n  Return a suggested default join condition when constructing a join against `joinable`, e.g. a Table, Saved\n  Question, or another query. A suggested condition will be returned if the query stage has a foreign key to the\n  primary key of the thing we're joining (see #31175 for more info); otherwise this will return `nil` if no default\n  condition is suggested."],"~$join-lhs-display-name",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E"],"^>@"],["^><",["^>=","^>L","^>M",["^>>","~$JoinOrJoinable"]],"^>@"]],"^>A","id80248","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E"],"^>@"],["^><",["^>=","^>L","^>M",["^>>","^?L"]],"^>@"]],"^>A","id80248","^7","metabase/lib/join.cljc","^;",31,"^?G",["^ ","^>H",false,"^?H",3,"^>I",3,"^>E",[["^>P","~$join-or-joinable"],["^>P","^>Q","^?M"]],"^>6",["^21",[["^>P","^?M"],["^>P","^>Q","^?M"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","^?M"],["^>P","~:-","^>L","^>Q","~:-","^>M","^?M","~:-",["^>>","^?L"]]]]]],"^8",835,"^:",835,"^>6",["^21",["^>7",["^21",[["^>P","^?M"],["^>P","^>Q","^?M"]]]]],"^6","Inputs: ([query join-or-joinable]\n           [query :- :metabase.lib.schema/query stage-number :- :int join-or-joinable :- [:maybe JoinOrJoinable]])\n  Return: :metabase.lib.schema.common/non-blank-string\n          \n\n  Get the display name for whatever we are joining. See #32015 for screenshot examples.\n\n  The rules, copied from MLv1, are as follows:\n\n  1. If this is the first join in the first stage of a query, and the query uses a `:source-table`, then use the\n     display name for the source Table.\n\n  2. Otherwise use `Previous results`.\n\n  These rules do seem a little goofy -- why don't we use the name of a Saved Question or Model? But we can worry about\n  that in the future. For now, let's just replicate MLv1 behavior.\n\n  This function needs to be usable while we are in the process of constructing a join in the context of a given stage,\n  but also needs to work for rendering existing joins. Pass a join in for existing joins, or something [[Joinable]]\n  for ones we are currently building."],"^L","^57","^7","metabase/lib/join.cljc","^;",31,"^?G",["^ ","^>H",false,"^?H",3,"^>I",3,"^>E",[["^>P","^?M"],["^>P","^>Q","^?M"]],"^>6",["^21",[["^>P","^?M"],["^>P","^>Q","^?M"]]],"^>G",["^21",[null,null]]],"^>E",[["^>P","^?M"],["^>P","^>Q","^?M"]],"^>F",null,"^?H",3,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",2,"^>H",false,"^>9","^>T"],["^ ","^?H",3,"^>H",false,"^>9","^>T"]],"^>C",["^21",["^>7",["^21",[["^>P","^?M"],["^>P","~:-","^>L","^>Q","~:-","^>M","^?M","~:-",["^>>","^?L"]]]]]],"^8",835,"^:",835,"^>I",3,"^>J",true,"^>6",["^21",[["^>P","^?M"],["^>P","^>Q","^?M"]]],"^6","Inputs: ([query join-or-joinable]\n           [query :- :metabase.lib.schema/query stage-number :- :int join-or-joinable :- [:maybe JoinOrJoinable]])\n  Return: :metabase.lib.schema.common/non-blank-string\n          \n\n  Get the display name for whatever we are joining. See #32015 for screenshot examples.\n\n  The rules, copied from MLv1, are as follows:\n\n  1. If this is the first join in the first stage of a query, and the query uses a `:source-table`, then use the\n     display name for the source Table.\n\n  2. Otherwise use `Previous results`.\n\n  These rules do seem a little goofy -- why don't we use the name of a Saved Question or Model? But we can worry about\n  that in the future. For now, let's just replicate MLv1 behavior.\n\n  This function needs to be usable while we are in the process of constructing a join in the context of a given stage,\n  but also needs to work for rendering existing joins. Pass a join in for existing joins, or something [[Joinable]]\n  for ones we are currently building."],"~$fk-column-for",["^ ","^>;",["^><",["^>=","^>L","^>M",["^>>","^?3"]],["^>>","^?3"]],"^>A","id80235","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M",["^>>","^?3"]],["^>>","^?3"]],"^>A","id80235","^?5",true,"^7","metabase/lib/join.cljc","^;",33,"^9",20,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","~$pk-col","~:-",["^>>","^?3"]]]]]],"^8",719,"^:",719,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?O"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int pk-col :- [:maybe lib.metadata/ColumnMetadata]]\n  Return: [:maybe lib.metadata/ColumnMetadata]\n          \n\n  Given a query stage find an FK column that points to the PK `pk-col`."],"^?5",true,"^L","^4@","^7","metabase/lib/join.cljc","^;",33,"^>E",["^21",[["^>P","^>Q","^?O"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^?O","~:-",["^>>","^?3"]]]]]],"^8",719,"^>S",["^K",[null,"^>T","^?J"]],"^:",719,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?O"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int pk-col :- [:maybe lib.metadata/ColumnMetadata]]\n  Return: [:maybe lib.metadata/ColumnMetadata]\n          \n\n  Given a query stage find an FK column that points to the PK `pk-col`."],"^?=",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E"],"^>L"],["^><",["^>=","^>L","^>M","^>Y"],"^>L"]],"^>A","id80204","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E"],"^>L"],["^><",["^>=","^>L","^>M","^>Y"],"^>L"]],"^>A","id80204","^7","metabase/lib/join.cljc","^;",14,"^?G",["^ ","^>H",false,"^?H",3,"^>I",3,"^>E",[["^>P","^>["],["^>P","^>Q","^>["]],"^>6",["^21",[["^>P","^>["],["^>P","^>Q","^>["]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","^>["],["^>P","~:-","^>L","^>Q","~:-","^>M","^>[","~:-","^>Y"]]]]],"^8",502,"^:",502,"^>6",["^21",["^>7",["^21",[["^>P","^>["],["^>P","^>Q","^>["]]]]],"^6","Inputs: ([query a-join]\n           [query :- :metabase.lib.schema/query stage-number :- :int a-join :- PartialJoin])\n  Return: :metabase.lib.schema/query\n          \n\n  Add a join clause to a `query`."],"^L","^55","^7","metabase/lib/join.cljc","^;",14,"^?G",["^ ","^>H",false,"^?H",3,"^>I",3,"^>E",[["^>P","^>["],["^>P","^>Q","^>["]],"^>6",["^21",[["^>P","^>["],["^>P","^>Q","^>["]]],"^>G",["^21",[null,null]]],"^>E",[["^>P","^>["],["^>P","^>Q","^>["]],"^>F",null,"^?H",3,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",2,"^>H",false,"^>9","^>T"],["^ ","^?H",3,"^>H",false,"^>9",["^K",["^??","^>T"]]]],"^>C",["^21",["^>7",["^21",[["^>P","^>["],["^>P","~:-","^>L","^>Q","~:-","^>M","^>[","~:-","^>Y"]]]]],"^8",502,"^:",502,"^>I",3,"^>J",true,"^>6",["^21",[["^>P","^>["],["^>P","^>Q","^>["]]],"^6","Inputs: ([query a-join]\n           [query :- :metabase.lib.schema/query stage-number :- :int a-join :- PartialJoin])\n  Return: :metabase.lib.schema/query\n          \n\n  Add a join clause to a `query`."],"~$similar-names?",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",399,"^9",8,"^:",399,"^;",22,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$name0","~$name1"]]]]],"^6","Checks if `name0` and `name1` are similar.\n  Two names are considered similar if they are the same, one is the plural of the other,\n  or their plurals are equal.\n  This is used to avoid repeating ourselves in situations like when we have a table called\n  PRODUCTS and a field (presumably referring to that table) called PRODUCT."],"^?5",true,"^L","^46","^7","metabase/lib/join.cljc","^;",22,"^>E",["^21",[["^?Q","^?R"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",399,"^>S","~$boolean","^:",399,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?Q","^?R"]]]]],"^6","Checks if `name0` and `name1` are similar.\n  Two names are considered similar if they are the same, one is the plural of the other,\n  or their plurals are equal.\n  This is used to avoid repeating ourselves in situations like when we have a table called\n  PRODUCTS and a field (presumably referring to that table) called PRODUCT."],"~$with-join-conditions",["^ ","^>;",["^><",["^>=","^>Y",["^>>",["~:sequential",["~:or","^?F","~:metabase.lib.schema.common/external-op"]]]],"^>Y"],"^>A","id80155","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y",["^>>",["^?U",["^?V","^?F","^?W"]]]],"^>Y"],"^>A","id80155","^7","metabase/lib/join.cljc","^;",30,"^9",10,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y","~$conditions","~:-",["^>>",["^?U",["^?V","^?F","^?W"]]]]]]]],"^8",337,"~:style/indent",["^20"],"^:",337,"^>6",["^21",["^>7",["^21",[["^>[","^?X"]]]]],"^6","Inputs: [a-join :- PartialJoin conditions :- [:maybe [:sequential [:or :metabase.lib.schema.expression/boolean :metabase.lib.schema.common/external-op]]]]\n  Return: PartialJoin\n          \n\n  Update the `:conditions` (filters) for a Join clause."],"^L","^49","^7","metabase/lib/join.cljc","^;",30,"^>E",["^21",[["^>[","^?X"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y","^?X","~:-",["^>>",["^?U",["^?V","^?F","^?W"]]]]]]]],"^8",337,"^>S",["^K",["^??","^>T","^?J"]],"^?Y",["^20"],"^:",337,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>[","^?X"]]]]],"^6","Inputs: [a-join :- PartialJoin conditions :- [:maybe [:sequential [:or :metabase.lib.schema.expression/boolean :metabase.lib.schema.common/external-op]]]]\n  Return: PartialJoin\n          \n\n  Update the `:conditions` (filters) for a Join clause."],"~$mark-selected-joinable-columns",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",766,"^9",8,"^:",766,"^;",38,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$cols","^>["]]]]],"^6","Mark the column metadatas in `cols` as `:selected` if they appear in `a-join`'s `:fields`."],"^?5",true,"^L","^5=","^7","metabase/lib/join.cljc","^;",38,"^>E",["^21",[["^?[","^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",766,"^>S","^??","^:",766,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?[","^>["]]]]],"^6","Mark the column metadatas in `cols` as `:selected` if they appear in `a-join`'s `:fields`."],"~$join-clause",["^ ","^>;",["^?D",["^><",["^>=","^?E"],"^>Y"],["^><",["^>=","^?E","^?E"],"^>Y"]],"^>A","id80164","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E"],"^>Y"],["^><",["^>=","^?E","^?E"],"^>Y"]],"^>A","id80164","^7","metabase/lib/join.cljc","^;",21,"^?G",["^ ","^>H",false,"^?H",2,"^>I",2,"^>E",[["^>8"],["^>8","^?X"]],"^>6",["^21",[["^>8"],["^>8","^?X"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>8"],["^>8","^?X"]]]]],"^8",346,"^:",346,"^>6",["^21",["^>7",["^21",[["^>8"],["^>8","^?X"]]]]],"^6","Inputs: ([joinable]\n           [joinable conditions])\n  Return: PartialJoin\n          \n\n  Create an MBQL join map from something that can conceptually be joined against. A `Table`? An MBQL or native query? A\n  Saved Question? You should be able to join anything, and this should return a sensible MBQL join map."],"^L","^3A","^7","metabase/lib/join.cljc","^;",21,"^?G",["^ ","^>H",false,"^?H",2,"^>I",2,"^>E",[["^>8"],["^>8","^?X"]],"^>6",["^21",[["^>8"],["^>8","^?X"]]],"^>G",["^21",[null,null]]],"^>E",[["^>8"],["^>8","^?X"]],"^>F",null,"^?H",2,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",1,"^>H",false,"^>9",["^K",[null,"^??","^>T"]]],["^ ","^?H",2,"^>H",false,"^>9",["^K",["^??","^>T","^?J"]]]],"^>C",["^21",["^>7",["^21",[["^>8"],["^>8","^?X"]]]]],"^8",346,"^:",346,"^>I",2,"^>J",true,"^>6",["^21",[["^>8"],["^>8","^?X"]]],"^6","Inputs: ([joinable]\n           [joinable conditions])\n  Return: PartialJoin\n          \n\n  Create an MBQL join map from something that can conceptually be joined against. A `Table`? An MBQL or native query? A\n  Saved Question? You should be able to join anything, and this should return a sensible MBQL join map."],"~$raw-join-strategy",["^ ","^>;",["^><",["^>=","^>Y"],"~:metabase.lib.schema.join/strategy"],"^>A","id80215","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y"],"^@2"],"^>A","id80215","^7","metabase/lib/join.cljc","^;",27,"^9",10,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y"]]]]],"^8",550,"^:",550,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: :metabase.lib.schema.join/strategy\n          \n\n  Get the raw keyword strategy (type) of a given join, e.g. `:left-join` or `:right-join`. This is either the value\n  of the optional `:strategy` key or the default, `:left-join`, if `:strategy` is not specified."],"^L","^3@","^7","metabase/lib/join.cljc","^;",27,"^>E",["^21",[["^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y"]]]]],"^8",550,"^>S",["^K",[null,"^>T"]],"^:",550,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: :metabase.lib.schema.join/strategy\n          \n\n  Get the raw keyword strategy (type) of a given join, e.g. `:left-join` or `:right-join`. This is either the value\n  of the optional `:strategy` key or the default, `:left-join`, if `:strategy` is not specified."],"~$joined-field-desired-alias",["^ ","^>;",["^><",["^>=","^>@","^>@"],"^>@"],"^>A","id80093","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>@","^>@"],"^>@"],"^>A","id80093","^7","metabase/lib/join.cljc","^;",36,"^9",10,"^>C",["^21",["^>7",["^21",[["^?7","~:-","^>@","~$field-name","~:-","^>@"]]]]],"^8",226,"^:",226,"^>6",["^21",["^>7",["^21",[["^?7","^@4"]]]]],"^6","Inputs: [join-alias :- :metabase.lib.schema.common/non-blank-string field-name :- :metabase.lib.schema.common/non-blank-string]\n  Return: :metabase.lib.schema.common/non-blank-string\n          \n\n  Desired alias for a Field that comes from a join, e.g.\n\n    MyJoin__my_field\n\n  You should pass the results thru a unique name function."],"^L","^37","^7","metabase/lib/join.cljc","^;",36,"^>E",["^21",[["^?7","^@4"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^?7","~:-","^>@","^@4","~:-","^>@"]]]]],"^8",226,"^>S","^>T","^:",226,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?7","^@4"]]]]],"^6","Inputs: [join-alias :- :metabase.lib.schema.common/non-blank-string field-name :- :metabase.lib.schema.common/non-blank-string]\n  Return: :metabase.lib.schema.common/non-blank-string\n          \n\n  Desired alias for a Field that comes from a join, e.g.\n\n    MyJoin__my_field\n\n  You should pass the results thru a unique name function."],"~$add-source-and-desired-aliases",["^ ","^>;",["^><",["^>=",["~:map",["~:alias",["^ ","~:error/message","Join must have an alias to determine column aliases!"],"^>@"]],"^>V","^@6"],"^@6"],"^>A","id80100","^>B",null,"^5",["^ ","^>;",["^><",["^>=",["^@6",["^@7",["^ ","^@8","Join must have an alias to determine column aliases!"],"^>@"]],"^>V","^@6"],"^@6"],"^>A","id80100","^?5",true,"^7","metabase/lib/join.cljc","^;",50,"^9",20,"^>C",["^21",["^>7",["^21",[["^?=","~:-",["^@6",["^@7",["^ ","^@8","Join must have an alias to determine column aliases!"],"^>@"]],"^>W","~:-","^>V","~$col","~:-","^@6"]]]]],"^8",236,"^:",236,"^>6",["^21",["^>7",["^21",[["^?=","^>W","^@9"]]]]],"^6","Inputs: [join :- [:map [:alias {:error/message \"Join must have an alias to determine column aliases!\"} :metabase.lib.schema.common/non-blank-string]] unique-name-fn :- fn? col :- :map]\n  Return: :map"],"^?5",true,"^L","^3;","^7","metabase/lib/join.cljc","^;",50,"^>E",["^21",[["^?=","^>W","^@9"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^?=","~:-",["^@6",["^@7",["^ ","^@8","Join must have an alias to determine column aliases!"],"^>@"]],"^>W","~:-","^>V","^@9","~:-","^@6"]]]]],"^8",236,"^>S",["^K",["^??","^>T"]],"^:",236,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?=","^>W","^@9"]]]]],"^6","Inputs: [join :- [:map [:alias {:error/message \"Join must have an alias to determine column aliases!\"} :metabase.lib.schema.common/non-blank-string]] unique-name-fn :- fn? col :- :map]\n  Return: :map"],"~$with-join-alias-update-join",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",137,"^9",8,"^:",137,"^;",35,"^?5",true,"^>6",["^21",["^>7",["^21",[["^?=","^?>"]]]]],"^6","Impl for [[with-join-alias]] for a join."],"^?5",true,"^L","^2X","^7","metabase/lib/join.cljc","^;",35,"^>E",["^21",[["^?=","^?>"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",137,"^>S",["^K",[null,"^??","^>T"]],"^:",137,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?=","^?>"]]]]],"^6","Impl for [[with-join-alias]] for a join."],"^>Y",["^ ","^5",["^ ","^7","metabase/lib/join.cljc","^8",38,"^9",16,"^:",38,"^;",27,"^?5",true],"^?5",true,"^L","^6C","^7","metabase/lib/join.cljc","^;",27,"^9",1,"^8",38,"^:",38,"^>9","~$cljs.core/IVector","^6","A join that may not yet have an `:alias` or `:conditions`."],"^>?",["^ ","^5",["^ ","^7","metabase/lib/join.cljc","^8",45,"^9",16,"^:",45,"^;",34,"^?5",true],"^?5",true,"^L","^2V","^7","metabase/lib/join.cljc","^;",34,"^9",1,"^8",45,"^:",45,"^>9","^@;"],"~$with-join-fields",["^ ","^>;",["^><",["^>=","^>Y",["^>>",["^?V",["~:enum","~:all","~:none"],["^?U","~$some?"]]]],"^>Y"],"^>A","id80171","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y",["^>>",["^?V",["^@=","^@>","^@?"],["^?U","^@@"]]]],"^>Y"],"^>A","id80171","^7","metabase/lib/join.cljc","^;",26,"^9",10,"^>C",["^21",["^>7",["^21",[["^>8","~:-","^>Y","~$fields","~:-",["^>>",["^?V",["^@=","^@>","^@?"],["^?U","^@@"]]]]]]]],"^8",357,"^:",357,"^>6",["^21",["^>7",["^21",[["^>8","^@A"]]]]],"^6","Inputs: [joinable :- PartialJoin fields :- [:maybe [:or [:enum :all :none] [:sequential some?]]]]\n  Return: PartialJoin\n          \n\n  Update a join (or a function that will return a join) to include `:fields`, either `:all`, `:none`, or a sequence of\n  references."],"^L","^6A","^7","metabase/lib/join.cljc","^;",26,"^>E",["^21",[["^>8","^@A"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>8","~:-","^>Y","^@A","~:-",["^>>",["^?V",["^@=","^@>","^@?"],["^?U","^@@"]]]]]]]],"^8",357,"^>S",["^K",["^??","^>T","^?J"]],"^:",357,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>8","^@A"]]]]],"^6","Inputs: [joinable :- PartialJoin fields :- [:maybe [:or [:enum :all :none] [:sequential some?]]]]\n  Return: PartialJoin\n          \n\n  Update a join (or a function that will return a join) to include `:fields`, either `:all`, `:none`, or a sequence of\n  references."],"^?L",["^ ","^5",["^ ","^7","metabase/lib/join.cljc","^8",791,"^9",16,"^:",791,"^;",30,"^?5",true],"^?5",true,"^L","^2G","^7","metabase/lib/join.cljc","^;",30,"^9",1,"^8",791,"^:",791,"^>9","^@;"],"~$JoinWithOptionalAlias",["^ ","^5",["^ ","^7","metabase/lib/join.cljc","^8",30,"^9",16,"^:",30,"^;",37,"^?5",true],"^?5",true,"^L","^6<","^7","metabase/lib/join.cljc","^;",37,"^9",1,"^8",30,"^:",30,"^>9","^@;","^6","A Join that may not yet have an `:alias`, which is normally required; [[join]] accepts this and will add a default\n  alias if one is not present."],"~$add-alias-to-condition",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",438,"^9",8,"^:",438,"^;",30,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$metadata-providerable","~$condition","^?7","~$home-refs","~$join-refs"]]]]]],"^?5",true,"^L","^60","^7","metabase/lib/join.cljc","^;",30,"^>E",["^21",[["^@D","^@E","^?7","^@F","^@G"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",438,"^>S","^>T","^:",438,"^>I",5,"^>J",true,"^>6",["^21",["^>7",["^21",[["^@D","^@E","^?7","^@F","^@G"]]]]]],"~$join-condition-rhs-columns",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E","^?E"],["^?U","^?3"]],["^><",["^>=","^>L","^>M","^?E",["^>>","^?3"]],["^?U","^?3"]]],"^>A","id80228","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E","^?E"],["^?U","^?3"]],["^><",["^>=","^>L","^>M","^?E",["^>>","^?3"]],["^?U","^?3"]]],"^>A","id80228","^7","metabase/lib/join.cljc","^;",36,"^?G",["^ ","^>H",false,"^?H",4,"^>I",4,"^>E",[["^>P","^>8","~$lhs-column-or-nil"],["^>P","^>Q","^>8","~$_lhs-column-or-nil"]],"^>6",["^21",[["^>P","^>8","^@I"],["^>P","^>Q","^>8","^@J"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","^>8","^@I"],["^>P","~:-","^>L","^>Q","~:-","^>M","^>8","^@J","~:-",["^>>","^?3"]]]]]],"^8",673,"^:",673,"^>6",["^21",["^>7",["^21",[["^>P","^>8","^@I"],["^>P","^>Q","^>8","^@J"]]]]],"^6","Inputs: ([query joinable lhs-column-or-nil]\n           [query :- :metabase.lib.schema/query stage-number :- :int joinable _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Get a sequence of columns that can be used as the right-hand-side (target column) in a join condition. This column\n  is the one that belongs to the thing being joined, `joinable`, which can be something like a\n  Table ([[metabase.lib.metadata/TableMetadata]]), Saved Question/Model ([[metabase.lib.metadata/CardMetadata]]),\n  another query, etc. -- anything you can pass to [[join-clause]].\n\n  If the lhs-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n  pass in the chosen LHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n\n  Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns."],"^L","^5Z","^7","metabase/lib/join.cljc","^;",36,"^?G",["^ ","^>H",false,"^?H",4,"^>I",4,"^>E",[["^>P","^>8","^@I"],["^>P","^>Q","^>8","^@J"]],"^>6",["^21",[["^>P","^>8","^@I"],["^>P","^>Q","^>8","^@J"]]],"^>G",["^21",[null,null]]],"^>E",[["^>P","^>8","^@I"],["^>P","^>Q","^>8","^@J"]],"^>F",null,"^?H",4,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",3,"^>H",false,"^>9","^>T"],["^ ","^?H",4,"^>H",false,"^>9","^45"]],"^>C",["^21",["^>7",["^21",[["^>P","^>8","^@I"],["^>P","~:-","^>L","^>Q","~:-","^>M","^>8","^@J","~:-",["^>>","^?3"]]]]]],"^8",673,"^:",673,"^>I",4,"^>J",true,"^>6",["^21",[["^>P","^>8","^@I"],["^>P","^>Q","^>8","^@J"]]],"^6","Inputs: ([query joinable lhs-column-or-nil]\n           [query :- :metabase.lib.schema/query stage-number :- :int joinable _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Get a sequence of columns that can be used as the right-hand-side (target column) in a join condition. This column\n  is the one that belongs to the thing being joined, `joinable`, which can be something like a\n  Table ([[metabase.lib.metadata/TableMetadata]]), Saved Question/Model ([[metabase.lib.metadata/CardMetadata]]),\n  another query, etc. -- anything you can pass to [[join-clause]].\n\n  If the lhs-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n  pass in the chosen LHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n\n  Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns."],"~$join-condition-lhs-columns",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E","^?E"],["^?U","^?3"]],["^><",["^>=","^>L","^>M",["^>>","~:metabase.lib.schema.join/join"],["^>>","^?3"]],["^?U","^?3"]]],"^>A","id80225","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E","^?E"],["^?U","^?3"]],["^><",["^>=","^>L","^>M",["^>>","^@L"],["^>>","^?3"]],["^?U","^?3"]]],"^>A","id80225","^7","metabase/lib/join.cljc","^;",36,"^?G",["^ ","^>H",false,"^?H",4,"^>I",4,"^>E",[["^>P","~$existing-join-or-nil","~$rhs-column-or-nil"],["^>P","^>Q","^@M","~$_rhs-column-or-nil"]],"^>6",["^21",[["^>P","^@M","^@N"],["^>P","^>Q","^@M","^@O"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","^@M","^@N"],["^>P","~:-","^>L","^>Q","~:-","^>M","^@M","~:-",["^>>","^@L"],"^@O","~:-",["^>>","^?3"]]]]]],"^8",629,"^:",629,"^>6",["^21",["^>7",["^21",[["^>P","^@M","^@N"],["^>P","^>Q","^@M","^@O"]]]]],"^6","Inputs: ([query existing-join-or-nil rhs-column-or-nil]\n           [query :- :metabase.lib.schema/query stage-number :- :int existing-join-or-nil :- [:maybe :metabase.lib.schema.join/join] _rhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Get a sequence of columns that can be used as the left-hand-side (source column) in a join condition. This column\n  is the one that comes from the source Table/Card/previous stage of the query or a previous join.\n\n  If you are changing the LHS of a condition for an existing join, pass in that existing join as\n  `existing-join-or-nil` so we can filter out the columns added by it (it doesn't make sense to present the columns\n  added by a join as options for its own LHS) or added by later joins (joins can only depend on things from previous\n  joins). Otherwise pass `nil` when building a new join. See #32005 for more info.\n\n  If the right-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n  pass in the chosen RHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n\n  Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns.\n\n  Unlike most other things that return columns, implicitly-joinable columns ARE NOT returned here."],"^L","^67","^7","metabase/lib/join.cljc","^;",36,"^?G",["^ ","^>H",false,"^?H",4,"^>I",4,"^>E",[["^>P","^@M","^@N"],["^>P","^>Q","^@M","^@O"]],"^>6",["^21",[["^>P","^@M","^@N"],["^>P","^>Q","^@M","^@O"]]],"^>G",["^21",[null,null]]],"^>E",[["^>P","^@M","^@N"],["^>P","^>Q","^@M","^@O"]],"^>F",null,"^?H",4,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",3,"^>H",false,"^>9","^>T"],["^ ","^?H",4,"^>H",false,"^>9","^45"]],"^>C",["^21",["^>7",["^21",[["^>P","^@M","^@N"],["^>P","~:-","^>L","^>Q","~:-","^>M","^@M","~:-",["^>>","^@L"],"^@O","~:-",["^>>","^?3"]]]]]],"^8",629,"^:",629,"^>I",4,"^>J",true,"^>6",["^21",[["^>P","^@M","^@N"],["^>P","^>Q","^@M","^@O"]]],"^6","Inputs: ([query existing-join-or-nil rhs-column-or-nil]\n           [query :- :metabase.lib.schema/query stage-number :- :int existing-join-or-nil :- [:maybe :metabase.lib.schema.join/join] _rhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Get a sequence of columns that can be used as the left-hand-side (source column) in a join condition. This column\n  is the one that comes from the source Table/Card/previous stage of the query or a previous join.\n\n  If you are changing the LHS of a condition for an existing join, pass in that existing join as\n  `existing-join-or-nil` so we can filter out the columns added by it (it doesn't make sense to present the columns\n  added by a join as options for its own LHS) or added by later joins (joins can only depend on things from previous\n  joins). Otherwise pass `nil` when building a new join. See #32005 for more info.\n\n  If the right-hand-side column has already been chosen (they can be chosen in any order in the Query Builder UI),\n  pass in the chosen RHS column. In the future, this may be used to restrict results to compatible columns. (See #31174)\n\n  Results will be returned in a 'somewhat smart' order with PKs and FKs returned before other columns.\n\n  Unlike most other things that return columns, implicitly-joinable columns ARE NOT returned here."],"~$add-alias-to-join-refs",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",430,"^9",8,"^:",430,"^;",30,"^?5",true,"^>6",["^21",["^>7",["^21",[["^@D","~$form","^?7","^@G"]]]]]],"^?5",true,"^L","^56","^7","metabase/lib/join.cljc","^;",30,"^>E",["^21",[["^@D","^@Q","^?7","^@G"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",430,"^>S","^>T","^:",430,"^>I",4,"^>J",true,"^>6",["^21",["^>7",["^21",[["^@D","^@Q","^?7","^@G"]]]]]],"~$pk-column",["^ ","^>;",["^><",["^>=","^>L","^>M","^?E"],["^>>","^?3"]],"^>A","id80234","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M","^?E"],["^>>","^?3"]],"^>A","id80234","^?5",true,"^7","metabase/lib/join.cljc","^;",29,"^9",20,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","~$x"]]]]],"^8",711,"^:",711,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","~$x"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int x]\n  Return: [:maybe lib.metadata/ColumnMetadata]\n          \n\n  Given something `x` (e.g. a Table metadata) find the PK column."],"^?5",true,"^L","^3?","^7","metabase/lib/join.cljc","^;",29,"^>E",["^21",[["^>P","^>Q","~$x"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","~$x"]]]]],"^8",711,"^>S",["^K",[null,"^>T"]],"^:",711,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","~$x"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int x]\n  Return: [:maybe lib.metadata/ColumnMetadata]\n          \n\n  Given something `x` (e.g. a Table metadata) find the PK column."],"~$select-home-column",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",374,"^9",8,"^:",374,"^;",26,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$home-cols","~$cond-fields"]]]]]],"^?5",true,"^L","^6=","^7","metabase/lib/join.cljc","^;",26,"^>E",["^21",[["^@T","^@U"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",374,"^>S",["^K",[null,"^>T","^?J"]],"^:",374,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^@T","^@U"]]]]]],"~$resolve-join",["^ ","^>;",["^><",["^>=","^>L","^>M","^>@"],"^@L"],"^>A","id80061","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M","^>@"],"^@L"],"^>A","id80061","^7","metabase/lib/join.cljc","^;",22,"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^?7","~:-","^>@"]]]]],"^8",162,"^:",162,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?7"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int join-alias :- :metabase.lib.schema.common/non-blank-string]\n  Return: :metabase.lib.schema.join/join\n          \n\n  Resolve a join with a specific `join-alias`."],"^L","^4H","^7","metabase/lib/join.cljc","^;",22,"^>E",["^21",[["^>P","^>Q","^?7"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^?7","~:-","^>@"]]]]],"^8",162,"^>S",["^K",[null,"^>T"]],"^:",162,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?7"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int join-alias :- :metabase.lib.schema.common/non-blank-string]\n  Return: :metabase.lib.schema.join/join\n          \n\n  Resolve a join with a specific `join-alias`."],"~$joinable-columns",["^ ","^>;",["^><",["^>=","^>L","^>M","^?L"],["^?U","^?3"]],"^>A","id80246","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M","^?L"],["^?U","^?3"]],"^>A","id80246","^7","metabase/lib/join.cljc","^;",26,"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^?M","~:-","^?L"]]]]],"^8",799,"^:",799,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?M"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int join-or-joinable :- JoinOrJoinable]\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Return information about the fields that you can pass to [[with-join-fields]] when constructing a join against\n  something [[Joinable]] (i.e., a Table or Card) or manipulating an existing join. When passing in a join, currently\n  selected columns (those in the join's `:fields`) will include `:selected true` information."],"^L","^4[","^7","metabase/lib/join.cljc","^;",26,"^>E",["^21",[["^>P","^>Q","^?M"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^?M","~:-","^?L"]]]]],"^8",799,"^>S",["^K",["^??","^>T"]],"^:",799,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?M"]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int join-or-joinable :- JoinOrJoinable]\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Return information about the fields that you can pass to [[with-join-fields]] when constructing a join against\n  something [[Joinable]] (i.e., a Table or Card) or manipulating an existing join. When passing in a join, currently\n  selected columns (those in the join's `:fields`) will include `:selected true` information."],"~$raw-join-strategy->strategy-option",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",543,"^9",8,"^:",543,"^;",42,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$raw-strategy"]]]]]],"^?5",true,"^L","^3B","^7","metabase/lib/join.cljc","^;",42,"^>E",["^21",[["^@Y"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",543,"^>S",["^K",["^>T","^?J"]],"^:",543,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^@Y"]]]]]],"~$joins",["^ ","^>;",["^?D",["^><",["^>=","^?E"],["^>>","~:metabase.lib.schema.join/joins"]],["^><",["^>=","^>L","^>M"],["^>>","^@["]]],"^>A","id80207","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E"],["^>>","^@["]],["^><",["^>=","^>L","^>M"],["^>>","^@["]]],"^>A","id80207","^7","metabase/lib/join.cljc","^;",15,"^?G",["^ ","^>H",false,"^?H",2,"^>I",2,"^>E",[["^>P"],["^>P","^>Q"]],"^>6",["^21",[["^>P"],["^>P","^>Q"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P"],["^>P","~:-","^>L","^>Q","~:-","^>M"]]]]],"^8",514,"^:",514,"^>6",["^21",["^>7",["^21",[["^>P"],["^>P","^>Q"]]]]],"^6","Inputs: ([query]\n           [query :- :metabase.lib.schema/query stage-number :- :int])\n  Return: [:maybe :metabase.lib.schema.join/joins]\n          \n\n  Get all joins in a specific `stage` of a `query`. If `stage` is unspecified, returns joins in the final stage of the\n  query."],"^L","^3E","^7","metabase/lib/join.cljc","^;",15,"^?G",["^ ","^>H",false,"^?H",2,"^>I",2,"^>E",[["^>P"],["^>P","^>Q"]],"^>6",["^21",[["^>P"],["^>P","^>Q"]]],"^>G",["^21",[null,null]]],"^>E",[["^>P"],["^>P","^>Q"]],"^>F",null,"^?H",2,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",1,"^>H",false,"^>9","^>T"],["^ ","^?H",2,"^>H",false,"^>9",["^K",[null,"^?J"]]]],"^>C",["^21",["^>7",["^21",[["^>P"],["^>P","~:-","^>L","^>Q","~:-","^>M"]]]]],"^8",514,"^:",514,"^>I",2,"^>J",true,"^>6",["^21",[["^>P"],["^>P","^>Q"]]],"^6","Inputs: ([query]\n           [query :- :metabase.lib.schema/query stage-number :- :int])\n  Return: [:maybe :metabase.lib.schema.join/joins]\n          \n\n  Get all joins in a specific `stage` of a `query`. If `stage` is unspecified, returns joins in the final stage of the\n  query."],"~$available-join-strategies",["^ ","^>;",["^?D",["^><",["^>=","^?E"],["^?U","~:metabase.lib.schema.join/strategy.option"]],["^><",["^>=","^>L","^>M"],["^?U","^A1"]]],"^>A","id80219","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E"],["^?U","^A1"]],["^><",["^>=","^>L","^>M"],["^?U","^A1"]]],"^>A","id80219","^7","metabase/lib/join.cljc","^;",35,"^?G",["^ ","^>H",false,"^?H",2,"^>I",2,"^>E",[["^>P"],["^>P","~$_stage-number"]],"^>6",["^21",[["^>P"],["^>P","^A2"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P"],["^>P","~:-","^>L","^A2","~:-","^>M"]]]]],"^8",571,"^:",571,"^>6",["^21",["^>7",["^21",[["^>P"],["^>P","^A2"]]]]],"^6","Inputs: ([query]\n           [query :- :metabase.lib.schema/query _stage-number :- :int])\n  Return: [:sequential :metabase.lib.schema.join/strategy.option]\n          \n\n  Get available join strategies for the current Database (based on the Database's\n  supported [[metabase.driver/driver-features]]) as raw keywords like `:left-join`."],"^L","^6G","^7","metabase/lib/join.cljc","^;",35,"^?G",["^ ","^>H",false,"^?H",2,"^>I",2,"^>E",[["^>P"],["^>P","^A2"]],"^>6",["^21",[["^>P"],["^>P","^A2"]]],"^>G",["^21",[null,null]]],"^>E",[["^>P"],["^>P","^A2"]],"^>F",null,"^?H",2,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",1,"^>H",false,"^>9","^>T"],["^ ","^?H",2,"^>H",false,"^>9","^>T"]],"^>C",["^21",["^>7",["^21",[["^>P"],["^>P","~:-","^>L","^A2","~:-","^>M"]]]]],"^8",571,"^:",571,"^>I",2,"^>J",true,"^>6",["^21",[["^>P"],["^>P","^A2"]]],"^6","Inputs: ([query]\n           [query :- :metabase.lib.schema/query _stage-number :- :int])\n  Return: [:sequential :metabase.lib.schema.join/strategy.option]\n          \n\n  Get available join strategies for the current Database (based on the Database's\n  supported [[metabase.driver/driver-features]]) as raw keywords like `:left-join`."],"~$first-join?",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",816,"^9",8,"^:",816,"^;",19,"^?5",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?M"]]]]],"^6","Whether a `join-or-joinable` is (or will be) the first join in a stage of a query.\n\n  If a join is passed, we need to check whether it's the first join in the first stage of a source-table query or\n  not.\n\n  New joins get appended after any existing ones, so it would be safe to assume that if there are any other joins in\n  the current stage, this **will not** be the first join in the stage."],"^?5",true,"^L","^53","^7","metabase/lib/join.cljc","^;",19,"^>E",["^21",[["^>P","^>Q","^?M"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",816,"^>S",["^K",["^?S","^?J"]],"^:",816,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^?M"]]]]],"^6","Whether a `join-or-joinable` is (or will be) the first join in a stage of a query.\n\n  If a join is passed, we need to check whether it's the first join in the first stage of a source-table query or\n  not.\n\n  New joins get appended after any existing ones, so it would be safe to assume that if there are any other joins in\n  the current stage, this **will not** be the first join in the stage."],"~$Joinable",["^ ","^5",["^ ","^7","metabase/lib/join.cljc","^8",745,"^9",16,"^:",745,"^;",24,"^?5",true],"^?5",true,"^L","^6:","^7","metabase/lib/join.cljc","^;",24,"^9",1,"^8",745,"^:",745,"^>9","^@;"],"~$join-strategy",["^ ","^>;",["^><",["^>=","^>Y"],"^A1"],"^>A","id80216","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y"],"^A1"],"^>A","id80216","^7","metabase/lib/join.cljc","^;",23,"^9",10,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y"]]]]],"^8",556,"^:",556,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: :metabase.lib.schema.join/strategy.option\n          \n\n  Get the strategy (type) of a given join, as a `:option/join.strategy` map. If `:stategy` is unspecified, returns\n  the default, left join."],"^L","^2Q","^7","metabase/lib/join.cljc","^;",23,"^>E",["^21",[["^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y"]]]]],"^8",556,"^>S",["^K",["^>T","^?J"]],"^:",556,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>["]]]]],"^6","Inputs: [a-join :- PartialJoin]\n  Return: :metabase.lib.schema.join/strategy.option\n          \n\n  Get the strategy (type) of a given join, as a `:option/join.strategy` map. If `:stategy` is unspecified, returns\n  the default, left join."],"~$with-join-alias-update-join-conditions",["^ ","^>;",["^><",["^>=","^>Y",["^>>","^>@"],["^>>","^>@"]],"^>Y"],"^>A","id80031","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y",["^>>","^>@"],["^>>","^>@"]],"^>Y"],"^>A","id80031","^?5",true,"^7","metabase/lib/join.cljc","^;",58,"^9",20,"^>C",["^21",["^>7",["^21",[["^?=","~:-","^>Y","~$old-alias","~:-",["^>>","^>@"],"^?>","~:-",["^>>","^>@"]]]]]],"^8",105,"^:",105,"^>6",["^21",["^>7",["^21",[["^?=","^A7","^?>"]]]]],"^6","Inputs: [join :- PartialJoin old-alias :- [:maybe :metabase.lib.schema.common/non-blank-string] new-alias :- [:maybe :metabase.lib.schema.common/non-blank-string]]\n  Return: PartialJoin\n          \n\n  Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for inside the `:conditions` of the\n  join.\n\n  If `old-alias` is specified, uses [[metabase.mbql.util.match]] to update all the `:field` references using the old\n  alias.\n\n  If `old-alias` is `nil`, updates the RHS of all 'standard' conditions (binary filter clauses with two `:field` refs as\n  args, e.g. the kind you'd get if you were using [[join-condition-operators]] and the like to create them). This\n  currently doesn't handle more complex filter clauses that were created without the 'normal' MLv2 functions used by\n  the frontend; we can add this in the future if we need it."],"^?5",true,"^L","^4W","^7","metabase/lib/join.cljc","^;",58,"^>E",["^21",[["^?=","^A7","^?>"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^?=","~:-","^>Y","^A7","~:-",["^>>","^>@"],"^?>","~:-",["^>>","^>@"]]]]]],"^8",105,"^>S",["^K",[null,"^??","^>T"]],"^:",105,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?=","^A7","^?>"]]]]],"^6","Inputs: [join :- PartialJoin old-alias :- [:maybe :metabase.lib.schema.common/non-blank-string] new-alias :- [:maybe :metabase.lib.schema.common/non-blank-string]]\n  Return: PartialJoin\n          \n\n  Impl for [[with-join-alias]] for a join: recursively update the `:join-alias` for inside the `:conditions` of the\n  join.\n\n  If `old-alias` is specified, uses [[metabase.mbql.util.match]] to update all the `:field` references using the old\n  alias.\n\n  If `old-alias` is `nil`, updates the RHS of all 'standard' conditions (binary filter clauses with two `:field` refs as\n  args, e.g. the kind you'd get if you were using [[join-condition-operators]] and the like to create them). This\n  currently doesn't handle more complex filter clauses that were created without the 'normal' MLv2 functions used by\n  the frontend; we can add this in the future if we need it."],"~$standard-join-condition-rhs",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",88,"^9",8,"^:",88,"^;",35,"^?5",true,"^>6",["^21",["^>7",["^21",[["^@E"]]]]],"^6","If `condition` is a [[standard-join-condition?]], return the RHS."],"^?5",true,"^L","^31","^7","metabase/lib/join.cljc","^;",35,"^>E",["^21",[["^@E"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",88,"^>S",["^K",[null,"^>T","^?J"]],"^:",88,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^@E"]]]]],"^6","If `condition` is a [[standard-join-condition?]], return the RHS."],"~$add-join-alias-to-joinable-columns",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",757,"^9",8,"^:",757,"^;",42,"^?5",true,"^>6",["^21",["^>7",["^21",[["^?[","^>["]]]]]],"^?5",true,"^L","^4D","^7","metabase/lib/join.cljc","^;",42,"^>E",["^21",[["^?[","^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",757,"^>S","^??","^:",757,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?[","^>["]]]]]],"~$with-join-conditions-add-alias-to-rhses",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",324,"^9",8,"^:",324,"^;",47,"^?5",true,"^>6",["^21",["^>7",["^21",[["^?X","^?7"]]]]],"^6","Add `join-alias` to the RHS of all [[standard-join-condition?]] `conditions` that don't already have a `:join-alias`.\n  If an RHS already has a `:join-alias`, don't second guess what was already explicitly specified."],"^?5",true,"^L","^5H","^7","metabase/lib/join.cljc","^;",47,"^>E",["^21",[["^?X","^?7"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",324,"^>S",["^K",[null,"^??"]],"^:",324,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^?X","^?7"]]]]],"^6","Add `join-alias` to the RHS of all [[standard-join-condition?]] `conditions` that don't already have a `:join-alias`.\n  If an RHS already has a `:join-alias`, don't second guess what was already explicitly specified."],"~$join-condition-operators",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E","^?E"],["^?U","~:metabase.lib.schema.filter/operator"]],["^><",["^>=","^>L","^>M",["^>>","^?3"],["^>>","^?3"]],["^?U","^A<"]]],"^>A","id80231","^>B",null,"^5",["^ ","^>;",["^?D",["^><",["^>=","^?E","^?E","^?E"],["^?U","^A<"]],["^><",["^>=","^>L","^>M",["^>>","^?3"],["^>>","^?3"]],["^?U","^A<"]]],"^>A","id80231","^7","metabase/lib/join.cljc","^;",34,"^?G",["^ ","^>H",false,"^?H",4,"^>I",4,"^>E",[["^>P","^@I","^@N"],["~$_query","^A2","^@J","^@O"]],"^>6",["^21",[["^>P","^@I","^@N"],["^A=","^A2","^@J","^@O"]]],"^>G",["^21",[null,null]]],"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","^@I","^@N"],["^A=","~:-","^>L","^A2","~:-","^>M","^@J","~:-",["^>>","^?3"],"^@O","~:-",["^>>","^?3"]]]]]],"^8",696,"^:",696,"^>6",["^21",["^>7",["^21",[["^>P","^@I","^@N"],["^A=","^A2","^@J","^@O"]]]]],"^6","Inputs: ([query lhs-column-or-nil rhs-column-or-nil]\n           [_query :- :metabase.lib.schema/query _stage-number :- :int _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata] _rhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n  Return: [:sequential :metabase.lib.schema.filter/operator]\n          \n\n  Return a sequence of valid filter clause operators that can be used to build a join condition. In the Query Builder\n  UI, this can be chosen at any point before or after choosing the LHS and RHS. Invalid options are not currently\n  filtered out based on values of the LHS or RHS, but in the future we can add this -- see #31174."],"^L","^4Z","^7","metabase/lib/join.cljc","^;",34,"^?G",["^ ","^>H",false,"^?H",4,"^>I",4,"^>E",[["^>P","^@I","^@N"],["^A=","^A2","^@J","^@O"]],"^>6",["^21",[["^>P","^@I","^@N"],["^A=","^A2","^@J","^@O"]]],"^>G",["^21",[null,null]]],"^>E",[["^>P","^@I","^@N"],["^A=","^A2","^@J","^@O"]],"^>F",null,"^?H",4,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^?I",[["^ ","^?H",3,"^>H",false,"^>9","^>T"],["^ ","^?H",4,"^>H",false,"^>9","^@;"]],"^>C",["^21",["^>7",["^21",[["^>P","^@I","^@N"],["^A=","~:-","^>L","^A2","~:-","^>M","^@J","~:-",["^>>","^?3"],"^@O","~:-",["^>>","^?3"]]]]]],"^8",696,"^:",696,"^>I",4,"^>J",true,"^>6",["^21",[["^>P","^@I","^@N"],["^A=","^A2","^@J","^@O"]]],"^6","Inputs: ([query lhs-column-or-nil rhs-column-or-nil]\n           [_query :- :metabase.lib.schema/query _stage-number :- :int _lhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata] _rhs-column-or-nil :- [:maybe lib.metadata/ColumnMetadata]])\n  Return: [:sequential :metabase.lib.schema.filter/operator]\n          \n\n  Return a sequence of valid filter clause operators that can be used to build a join condition. In the Query Builder\n  UI, this can be chosen at any point before or after choosing the LHS and RHS. Invalid options are not currently\n  filtered out based on values of the LHS or RHS, but in the future we can add this -- see #31174."],"~$implicit-join-name",["^ ","^>;",["^><",["^>=","^>@","^>@"],"^>@"],"^>A","id80212","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>@","^>@"],"^>@"],"^>A","id80212","^7","metabase/lib/join.cljc","^;",28,"^9",10,"^>C",["^21",["^>7",["^21",[["~$table-name","~:-","^>@","~$source-field-id-name","~:-","^>@"]]]]],"^8",523,"^:",523,"^>6",["^21",["^>7",["^21",[["^A?","^A@"]]]]],"^6","Inputs: [table-name :- :metabase.lib.schema.common/non-blank-string source-field-id-name :- :metabase.lib.schema.common/non-blank-string]\n  Return: :metabase.lib.schema.common/non-blank-string\n          \n\n  Name for an implicit join against `table-name` via an FK field, e.g.\n\n    CATEGORIES__via__CATEGORY_ID\n\n  You should make sure this gets ran thru a unique-name fn."],"^L","^3:","^7","metabase/lib/join.cljc","^;",28,"^>E",["^21",[["^A?","^A@"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^A?","~:-","^>@","^A@","~:-","^>@"]]]]],"^8",523,"^>S","^>T","^:",523,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^A?","^A@"]]]]],"^6","Inputs: [table-name :- :metabase.lib.schema.common/non-blank-string source-field-id-name :- :metabase.lib.schema.common/non-blank-string]\n  Return: :metabase.lib.schema.common/non-blank-string\n          \n\n  Name for an implicit join against `table-name` via an FK field, e.g.\n\n    CATEGORIES__via__CATEGORY_ID\n\n  You should make sure this gets ran thru a unique-name fn."],"~$strip-id",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",395,"^9",8,"^:",395,"^;",16,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$s"]]]]]],"^?5",true,"^L","^39","^7","metabase/lib/join.cljc","^;",16,"^>E",["^21",[["~$s"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",395,"^>S",["^K",["^?;","^?J"]],"^:",395,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["~$s"]]]]]],"~$join?",["^ ","^>B",null,"^5",["^ ","^7","metabase/lib/join.cljc","^8",796,"^9",8,"^:",796,"^;",13,"^?5",true,"^>6",["^21",["^>7",["^21",[["~$x"]]]]]],"^?5",true,"^L","^3>","^7","metabase/lib/join.cljc","^;",13,"^>E",["^21",[["~$x"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^8",796,"^>S","^?S","^:",796,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["~$x"]]]]]],"~$with-join-alias",["^ ","^>;",["^><",["^>=","^>?",["^>>","^>@"]],"^>?"],"^>A","id80058","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>?",["^>>","^>@"]],"^>?"],"^>A","id80058","^7","metabase/lib/join.cljc","^;",25,"^9",10,"^>C",["^21",["^>7",["^21",[["^>D","~:-","^>?","^?7","~:-",["^>>","^>@"]]]]]],"^8",146,"^?Y",["^20"],"^:",146,"^>6",["^21",["^>7",["^21",[["^>D","^?7"]]]]],"^6","Inputs: [field-or-join :- FieldOrPartialJoin join-alias :- [:maybe :metabase.lib.schema.common/non-blank-string]]\n  Return: FieldOrPartialJoin\n          \n\n  Add OR REMOVE a specific `join-alias` to `field-or-join`, which is either a `:field`/Field metadata, or a join map.\n  Does not recursively update other references (yet; we can add this in the future)."],"^L","^3J","^7","metabase/lib/join.cljc","^;",25,"^>E",["^21",[["^>D","^?7"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>D","~:-","^>?","^?7","~:-",["^>>","^>@"]]]]]],"^8",146,"^?Y",["^20"],"^:",146,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>D","^?7"]]]]],"^6","Inputs: [field-or-join :- FieldOrPartialJoin join-alias :- [:maybe :metabase.lib.schema.common/non-blank-string]]\n  Return: FieldOrPartialJoin\n          \n\n  Add OR REMOVE a specific `join-alias` to `field-or-join`, which is either a `:field`/Field metadata, or a join map.\n  Does not recursively update other references (yet; we can add this in the future)."],"~$standard-join-condition?",["^ ","^>;",["^><",["^>=","^?F"],"~:boolean"],"^>A","id79984","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^?F"],"^AE"],"^>A","id79984","^?5",true,"^7","metabase/lib/join.cljc","^;",44,"^9",20,"^>C",["^21",["^>7",["^21",[["^@E","~:-","^?F"]]]]],"^8",74,"^:",74,"^>6",["^21",["^>7",["^21",[["^@E"]]]]],"^6","Inputs: [condition :- :metabase.lib.schema.expression/boolean]\n  Return: :boolean\n          \n\n  Whether this join condition is a binary condition with two `:field` references (a LHS and a RHS), as you'd produce\n  in the frontend using functions like [[join-condition-operators]], [[join-condition-lhs-columns]],\n  and [[join-condition-rhs-columns]]."],"^?5",true,"^L","^5L","^7","metabase/lib/join.cljc","^;",44,"^>E",["^21",[["^@E"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^@E","~:-","^?F"]]]]],"^8",74,"^>S",["^K",["^>T","^?J"]],"^:",74,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^@E"]]]]],"^6","Inputs: [condition :- :metabase.lib.schema.expression/boolean]\n  Return: :boolean\n          \n\n  Whether this join condition is a binary condition with two `:field` references (a LHS and a RHS), as you'd produce\n  in the frontend using functions like [[join-condition-operators]], [[join-condition-lhs-columns]],\n  and [[join-condition-rhs-columns]]."],"~$standard-join-condition-update-rhs",["^ ","^>B",null,"^5",["^ ","^?5",true,"^7","metabase/lib/join.cljc","^;",42,"^?G",["^ ","^>H",true,"^?H",2,"^>I",2,"^>E",[["^21",["^@E","~$f","~$args"]]],"^>6",["^21",[["^@E","~$f","~$&","^AG"]]],"^>G",["^21",[null]]],"^9",8,"^8",95,"^:",95,"^>6",["^21",["^>7",["^21",[["^@E","~$f","~$&","^AG"]]]]],"^6","If `condition` is a [[standard-join-condition?]], update the RHS with `f` like\n\n    (apply f rhs args)"],"^?5",true,"^L","^4K","^7","metabase/lib/join.cljc","^;",42,"^?G",["^ ","^>H",true,"^?H",2,"^>I",2,"^>E",[["^21",["^@E","~$f","^AG"]]],"^>6",["^21",[["^@E","~$f","~$&","^AG"]]],"^>G",["^21",[null]]],"^>E",[["^21",["^@E","~$f","^AG"]]],"^>F",null,"^?H",2,"^>G",["^21",[null]],"^9",1,"^>H",true,"^?I",[["^ ","^?H",2,"^>H",true,"^>9",["^K",[null,"^@;"]]]],"^8",95,"^>S","^>T","^:",95,"^>I",2,"^>J",true,"^>6",["^21",[["^@E","~$f","~$&","^AG"]]],"^6","If `condition` is a [[standard-join-condition?]], update the RHS with `f` like\n\n    (apply f rhs args)"],"~$with-join-strategy",["^ ","^>;",["^><",["^>=","^>Y",["^?V","^@2","^A1"]],"^>Y"],"^>A","id80217","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>Y",["^?V","^@2","^A1"]],"^>Y"],"^>A","id80217","^7","metabase/lib/join.cljc","^;",28,"^9",10,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y","~$strategy","~:-",["^?V","^@2","^A1"]]]]]],"^8",562,"^:",562,"^>6",["^21",["^>7",["^21",[["^>[","^AI"]]]]],"^6","Inputs: [a-join :- PartialJoin strategy :- [:or :metabase.lib.schema.join/strategy :metabase.lib.schema.join/strategy.option]]\n  Return: PartialJoin\n          \n\n  Return a copy of `a-join` with its `:strategy` set to `strategy`."],"^L","^34","^7","metabase/lib/join.cljc","^;",28,"^>E",["^21",[["^>[","^AI"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>[","~:-","^>Y","^AI","~:-",["^?V","^@2","^A1"]]]]]],"^8",562,"^>S",["^K",["^??","^>T"]],"^:",562,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>[","^AI"]]]]],"^6","Inputs: [a-join :- PartialJoin strategy :- [:or :metabase.lib.schema.join/strategy :metabase.lib.schema.join/strategy.option]]\n  Return: PartialJoin\n          \n\n  Return a copy of `a-join` with its `:strategy` set to `strategy`."],"~$joined-thing",["^ ","^>;",["^><",["^>=","~$lib.metadata/MetadataProviderable","^@L"],["^>>","^A4"]],"^>A","id80241","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^AK","^@L"],["^>>","^A4"]],"^>A","id80241","^7","metabase/lib/join.cljc","^;",22,"^9",10,"^>C",["^21",["^>7",["^21",[["^@D","~:-","^AK","^>[","~:-","^@L"]]]]],"^8",748,"^:",748,"^>6",["^21",["^>7",["^21",[["^@D","^>["]]]]],"^6","Inputs: [metadata-providerable :- lib.metadata/MetadataProviderable a-join :- :metabase.lib.schema.join/join]\n  Return: [:maybe Joinable]\n          \n\n  Return metadata about the origin of `a-join` using `metadata-providerable` as the source of information."],"^L","^4B","^7","metabase/lib/join.cljc","^;",22,"^>E",["^21",[["^@D","^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^@D","~:-","^AK","^>[","~:-","^@L"]]]]],"^8",748,"^>S",["^K",["^>T","^?J"]],"^:",748,"^>I",2,"^>J",true,"^>6",["^21",["^>7",["^21",[["^@D","^>["]]]]],"^6","Inputs: [metadata-providerable :- lib.metadata/MetadataProviderable a-join :- :metabase.lib.schema.join/join]\n  Return: [:maybe Joinable]\n          \n\n  Return metadata about the origin of `a-join` using `metadata-providerable` as the source of information."],"~$sort-join-condition-columns",["^ ","^>;",["^><",["^>=",["^?U","^?3"]],["^?U","^?3"]],"^>A","id80222","^>B",null,"^5",["^ ","^>;",["^><",["^>=",["^?U","^?3"]],["^?U","^?3"]],"^>A","id80222","^?5",true,"^7","metabase/lib/join.cljc","^;",47,"^9",20,"^>C",["^21",["^>7",["^21",[["~$columns","~:-",["^?U","^?3"]]]]]],"^8",616,"^:",616,"^>6",["^21",["^>7",["^21",[["^AM"]]]]],"^6","Inputs: [columns :- [:sequential lib.metadata/ColumnMetadata]]\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Sort potential join condition columns as returned by [[join-condition-lhs-columns]]\n  or [[join-condition-rhs-columns]]. PK columns are returned first, followed by FK columns, followed by other columns.\n  Otherwise original order is maintained."],"^?5",true,"^L","^4<","^7","metabase/lib/join.cljc","^;",47,"^>E",["^21",[["^AM"]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^AM","~:-",["^?U","^?3"]]]]]],"^8",616,"^>S","^45","^:",616,"^>I",1,"^>J",true,"^>6",["^21",["^>7",["^21",[["^AM"]]]]],"^6","Inputs: [columns :- [:sequential lib.metadata/ColumnMetadata]]\n  Return: [:sequential lib.metadata/ColumnMetadata]\n          \n\n  Sort potential join condition columns as returned by [[join-condition-lhs-columns]]\n  or [[join-condition-rhs-columns]]. PK columns are returned first, followed by FK columns, followed by other columns.\n  Otherwise original order is maintained."],"~$add-default-alias",["^ ","^>;",["^><",["^>=","^>L","^>M","^@B"],"^@L"],"^>A","id80194","^>B",null,"^5",["^ ","^>;",["^><",["^>=","^>L","^>M","^@B"],"^@L"],"^>A","id80194","^7","metabase/lib/join.cljc","^;",27,"^9",10,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^>[","~:-","^@B"]]]]],"^8",476,"^:",476,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^>["]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int a-join :- JoinWithOptionalAlias]\n  Return: :metabase.lib.schema.join/join\n          \n\n  Add a default generated `:alias` to a join clause that does not already have one."],"^L","^4?","^7","metabase/lib/join.cljc","^;",27,"^>E",["^21",[["^>P","^>Q","^>["]]],"^>F",null,"^>G",["^21",[null,null]],"^9",1,"^>H",false,"^>C",["^21",["^>7",["^21",[["^>P","~:-","^>L","^>Q","~:-","^>M","^>[","~:-","^@B"]]]]],"^8",476,"^>S",["^K",[null,"^>T"]],"^:",476,"^>I",3,"^>J",true,"^>6",["^21",["^>7",["^21",[["^>P","^>Q","^>["]]]]],"^6","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int a-join :- JoinWithOptionalAlias]\n  Return: :metabase.lib.schema.join/join\n          \n\n  Add a default generated `:alias` to a join clause that does not already have one."]],"^1[",["^ ","^T","^U","^Z","^[","^14","^14","~$u","^17","^18","^19","^1;","^1<","^D","^D","^19","^19","^17","^17","^1I","^1J","^1<","^1<","^[","^[","^U","^U","^1V","^14","^1J","^1J"],"~:cljs.analyzer/constants",["^ ","^1X",["^K",["~:features","~:full-join","~:lib/type","~:short-name","~:option/join.strategy","~:stages","~:pk","~:else","~:ref","^3N","~:default","~:other","^L","^?V","~:lib/source","~:metabase.lib.join/ref","~:lib/source-column-alias","~:fields","~:mbql/query","~:join-alias","~:unique-name-fn","~:joins","~:metabase.lib.schema.join/alias","~:field","^?1","~:source/joins","^@>","~:mbql/join","~:merge","~:fk-target-field-id","~:right-join","~:left-join","^@7","~:strategy","~:conditions","~:clojure.core.match/not-found","~:id","~:source-alias","~:source-table","^@L","~:optional","~:include-implicitly-joinable?","~:lib/desired-column-alias","~:mbql.stage/mbql","~:cljs.analyzer/no-resolve","~:display-name","~:source-card","~:query","~:stage-number","~:fk","~:hierarchy","~:inner-join","~:selected?","~:=","^@6","^@?","~:metabase.lib.join/join-alias","~:mbql.clause/field"]],"~:order",["^B;","^AX","^@L","^@6","^@7","^BE","^B7","^B@","^?1","^?V","^BS","^B4","^BR","^B2","^AW","^B8","^BA","^B6","^BL","^BM","^B:","^AU","^BD","^BK","^BJ","^L","^BC","^A[","^B9","^AT","^B?","^AY","^AS","^B1","^BG","^@?","^B5","^3N","^BI","^@>","^BF","^BO","^B3","^AR","^BH","^B>","^AP","^B=","^BP","^AQ","^AV","^BN","^AZ","^BB","^B<","~:=","^BQ","^B0"]],"^24",["^ ","^1Y",["^K",[]]],"^25",["^ "],"^26",["^1?","^D","^1U","^1Q","^1G","^1<","^1M","^W","^1J","^16","^1F","^X","^V","^1D","^1A","^1=","^S","^13","^19","^1P","^11","^1N","^1>","^14","^[","^17","^U"]],"^P","^M","~:ns-specs",["^ "],"~:ns-spec-vars",["^K",[]],"~:compiler-options",["^6L",[["^BW","~:static-fns"],true,["^BW","~:shadow-tweaks"],null,["^BW","~:source-map-inline"],null,["^BW","~:elide-asserts"],false,["^BW","~:optimize-constants"],null,["^BW","^2;"],null,["^BW","~:external-config"],null,["^BW","~:tooling-config"],null,["^BW","~:emit-constants"],null,["^BW","~:load-tests"],null,["^BW","~:form-size-threshold"],null,["^BW","~:global-goog-object&array"],null,["^BW","~:data-readers"],null,["^BW","~:infer-externs"],"~:auto",["^BW","^2="],["^K",["^2>","^2?"]],["~:js-options","~:js-provider"],"^1Y",["~:mode"],"~:dev",["^BW","~:fn-invoke-direct"],null,["^BW","~:source-map"],"/dev/null"]]]