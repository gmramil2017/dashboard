["^ ","~:output",["^ ","~:js","goog.provide('clojure.test.check.generators');\n\n/**\n* @constructor\n * @implements {cljs.core.IRecord}\n * @implements {cljs.core.IKVReduce}\n * @implements {cljs.core.IEquiv}\n * @implements {cljs.core.IHash}\n * @implements {cljs.core.ICollection}\n * @implements {cljs.core.ICounted}\n * @implements {cljs.core.ISeqable}\n * @implements {cljs.core.IMeta}\n * @implements {cljs.core.ICloneable}\n * @implements {cljs.core.IPrintWithWriter}\n * @implements {cljs.core.IIterable}\n * @implements {cljs.core.IWithMeta}\n * @implements {cljs.core.IAssociative}\n * @implements {cljs.core.IMap}\n * @implements {cljs.core.ILookup}\n*/\nclojure.test.check.generators.Generator = (function (gen,__meta,__extmap,__hash){\nthis.gen = gen;\nthis.__meta = __meta;\nthis.__extmap = __extmap;\nthis.__hash = __hash;\nthis.cljs$lang$protocol_mask$partition0$ = 2230716170;\nthis.cljs$lang$protocol_mask$partition1$ = 139264;\n});\n(clojure.test.check.generators.Generator.prototype.cljs$core$ILookup$_lookup$arity$2 = (function (this__5343__auto__,k__5344__auto__){\nvar self__ = this;\nvar this__5343__auto____$1 = this;\nreturn this__5343__auto____$1.cljs$core$ILookup$_lookup$arity$3(null,k__5344__auto__,null);\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$ILookup$_lookup$arity$3 = (function (this__5345__auto__,k45886,else__5346__auto__){\nvar self__ = this;\nvar this__5345__auto____$1 = this;\nvar G__45890 = k45886;\nvar G__45890__$1 = (((G__45890 instanceof cljs.core.Keyword))?G__45890.fqn:null);\nswitch (G__45890__$1) {\ncase \"gen\":\nreturn self__.gen;\n\nbreak;\ndefault:\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k45886,else__5346__auto__);\n\n}\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IKVReduce$_kv_reduce$arity$3 = (function (this__5363__auto__,f__5364__auto__,init__5365__auto__){\nvar self__ = this;\nvar this__5363__auto____$1 = this;\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (ret__5366__auto__,p__45891){\nvar vec__45892 = p__45891;\nvar k__5367__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45892,(0),null);\nvar v__5368__auto__ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45892,(1),null);\nreturn (f__5364__auto__.cljs$core$IFn$_invoke$arity$3 ? f__5364__auto__.cljs$core$IFn$_invoke$arity$3(ret__5366__auto__,k__5367__auto__,v__5368__auto__) : f__5364__auto__.call(null,ret__5366__auto__,k__5367__auto__,v__5368__auto__));\n}),init__5365__auto__,this__5363__auto____$1);\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IPrintWithWriter$_pr_writer$arity$3 = (function (this__5358__auto__,writer__5359__auto__,opts__5360__auto__){\nvar self__ = this;\nvar this__5358__auto____$1 = this;\nvar pr_pair__5361__auto__ = (function (keyval__5362__auto__){\nreturn cljs.core.pr_sequential_writer(writer__5359__auto__,cljs.core.pr_writer,\"\",\" \",\"\",opts__5360__auto__,keyval__5362__auto__);\n});\nreturn cljs.core.pr_sequential_writer(writer__5359__auto__,pr_pair__5361__auto__,\"#clojure.test.check.generators.Generator{\",\", \",\"}\",opts__5360__auto__,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.PersistentVector(null,2,(5),cljs.core.PersistentVector.EMPTY_NODE,[new cljs.core.Keyword(null,\"gen\",\"gen\",142575302),self__.gen],null))], null),self__.__extmap));\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IIterable$_iterator$arity$1 = (function (G__45885){\nvar self__ = this;\nvar G__45885__$1 = this;\nreturn (new cljs.core.RecordIter((0),G__45885__$1,1,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"gen\",\"gen\",142575302)], null),(cljs.core.truth_(self__.__extmap)?cljs.core._iterator(self__.__extmap):cljs.core.nil_iter())));\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IMeta$_meta$arity$1 = (function (this__5341__auto__){\nvar self__ = this;\nvar this__5341__auto____$1 = this;\nreturn self__.__meta;\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$ICloneable$_clone$arity$1 = (function (this__5338__auto__){\nvar self__ = this;\nvar this__5338__auto____$1 = this;\nreturn (new clojure.test.check.generators.Generator(self__.gen,self__.__meta,self__.__extmap,self__.__hash));\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$ICounted$_count$arity$1 = (function (this__5347__auto__){\nvar self__ = this;\nvar this__5347__auto____$1 = this;\nreturn (1 + cljs.core.count(self__.__extmap));\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IHash$_hash$arity$1 = (function (this__5339__auto__){\nvar self__ = this;\nvar this__5339__auto____$1 = this;\nvar h__5154__auto__ = self__.__hash;\nif((!((h__5154__auto__ == null)))){\nreturn h__5154__auto__;\n} else {\nvar h__5154__auto____$1 = (function (coll__5340__auto__){\nreturn (236843149 ^ cljs.core.hash_unordered_coll(coll__5340__auto__));\n})(this__5339__auto____$1);\n(self__.__hash = h__5154__auto____$1);\n\nreturn h__5154__auto____$1;\n}\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IEquiv$_equiv$arity$2 = (function (this45887,other45888){\nvar self__ = this;\nvar this45887__$1 = this;\nreturn (((!((other45888 == null)))) && ((((this45887__$1.constructor === other45888.constructor)) && (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this45887__$1.gen,other45888.gen)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(this45887__$1.__extmap,other45888.__extmap)))))));\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IMap$_dissoc$arity$2 = (function (this__5353__auto__,k__5354__auto__){\nvar self__ = this;\nvar this__5353__auto____$1 = this;\nif(cljs.core.contains_QMARK_(new cljs.core.PersistentHashSet(null, new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"gen\",\"gen\",142575302),null], null), null),k__5354__auto__)){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(cljs.core._with_meta(cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,this__5353__auto____$1),self__.__meta),k__5354__auto__);\n} else {\nreturn (new clojure.test.check.generators.Generator(self__.gen,self__.__meta,cljs.core.not_empty(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(self__.__extmap,k__5354__auto__)),null));\n}\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IAssociative$_contains_key_QMARK_$arity$2 = (function (this__5350__auto__,k45886){\nvar self__ = this;\nvar this__5350__auto____$1 = this;\nvar G__45898 = k45886;\nvar G__45898__$1 = (((G__45898 instanceof cljs.core.Keyword))?G__45898.fqn:null);\nswitch (G__45898__$1) {\ncase \"gen\":\nreturn true;\n\nbreak;\ndefault:\nreturn cljs.core.contains_QMARK_(self__.__extmap,k45886);\n\n}\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IAssociative$_assoc$arity$3 = (function (this__5351__auto__,k__5352__auto__,G__45885){\nvar self__ = this;\nvar this__5351__auto____$1 = this;\nvar pred__45904 = cljs.core.keyword_identical_QMARK_;\nvar expr__45905 = k__5352__auto__;\nif(cljs.core.truth_((pred__45904.cljs$core$IFn$_invoke$arity$2 ? pred__45904.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"gen\",\"gen\",142575302),expr__45905) : pred__45904.call(null,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302),expr__45905)))){\nreturn (new clojure.test.check.generators.Generator(G__45885,self__.__meta,self__.__extmap,null));\n} else {\nreturn (new clojure.test.check.generators.Generator(self__.gen,self__.__meta,cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(self__.__extmap,k__5352__auto__,G__45885),null));\n}\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$ISeqable$_seq$arity$1 = (function (this__5356__auto__){\nvar self__ = this;\nvar this__5356__auto____$1 = this;\nreturn cljs.core.seq(cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(new cljs.core.MapEntry(new cljs.core.Keyword(null,\"gen\",\"gen\",142575302),self__.gen,null))], null),self__.__extmap));\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$IWithMeta$_with_meta$arity$2 = (function (this__5342__auto__,G__45885){\nvar self__ = this;\nvar this__5342__auto____$1 = this;\nreturn (new clojure.test.check.generators.Generator(self__.gen,G__45885,self__.__extmap,self__.__hash));\n}));\n\n(clojure.test.check.generators.Generator.prototype.cljs$core$ICollection$_conj$arity$2 = (function (this__5348__auto__,entry__5349__auto__){\nvar self__ = this;\nvar this__5348__auto____$1 = this;\nif(cljs.core.vector_QMARK_(entry__5349__auto__)){\nreturn this__5348__auto____$1.cljs$core$IAssociative$_assoc$arity$3(null,cljs.core._nth(entry__5349__auto__,(0)),cljs.core._nth(entry__5349__auto__,(1)));\n} else {\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core._conj,this__5348__auto____$1,entry__5349__auto__);\n}\n}));\n\n(clojure.test.check.generators.Generator.getBasis = (function (){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,\"gen\",\"gen\",1783106829,null)], null);\n}));\n\n(clojure.test.check.generators.Generator.cljs$lang$type = true);\n\n(clojure.test.check.generators.Generator.cljs$lang$ctorPrSeq = (function (this__5389__auto__){\nreturn (new cljs.core.List(null,\"clojure.test.check.generators/Generator\",null,(1),null));\n}));\n\n(clojure.test.check.generators.Generator.cljs$lang$ctorPrWriter = (function (this__5389__auto__,writer__5390__auto__){\nreturn cljs.core._write(writer__5390__auto__,\"clojure.test.check.generators/Generator\");\n}));\n\n/**\n * Positional factory function for clojure.test.check.generators/Generator.\n */\nclojure.test.check.generators.__GT_Generator = (function clojure$test$check$generators$__GT_Generator(gen){\nreturn (new clojure.test.check.generators.Generator(gen,null,null,null));\n});\n\n/**\n * Factory function for clojure.test.check.generators/Generator, taking a map of keywords to field values.\n */\nclojure.test.check.generators.map__GT_Generator = (function clojure$test$check$generators$map__GT_Generator(G__45889){\nvar extmap__5385__auto__ = (function (){var G__45907 = cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(G__45889,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302));\nif(cljs.core.record_QMARK_(G__45889)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,G__45907);\n} else {\nreturn G__45907;\n}\n})();\nreturn (new clojure.test.check.generators.Generator(new cljs.core.Keyword(null,\"gen\",\"gen\",142575302).cljs$core$IFn$_invoke$arity$1(G__45889),null,cljs.core.not_empty(extmap__5385__auto__),null));\n});\n\n/**\n * Test if `x` is a generator. Generators should be treated as opaque values.\n */\nclojure.test.check.generators.generator_QMARK_ = (function clojure$test$check$generators$generator_QMARK_(x){\nreturn (x instanceof clojure.test.check.generators.Generator);\n});\nclojure.test.check.generators.make_gen = (function clojure$test$check$generators$make_gen(generator_fn){\nreturn (new clojure.test.check.generators.Generator(generator_fn,null,null,null));\n});\n/**\n * Internal function.\n */\nclojure.test.check.generators.call_gen = (function clojure$test$check$generators$call_gen(p__45911,rnd,size){\nvar map__45912 = p__45911;\nvar map__45912__$1 = cljs.core.__destructure_map(map__45912);\nvar generator_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45912__$1,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302));\nreturn (generator_fn.cljs$core$IFn$_invoke$arity$2 ? generator_fn.cljs$core$IFn$_invoke$arity$2(rnd,size) : generator_fn.call(null,rnd,size));\n});\n/**\n * Internal function.\n */\nclojure.test.check.generators.gen_pure = (function clojure$test$check$generators$gen_pure(value){\nreturn clojure.test.check.generators.make_gen((function (rnd,size){\nreturn value;\n}));\n});\n/**\n * Internal function.\n */\nclojure.test.check.generators.gen_fmap = (function clojure$test$check$generators$gen_fmap(k,p__45913){\nvar map__45914 = p__45913;\nvar map__45914__$1 = cljs.core.__destructure_map(map__45914);\nvar h = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45914__$1,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302));\nreturn clojure.test.check.generators.make_gen((function (rnd,size){\nvar G__45915 = (h.cljs$core$IFn$_invoke$arity$2 ? h.cljs$core$IFn$_invoke$arity$2(rnd,size) : h.call(null,rnd,size));\nreturn (k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(G__45915) : k.call(null,G__45915));\n}));\n});\n/**\n * Internal function.\n */\nclojure.test.check.generators.gen_bind = (function clojure$test$check$generators$gen_bind(p__45916,k){\nvar map__45917 = p__45916;\nvar map__45917__$1 = cljs.core.__destructure_map(map__45917);\nvar h = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45917__$1,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302));\nreturn clojure.test.check.generators.make_gen((function (rnd,size){\nvar vec__45918 = clojure.test.check.random.split(rnd);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45918,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45918,(1),null);\nvar inner = (h.cljs$core$IFn$_invoke$arity$2 ? h.cljs$core$IFn$_invoke$arity$2(r1,size) : h.call(null,r1,size));\nvar map__45921 = (k.cljs$core$IFn$_invoke$arity$1 ? k.cljs$core$IFn$_invoke$arity$1(inner) : k.call(null,inner));\nvar map__45921__$1 = cljs.core.__destructure_map(map__45921);\nvar result = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45921__$1,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302));\nreturn (result.cljs$core$IFn$_invoke$arity$2 ? result.cljs$core$IFn$_invoke$arity$2(r2,size) : result.call(null,r2,size));\n}));\n});\n/**\n * Internal function.\n * \n *   Given a random number generator, returns an infinite lazy sequence\n *   of random number generators.\n */\nclojure.test.check.generators.lazy_random_states = (function clojure$test$check$generators$lazy_random_states(rr){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar vec__45922 = clojure.test.check.random.split(rr);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45922,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45922,(1),null);\nreturn cljs.core.cons(r1,(clojure.test.check.generators.lazy_random_states.cljs$core$IFn$_invoke$arity$1 ? clojure.test.check.generators.lazy_random_states.cljs$core$IFn$_invoke$arity$1(r2) : clojure.test.check.generators.lazy_random_states.call(null,r2)));\n}),null,null));\n});\n/**\n * Takes a collection of generators and returns a generator of vectors.\n */\nclojure.test.check.generators.gen_tuple = (function clojure$test$check$generators$gen_tuple(gens){\nreturn clojure.test.check.generators.make_gen((function (rnd,size){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$3((function (p1__45925_SHARP_,p2__45926_SHARP_){\nreturn clojure.test.check.generators.call_gen(p1__45925_SHARP_,p2__45926_SHARP_,size);\n}),gens,clojure.test.check.random.split_n(rnd,cljs.core.count(gens)));\n}));\n});\n/**\n * Returns a generator like `gen` but with values transformed by `f`.\n *   E.g.:\n * \n *    (gen/sample (gen/fmap str gen/nat))\n *    => (\"0\" \"1\" \"0\" \"1\" \"4\" \"3\" \"6\" \"6\" \"4\" \"2\")\n * \n *   Also see gen/let for a macro with similar functionality.\n */\nclojure.test.check.generators.fmap = (function clojure$test$check$generators$fmap(f,gen){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Second arg to fmap must be a generator\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_fmap((function (p1__45927_SHARP_){\nreturn clojure.test.check.rose_tree.fmap(f,p1__45927_SHARP_);\n}),gen);\n});\n/**\n * Creates a generator that always returns `value`,\n *   and never shrinks. You can think of this as\n *   the `constantly` of generators. E.g.:\n * \n *    (gen/sample (gen/return 42))\n *    => (42 42 42 42 42 42 42 42 42 42)\n */\nclojure.test.check.generators.return$ = (function clojure$test$check$generators$return(value){\nreturn clojure.test.check.generators.gen_pure(clojure.test.check.rose_tree.pure(value));\n});\nclojure.test.check.generators.bind_helper = (function clojure$test$check$generators$bind_helper(f){\nreturn (function (rose){\nreturn clojure.test.check.generators.gen_fmap(clojure.test.check.rose_tree.join,clojure.test.check.generators.make_gen((function (rnd,size){\nreturn clojure.test.check.rose_tree.fmap((function (p1__45928_SHARP_){\nreturn clojure.test.check.generators.call_gen((f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(p1__45928_SHARP_) : f.call(null,p1__45928_SHARP_)),rnd,size);\n}),rose);\n})));\n});\n});\n/**\n * Creates a new generator that passes the result of `gen` into function\n *   `f`. `f` should return a new generator. This allows you to create new\n *   generators that depend on the value of other generators. For example,\n *   to create a generator of permutations which first generates a\n *   `num-elements` and then generates a shuffling of `(range num-elements)`:\n * \n *    (gen/bind gen/nat\n *              ;; this function takes a value generated by\n *              ;; the generator above and returns a new generator\n *              ;; which shuffles the collection returned by `range`\n *              (fn [num-elements]\n *                (gen/shuffle (range num-elements))))\n * \n *   Also see gen/let for a macro with similar functionality.\n */\nclojure.test.check.generators.bind = (function clojure$test$check$generators$bind(generator,f){\nif(clojure.test.check.generators.generator_QMARK_(generator)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to bind must be a generator\",\"\\n\",\"(generator? generator)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_bind(generator,clojure.test.check.generators.bind_helper(f));\n});\n/**\n * Internal function.\n */\nclojure.test.check.generators.make_size_range_seq = (function clojure$test$check$generators$make_size_range_seq(max_size){\nreturn cljs.core.cycle(cljs.core.range.cljs$core$IFn$_invoke$arity$2((0),max_size));\n});\n/**\n * Returns an infinite sequence of realized values from `generator`.\n * \n *   Note that this function is a dev helper and is not meant to be used\n *   to build other generators.\n */\nclojure.test.check.generators.sample_seq = (function clojure$test$check$generators$sample_seq(var_args){\nvar G__45938 = arguments.length;\nswitch (G__45938) {\ncase 1:\nreturn clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$1 = (function (generator){\nreturn clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$2(generator,(200));\n}));\n\n(clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$2 = (function (generator,max_size){\nvar r = clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$0();\nvar size_seq = clojure.test.check.generators.make_size_range_seq(max_size);\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$3((function (p1__45933_SHARP_,p2__45934_SHARP_){\nreturn clojure.test.check.rose_tree.root(clojure.test.check.generators.call_gen(generator,p1__45933_SHARP_,p2__45934_SHARP_));\n}),clojure.test.check.generators.lazy_random_states(r),size_seq);\n}));\n\n(clojure.test.check.generators.sample_seq.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return a sequence of `num-samples` (default 10)\n *   realized values from `generator`.\n * \n *   The sequence starts with small values from the generator, which\n *   probably do not reflect the variety of values that will be generated\n *   during a longer test run.\n * \n *   Note that this function is a dev helper and is not meant to be used\n *   to build other generators.\n */\nclojure.test.check.generators.sample = (function clojure$test$check$generators$sample(var_args){\nvar G__45944 = arguments.length;\nswitch (G__45944) {\ncase 1:\nreturn clojure.test.check.generators.sample.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.sample.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.sample.cljs$core$IFn$_invoke$arity$1 = (function (generator){\nreturn clojure.test.check.generators.sample.cljs$core$IFn$_invoke$arity$2(generator,(10));\n}));\n\n(clojure.test.check.generators.sample.cljs$core$IFn$_invoke$arity$2 = (function (generator,num_samples){\nif(clojure.test.check.generators.generator_QMARK_(generator)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to sample must be a generator\",\"\\n\",\"(generator? generator)\"].join('')));\n}\n\nreturn cljs.core.take.cljs$core$IFn$_invoke$arity$2(num_samples,clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$1(generator));\n}));\n\n(clojure.test.check.generators.sample.cljs$lang$maxFixedArity = 2);\n\n/**\n * Returns a single sample value from the generator.\n * \n *   Note that this function is a dev helper and is not meant to be used\n *   to build other generators.\n * \n *   Optional args:\n * \n *   - size: the abstract size parameter, defaults to 30\n *   - seed: the seed for the random number generator, an integer\n */\nclojure.test.check.generators.generate = (function clojure$test$check$generators$generate(var_args){\nvar G__45946 = arguments.length;\nswitch (G__45946) {\ncase 1:\nreturn clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$1 = (function (generator){\nreturn clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$2(generator,(30));\n}));\n\n(clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$2 = (function (generator,size){\nvar rng = clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$0();\nreturn clojure.test.check.rose_tree.root(clojure.test.check.generators.call_gen(generator,rng,size));\n}));\n\n(clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$3 = (function (generator,size,seed){\nvar rng = clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1(seed);\nreturn clojure.test.check.rose_tree.root(clojure.test.check.generators.call_gen(generator,rng,size));\n}));\n\n(clojure.test.check.generators.generate.cljs$lang$maxFixedArity = 3);\n\nclojure.test.check.generators.halfs = (function clojure$test$check$generators$halfs(n){\nreturn cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__45950_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2((0),p1__45950_SHARP_);\n}),cljs.core.iterate((function (p1__45951_SHARP_){\nreturn cljs.core.quot(p1__45951_SHARP_,(2));\n}),n));\n});\nclojure.test.check.generators.shrink_int = (function clojure$test$check$generators$shrink_int(integer){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__45955_SHARP_){\nreturn (integer - p1__45955_SHARP_);\n}),clojure.test.check.generators.halfs(integer));\n});\nclojure.test.check.generators.int_rose_tree = (function clojure$test$check$generators$int_rose_tree(value){\nreturn clojure.test.check.rose_tree.make_rose(value,cljs.core.map.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.int_rose_tree,clojure.test.check.generators.shrink_int(value)));\n});\nclojure.test.check.generators.calc_long = (function clojure$test$check$generators$calc_long(factor,lower,upper){\nreturn cljs.core.long$(Math.floor((lower + ((factor * (1.0 + upper)) - (factor * lower)))));\n});\nclojure.test.check.generators.rand_range = (function clojure$test$check$generators$rand_range(rnd,lower,upper){\nif((lower <= upper)){\n} else {\nthrow (new Error(\"Assert failed: (<= lower upper)\"));\n}\n\nreturn clojure.test.check.generators.calc_long(clojure.test.check.random.rand_double(rnd),lower,upper);\n});\n/**\n * Creates a generator that depends on the size parameter.\n *   `sized-gen` is a function that takes an integer and returns\n *   a generator.\n * \n *   Examples:\n * \n *    ;; generates vectors of booleans where the length always exactly\n *    ;; matches the `size` parameter\n *    (gen/sample (gen/sized (fn [size] (gen/vector gen/boolean size))))\n *    => ([]\n *        [false]\n *        [true true]\n *        [false true false]\n *        [false true true true]\n *        [false false true true false]\n *        [false true false true true false]\n *        [true false true true true false false]\n *        [true true false false false true false false]\n *        [false false false true true false true false true])\n */\nclojure.test.check.generators.sized = (function clojure$test$check$generators$sized(sized_gen){\nreturn clojure.test.check.generators.make_gen((function (rnd,size){\nvar sized_gen__$1 = (sized_gen.cljs$core$IFn$_invoke$arity$1 ? sized_gen.cljs$core$IFn$_invoke$arity$1(size) : sized_gen.call(null,size));\nreturn clojure.test.check.generators.call_gen(sized_gen__$1,rnd,size);\n}));\n});\n/**\n * Creates a new generator with `size` always bound to `n`.\n * \n *    (gen/sample (gen/set (gen/resize 200 gen/double)))\n *    => (#{}\n *        #{-4.994772362980037E147}\n *        #{-4.234418056487335E-146}\n *        #{}\n *        #{}\n *        #{}\n *        #{NaN}\n *        #{8.142414100982609E-63}\n *        #{-3.58429955903876E-159 2.8563794617604296E-154\n *          4.1021360195776005E-100 1.9084564045332549E-38}\n *        #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})\n */\nclojure.test.check.generators.resize = (function clojure$test$check$generators$resize(n,generator){\nif(clojure.test.check.generators.generator_QMARK_(generator)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Second arg to resize must be a generator\",\"\\n\",\"(generator? generator)\"].join('')));\n}\n\nvar map__45959 = generator;\nvar map__45959__$1 = cljs.core.__destructure_map(map__45959);\nvar gen = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__45959__$1,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302));\nreturn clojure.test.check.generators.make_gen((function (rnd,_size){\nreturn (gen.cljs$core$IFn$_invoke$arity$2 ? gen.cljs$core$IFn$_invoke$arity$2(rnd,n) : gen.call(null,rnd,n));\n}));\n});\n/**\n * Creates a new generator that modifies the size parameter by the\n *   given function. Intended to support generators with sizes that need\n *   to grow at different rates compared to the normal linear scaling.\n * \n *    (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n *                           gen/nat\n *                           (gen/scale #(* % 10) gen/nat)))\n *    => ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n *        [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])\n */\nclojure.test.check.generators.scale = (function clojure$test$check$generators$scale(f,generator){\nreturn clojure.test.check.generators.sized((function (n){\nreturn clojure.test.check.generators.resize((f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(n) : f.call(null,n)),generator);\n}));\n});\n/**\n * Creates a generator that generates integer numbers uniformly in\n *   the range `lower` to `upper`, inclusive.\n * \n *       (gen/sample (gen/choose 200 800))\n *       => (331 241 593 339 643 718 688 473 247 694)\n */\nclojure.test.check.generators.choose = (function clojure$test$check$generators$choose(lower,upper){\nreturn clojure.test.check.generators.make_gen((function (rnd,_size){\nvar value = clojure.test.check.generators.rand_range(rnd,lower,upper);\nreturn clojure.test.check.rose_tree.filter((function (p1__45960_SHARP_){\nreturn (((p1__45960_SHARP_ >= lower)) && ((p1__45960_SHARP_ <= upper)));\n}),clojure.test.check.generators.int_rose_tree(value));\n}));\n});\n/**\n * Creates a generator that randomly chooses a value from the list of\n *   provided generators. Shrinks toward choosing an earlier generator,\n *   as well as shrinking the value generated by the chosen generator.\n * \n *    (gen/sample (gen/one-of [gen/small-integer gen/boolean (gen/vector gen/small-integer)]))\n *    => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)\n */\nclojure.test.check.generators.one_of = (function clojure$test$check$generators$one_of(generators){\nif(cljs.core.every_QMARK_(clojure.test.check.generators.generator_QMARK_,generators)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Arg to one-of must be a collection of generators\",\"\\n\",\"(every? generator? generators)\"].join('')));\n}\n\nif(cljs.core.seq(generators)){\n} else {\nthrow (new Error([\"Assert failed: \",\"one-of cannot be called with an empty collection\",\"\\n\",\"(seq generators)\"].join('')));\n}\n\nreturn clojure.test.check.generators.bind(clojure.test.check.generators.choose((0),(cljs.core.count(generators) - (1))),(function (p1__45961_SHARP_){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(generators,p1__45961_SHARP_);\n}));\n});\n/**\n * Returns an index into the `likelihoods` sequence.\n */\nclojure.test.check.generators.pick = (function clojure$test$check$generators$pick(likelihoods,n){\nreturn cljs.core.count(cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__45962_SHARP_){\nreturn (p1__45962_SHARP_ <= n);\n}),cljs.core.rest(cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(cljs.core._PLUS_,(0),likelihoods))));\n});\n/**\n * Creates a generator that chooses a generator from `pairs` based on the\n *   provided likelihoods. The likelihood of a given generator being chosen is\n *   its likelihood divided by the sum of all likelihoods. Shrinks toward\n *   choosing an earlier generator, as well as shrinking the value generated\n *   by the chosen generator.\n * \n *   Examples:\n * \n *    (gen/sample (gen/frequency [[5 gen/small-integer] [3 (gen/vector gen/small-integer)] [2 gen/boolean]]))\n *    => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)\n */\nclojure.test.check.generators.frequency = (function clojure$test$check$generators$frequency(pairs){\nif(cljs.core.every_QMARK_((function (p__45971){\nvar vec__45972 = p__45971;\nvar x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45972,(0),null);\nvar g = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__45972,(1),null);\nreturn ((typeof x === 'number') && (clojure.test.check.generators.generator_QMARK_(g)));\n}),pairs)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Arg to frequency must be a list of [num generator] pairs\",\"\\n\",\"(every? (fn [[x g]] (and (number? x) (generator? g))) pairs)\"].join('')));\n}\n\nvar pairs__$1 = cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.pos_QMARK_,cljs.core.first),pairs);\nvar total = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,pairs__$1));\nif(cljs.core.seq(pairs__$1)){\n} else {\nthrow (new Error([\"Assert failed: \",\"frequency must be called with at least one non-zero weight\",\"\\n\",\"(seq pairs)\"].join('')));\n}\n\nreturn clojure.test.check.generators.make_gen((function (rnd,size){\nreturn clojure.test.check.generators.call_gen(clojure.test.check.generators.gen_bind(clojure.test.check.generators.choose((0),(total - (1))),(function (x){\nvar idx = clojure.test.check.generators.pick(cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.first,pairs__$1),clojure.test.check.rose_tree.root(x));\nreturn clojure.test.check.generators.gen_fmap((function (rose){\nreturn clojure.test.check.rose_tree.make_rose(clojure.test.check.rose_tree.root(rose),(new cljs.core.LazySeq(null,(function (){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2((function (){var iter__5523__auto__ = (function clojure$test$check$generators$frequency_$_iter__45985(s__45986){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s__45986__$1 = s__45986;\nwhile(true){\nvar temp__5804__auto__ = cljs.core.seq(s__45986__$1);\nif(temp__5804__auto__){\nvar s__45986__$2 = temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(s__45986__$2)){\nvar c__5521__auto__ = cljs.core.chunk_first(s__45986__$2);\nvar size__5522__auto__ = cljs.core.count(c__5521__auto__);\nvar b__45988 = cljs.core.chunk_buffer(size__5522__auto__);\nif((function (){var i__45987 = (0);\nwhile(true){\nif((i__45987 < size__5522__auto__)){\nvar idx__$1 = cljs.core._nth(c__5521__auto__,i__45987);\ncljs.core.chunk_append(b__45988,clojure.test.check.generators.call_gen(cljs.core.second(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(pairs__$1,idx__$1)),rnd,size));\n\nvar G__46408 = (i__45987 + (1));\ni__45987 = G__46408;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__45988),clojure$test$check$generators$frequency_$_iter__45985(cljs.core.chunk_rest(s__45986__$2)));\n} else {\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__45988),null);\n}\n} else {\nvar idx__$1 = cljs.core.first(s__45986__$2);\nreturn cljs.core.cons(clojure.test.check.generators.call_gen(cljs.core.second(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(pairs__$1,idx__$1)),rnd,size),clojure$test$check$generators$frequency_$_iter__45985(cljs.core.rest(s__45986__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n}),null,null));\n});\nreturn iter__5523__auto__(cljs.core.range.cljs$core$IFn$_invoke$arity$1(idx));\n})(),clojure.test.check.rose_tree.children(rose));\n}),null,null)));\n}),cljs.core.second(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(pairs__$1,idx)));\n})),rnd,size);\n}));\n});\n/**\n * Creates a generator that randomly chooses an element from `coll`.\n * \n *    (gen/sample (gen/elements [:foo :bar :baz]))\n *    => (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)\n */\nclojure.test.check.generators.elements = (function clojure$test$check$generators$elements(coll){\nif(cljs.core.seq(coll)){\n} else {\nthrow (new Error([\"Assert failed: \",\"elements cannot be called with an empty collection\",\"\\n\",\"(seq coll)\"].join('')));\n}\n\nvar v = cljs.core.vec(coll);\nreturn clojure.test.check.generators.gen_fmap((function (p1__46001_SHARP_){\nreturn clojure.test.check.rose_tree.fmap(v,p1__46001_SHARP_);\n}),clojure.test.check.generators.choose((0),(cljs.core.count(v) - (1))));\n});\nclojure.test.check.generators.such_that_helper = (function clojure$test$check$generators$such_that_helper(pred,gen,p__46004,rng,size){\nvar map__46005 = p__46004;\nvar map__46005__$1 = cljs.core.__destructure_map(map__46005);\nvar ex_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46005__$1,new cljs.core.Keyword(null,\"ex-fn\",\"ex-fn\",-284925510));\nvar max_tries = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46005__$1,new cljs.core.Keyword(null,\"max-tries\",\"max-tries\",-1824441792));\nvar tries_left = max_tries;\nvar rng__$1 = rng;\nvar size__$1 = size;\nwhile(true){\nif((tries_left === (0))){\nthrow (function (){var G__46011 = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"pred\",\"pred\",1927423397),pred,new cljs.core.Keyword(null,\"gen\",\"gen\",142575302),gen,new cljs.core.Keyword(null,\"max-tries\",\"max-tries\",-1824441792),max_tries], null);\nreturn (ex_fn.cljs$core$IFn$_invoke$arity$1 ? ex_fn.cljs$core$IFn$_invoke$arity$1(G__46011) : ex_fn.call(null,G__46011));\n})();\n} else {\nvar vec__46012 = clojure.test.check.random.split(rng__$1);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46012,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46012,(1),null);\nvar value = clojure.test.check.generators.call_gen(gen,r1,size__$1);\nif(cljs.core.truth_((function (){var G__46015 = clojure.test.check.rose_tree.root(value);\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(G__46015) : pred.call(null,G__46015));\n})())){\nreturn clojure.test.check.rose_tree.filter(pred,value);\n} else {\nvar G__46422 = (tries_left - (1));\nvar G__46423 = r2;\nvar G__46424 = (size__$1 + (1));\ntries_left = G__46422;\nrng__$1 = G__46423;\nsize__$1 = G__46424;\ncontinue;\n}\n}\nbreak;\n}\n});\nclojure.test.check.generators.default_such_that_opts = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"ex-fn\",\"ex-fn\",-284925510),(function (p__46018){\nvar map__46020 = p__46018;\nvar map__46020__$1 = cljs.core.__destructure_map(map__46020);\nvar arg = map__46020__$1;\nvar max_tries = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46020__$1,new cljs.core.Keyword(null,\"max-tries\",\"max-tries\",-1824441792));\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2([\"Couldn't satisfy such-that predicate after \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(max_tries),\" tries.\"].join(''),arg);\n}),new cljs.core.Keyword(null,\"max-tries\",\"max-tries\",-1824441792),(10)], null);\n/**\n * Creates a generator that generates values from `gen` that satisfy predicate\n *   `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n *   `pred`. By default, `such-that` will try 10 times to generate a value that\n *   satisfies the predicate. If no value passes this predicate after this number\n *   of iterations, a runtime exception will be thrown. Note also that each\n *   time such-that retries, it will increase the size parameter.\n * \n *   Examples:\n * \n *    ;; generate non-empty vectors of integers\n *    ;; (note, gen/not-empty does exactly this)\n *    (gen/such-that not-empty (gen/vector gen/small-integer))\n * \n *   You can customize `such-that` by passing an optional third argument, which can\n *   either be an integer representing the maximum number of times test.check\n *   will try to generate a value matching the predicate, or a map:\n * \n *    :max-tries  positive integer, the maximum number of tries (default 10)\n *    :ex-fn      a function of one arg that will be called if test.check cannot\n *                generate a matching value; it will be passed a map with `:gen`,\n *                `:pred`, and `:max-tries` and should return an exception\n */\nclojure.test.check.generators.such_that = (function clojure$test$check$generators$such_that(var_args){\nvar G__46023 = arguments.length;\nswitch (G__46023) {\ncase 2:\nreturn clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2 = (function (pred,gen){\nreturn clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$3(pred,gen,(10));\n}));\n\n(clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$3 = (function (pred,gen,max_tries_or_opts){\nvar opts = ((cljs.core.integer_QMARK_(max_tries_or_opts))?new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"max-tries\",\"max-tries\",-1824441792),max_tries_or_opts], null):((cljs.core.map_QMARK_(max_tries_or_opts))?max_tries_or_opts:(function(){throw cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"Bad argument to such-that!\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"max-tries-or-opts\",\"max-tries-or-opts\",-609860571),max_tries_or_opts], null))})()\n));\nvar opts__$1 = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.test.check.generators.default_such_that_opts,opts], 0));\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Second arg to such-that must be a generator\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.make_gen((function (rand_seed,size){\nreturn clojure.test.check.generators.such_that_helper(pred,gen,opts__$1,rand_seed,size);\n}));\n}));\n\n(clojure.test.check.generators.such_that.cljs$lang$maxFixedArity = 3);\n\n/**\n * Modifies a generator so that it doesn't generate empty collections.\n * \n *   Examples:\n * \n *    ;; generate a vector of booleans, but never the empty vector\n *    (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n *    => ([false]\n *        [false false]\n *        [false false]\n *        [false false false]\n *        [false false false false]\n *        [false true true]\n *        [true false false false]\n *        [true]\n *        [true true true false false true false]\n *        [false true true true false true true true false])\n */\nclojure.test.check.generators.not_empty = (function clojure$test$check$generators$not_empty(gen){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Arg to not-empty must be a generator\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2(cljs.core.not_empty,gen);\n});\n/**\n * Creates a new generator that is just like `gen`, except does not shrink\n *   at all. This can be useful when shrinking is taking a long time or is not\n *   applicable to the domain.\n */\nclojure.test.check.generators.no_shrink = (function clojure$test$check$generators$no_shrink(gen){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Arg to no-shrink must be a generator\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_fmap((function (rose){\nreturn clojure.test.check.rose_tree.make_rose(clojure.test.check.rose_tree.root(rose),cljs.core.PersistentVector.EMPTY);\n}),gen);\n});\n/**\n * Creates a new generator like `gen`, but will consider nodes for shrinking\n *   even if their parent passes the test (up to one additional level).\n */\nclojure.test.check.generators.shrink_2 = (function clojure$test$check$generators$shrink_2(gen){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Arg to shrink-2 must be a generator\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_fmap(clojure.test.check.rose_tree.collapse,gen);\n});\n/**\n * Generates one of `true` or `false`. Shrinks to `false`.\n */\nclojure.test.check.generators.boolean$ = clojure.test.check.generators.elements(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [false,true], null));\n/**\n * Creates a generator that returns a vector, whose elements are chosen\n *   from the generators in the same position. The individual elements shrink\n *   according to their generator, but the vector will never shrink in count.\n * \n *   Examples:\n * \n *    (def t (gen/tuple gen/small-integer gen/boolean))\n *    (sample t)\n *    ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n *    ;; =>  [3 true] [-4 false] [9 true]))\n */\nclojure.test.check.generators.tuple = (function clojure$test$check$generators$tuple(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___46427 = arguments.length;\nvar i__5770__auto___46428 = (0);\nwhile(true){\nif((i__5770__auto___46428 < len__5769__auto___46427)){\nargs__5775__auto__.push((arguments[i__5770__auto___46428]));\n\nvar G__46429 = (i__5770__auto___46428 + (1));\ni__5770__auto___46428 = G__46429;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((0) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic = (function (generators){\nif(cljs.core.every_QMARK_(clojure.test.check.generators.generator_QMARK_,generators)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Args to tuple must be generators\",\"\\n\",\"(every? generator? generators)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_fmap((function (roses){\nreturn clojure.test.check.rose_tree.zip(cljs.core.vector,roses);\n}),clojure.test.check.generators.gen_tuple(generators));\n}));\n\n(clojure.test.check.generators.tuple.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(clojure.test.check.generators.tuple.cljs$lang$applyTo = (function (seq46032){\nvar self__5755__auto__ = this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq46032));\n}));\n\n/**\n * Generates non-negative integers bounded by the generator's `size`\n *   parameter. Shrinks to zero.\n */\nclojure.test.check.generators.nat = clojure.test.check.generators.sized((function (size){\nreturn clojure.test.check.generators.choose((0),size);\n}));\n/**\n * Generates a positive or negative integer bounded by the generator's\n *   `size` parameter. Shrinks to zero.\n */\nclojure.test.check.generators.small_integer = clojure.test.check.generators.sized((function (size){\nreturn clojure.test.check.generators.choose((- size),size);\n}));\n/**\n * Deprecated - use gen/small-integer instead.\n * \n *   Generates a positive or negative integer bounded by the generator's\n *   `size` parameter.\n */\nclojure.test.check.generators.int$ = clojure.test.check.generators.small_integer;\n/**\n * Deprecated - use gen/nat instead (see also gen/large-integer).\n * \n *   (this generator, despite its name, can generate 0)\n * \n *   Generates nonnegative integers bounded by the generator's `size` parameter.\n */\nclojure.test.check.generators.pos_int = clojure.test.check.generators.nat;\n/**\n * Deprecated - use (gen/fmap - gen/nat) instead (see also gen/large-integer).\n * \n *   (this generator, despite its name, can generate 0)\n * \n *   Generates nonpositive integers bounded by the generator's `size` parameter.\n */\nclojure.test.check.generators.neg_int = clojure.test.check.generators.fmap((function (p1__46041_SHARP_){\nreturn ((-1) * p1__46041_SHARP_);\n}),clojure.test.check.generators.nat);\n/**\n * Deprecated - use (gen/fmap inc gen/nat) instead (see also gen/large-integer).\n * \n *   Generates positive integers bounded by the generator's `size` + 1\n */\nclojure.test.check.generators.s_pos_int = clojure.test.check.generators.fmap(cljs.core.inc,clojure.test.check.generators.nat);\n/**\n * Deprecated - use (gen/fmap (comp dec -) gen/nat) instead (see also gen/large-integer).\n * \n *   Generates negative integers bounded by the generator's `size` + 1\n */\nclojure.test.check.generators.s_neg_int = clojure.test.check.generators.fmap(cljs.core.dec,clojure.test.check.generators.neg_int);\n/**\n * Creates a generator of vectors whose elements are chosen from\n *   `generator`. The count of the vector will be bounded by the `size`\n *   generator parameter.\n */\nclojure.test.check.generators.vector = (function clojure$test$check$generators$vector(var_args){\nvar G__46046 = arguments.length;\nswitch (G__46046) {\ncase 1:\nreturn clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1 = (function (generator){\nif(clojure.test.check.generators.generator_QMARK_(generator)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Arg to vector must be a generator\",\"\\n\",\"(generator? generator)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_bind(clojure.test.check.generators.sized((function (p1__46042_SHARP_){\nreturn clojure.test.check.generators.choose((0),p1__46042_SHARP_);\n})),(function (num_elements_rose){\nreturn clojure.test.check.generators.gen_fmap((function (roses){\nreturn clojure.test.check.rose_tree.shrink_vector(cljs.core.vector,roses);\n}),clojure.test.check.generators.gen_tuple(cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(clojure.test.check.rose_tree.root(num_elements_rose),generator)));\n}));\n}));\n\n(clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$2 = (function (generator,num_elements){\nif(clojure.test.check.generators.generator_QMARK_(generator)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to vector must be a generator\",\"\\n\",\"(generator? generator)\"].join('')));\n}\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.tuple,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(num_elements,generator));\n}));\n\n(clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$3 = (function (generator,min_elements,max_elements){\nif(clojure.test.check.generators.generator_QMARK_(generator)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to vector must be a generator\",\"\\n\",\"(generator? generator)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_bind(clojure.test.check.generators.choose(min_elements,max_elements),(function (num_elements_rose){\nreturn clojure.test.check.generators.gen_fmap((function (roses){\nreturn clojure.test.check.rose_tree.filter((function (v){\nreturn (((cljs.core.count(v) >= min_elements)) && ((cljs.core.count(v) <= max_elements)));\n}),clojure.test.check.rose_tree.shrink_vector(cljs.core.vector,roses));\n}),clojure.test.check.generators.gen_tuple(cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(clojure.test.check.rose_tree.root(num_elements_rose),generator)));\n}));\n}));\n\n(clojure.test.check.generators.vector.cljs$lang$maxFixedArity = 3);\n\n/**\n * Like `vector`, but generates lists.\n */\nclojure.test.check.generators.list = (function clojure$test$check$generators$list(generator){\nif(clojure.test.check.generators.generator_QMARK_(generator)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to list must be a generator\",\"\\n\",\"(generator? generator)\"].join('')));\n}\n\nreturn clojure.test.check.generators.gen_bind(clojure.test.check.generators.sized((function (p1__46053_SHARP_){\nreturn clojure.test.check.generators.choose((0),p1__46053_SHARP_);\n})),(function (num_elements_rose){\nreturn clojure.test.check.generators.gen_fmap((function (roses){\nreturn clojure.test.check.rose_tree.shrink_vector(cljs.core.list,roses);\n}),clojure.test.check.generators.gen_tuple(cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(clojure.test.check.rose_tree.root(num_elements_rose),generator)));\n}));\n});\nclojure.test.check.generators.swap = (function clojure$test$check$generators$swap(coll,p__46058){\nvar vec__46059 = p__46058;\nvar i1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46059,(0),null);\nvar i2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46059,(1),null);\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(coll,i2,(coll.cljs$core$IFn$_invoke$arity$1 ? coll.cljs$core$IFn$_invoke$arity$1(i1) : coll.call(null,i1)),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([i1,(coll.cljs$core$IFn$_invoke$arity$1 ? coll.cljs$core$IFn$_invoke$arity$1(i2) : coll.call(null,i2))], 0));\n});\n/**\n * Creates a generator that generates random permutations of\n *   `coll`. Shrinks toward the original collection: `coll`. `coll` will\n *   be coerced to a vector.\n */\nclojure.test.check.generators.shuffle = (function clojure$test$check$generators$shuffle(coll){\nvar coll__$1 = ((cljs.core.vector_QMARK_(coll))?coll:cljs.core.vec(coll));\nvar index_gen = clojure.test.check.generators.choose((0),(cljs.core.count(coll__$1) - (1)));\nreturn clojure.test.check.generators.fmap((function (p1__46062_SHARP_){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(clojure.test.check.generators.swap,coll__$1,p1__46062_SHARP_);\n}),clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$3(clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([index_gen,index_gen], 0)),(0),((2) * cljs.core.count(coll__$1))));\n});\n/**\n * Like clojure.core/hash-map, except the values are generators.\n * Returns a generator that makes maps with the supplied keys and\n * values generated using the supplied generators.\n * \n *     (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n *     => ({:a false, :b 0}\n *         {:a true,  :b 1}\n *         {:a false, :b 2}\n *         {:a true,  :b 2}\n *         {:a false, :b 4}\n *         {:a false, :b 2}\n *         {:a true,  :b 3}\n *         {:a true,  :b 4}\n *         {:a false, :b 1}\n *         {:a false, :b 0})\n */\nclojure.test.check.generators.hash_map = (function clojure$test$check$generators$hash_map(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___46432 = arguments.length;\nvar i__5770__auto___46433 = (0);\nwhile(true){\nif((i__5770__auto___46433 < len__5769__auto___46432)){\nargs__5775__auto__.push((arguments[i__5770__auto___46433]));\n\nvar G__46434 = (i__5770__auto___46433 + (1));\ni__5770__auto___46433 = G__46434;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((0) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn clojure.test.check.generators.hash_map.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(clojure.test.check.generators.hash_map.cljs$core$IFn$_invoke$arity$variadic = (function (kvs){\nif(cljs.core.even_QMARK_(cljs.core.count(kvs))){\n} else {\nthrow (new Error(\"Assert failed: (even? (count kvs))\"));\n}\n\nvar ks = cljs.core.take_nth.cljs$core$IFn$_invoke$arity$2((2),kvs);\nvar vs = cljs.core.take_nth.cljs$core$IFn$_invoke$arity$2((2),cljs.core.rest(kvs));\nif(cljs.core.every_QMARK_(clojure.test.check.generators.generator_QMARK_,vs)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Value args to hash-map must be generators\",\"\\n\",\"(every? generator? vs)\"].join('')));\n}\n\nreturn clojure.test.check.generators.fmap((function (p1__46066_SHARP_){\nreturn cljs.core.zipmap(ks,p1__46066_SHARP_);\n}),cljs.core.apply.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.tuple,vs));\n}));\n\n(clojure.test.check.generators.hash_map.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(clojure.test.check.generators.hash_map.cljs$lang$applyTo = (function (seq46067){\nvar self__5755__auto__ = this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq46067));\n}));\n\nclojure.test.check.generators.transient_set_contains_QMARK_ = (function clojure$test$check$generators$transient_set_contains_QMARK_(s,k){\nreturn (!((cljs.core._lookup(s,k) == null)));\n});\n/**\n * Returns a rose tree.\n */\nclojure.test.check.generators.coll_distinct_by_STAR_ = (function clojure$test$check$generators$coll_distinct_by_STAR_(empty_coll,key_fn,shuffle_fn,gen,rng,size,num_elements,min_elements,max_tries,ex_fn){\nif(cljs.core.truth_(gen)){\n} else {\nthrow (new Error(\"Assert failed: gen\"));\n}\n\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"gen\",\"gen\",142575302).cljs$core$IFn$_invoke$arity$1(gen))){\n} else {\nthrow (new Error(\"Assert failed: (:gen gen)\"));\n}\n\nvar rose_trees = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nvar s = cljs.core.transient$(cljs.core.PersistentHashSet.EMPTY);\nvar rng__$1 = rng;\nvar size__$1 = size;\nvar tries = (0);\nwhile(true){\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(max_tries,tries)) && ((cljs.core.count(rose_trees) < min_elements)))){\nthrow (function (){var G__46085 = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"gen\",\"gen\",142575302),gen,new cljs.core.Keyword(null,\"max-tries\",\"max-tries\",-1824441792),max_tries,new cljs.core.Keyword(null,\"num-elements\",\"num-elements\",1960422107),num_elements], null);\nreturn (ex_fn.cljs$core$IFn$_invoke$arity$1 ? ex_fn.cljs$core$IFn$_invoke$arity$1(G__46085) : ex_fn.call(null,G__46085));\n})();\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(max_tries,tries)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(rose_trees),num_elements)))){\nreturn clojure.test.check.rose_tree.shrink_vector(((function (rose_trees,s,rng__$1,size__$1,tries){\nreturn (function() { \nvar G__46436__delegate = function (rest__46072_SHARP_){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(empty_coll,rest__46072_SHARP_);\n};\nvar G__46436 = function (var_args){\nvar rest__46072_SHARP_ = null;\nif (arguments.length > 0) {\nvar G__46437__i = 0, G__46437__a = new Array(arguments.length -  0);\nwhile (G__46437__i < G__46437__a.length) {G__46437__a[G__46437__i] = arguments[G__46437__i + 0]; ++G__46437__i;}\n  rest__46072_SHARP_ = new cljs.core.IndexedSeq(G__46437__a,0,null);\n} \nreturn G__46436__delegate.call(this,rest__46072_SHARP_);};\nG__46436.cljs$lang$maxFixedArity = 0;\nG__46436.cljs$lang$applyTo = (function (arglist__46438){\nvar rest__46072_SHARP_ = cljs.core.seq(arglist__46438);\nreturn G__46436__delegate(rest__46072_SHARP_);\n});\nG__46436.cljs$core$IFn$_invoke$arity$variadic = G__46436__delegate;\nreturn G__46436;\n})()\n;})(rose_trees,s,rng__$1,size__$1,tries))\n,(function (){var G__46088 = rng__$1;\nvar G__46089 = cljs.core.persistent_BANG_(rose_trees);\nreturn (shuffle_fn.cljs$core$IFn$_invoke$arity$2 ? shuffle_fn.cljs$core$IFn$_invoke$arity$2(G__46088,G__46089) : shuffle_fn.call(null,G__46088,G__46089));\n})());\n} else {\nvar vec__46090 = clojure.test.check.random.split(rng__$1);\nvar rng1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46090,(0),null);\nvar rng2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46090,(1),null);\nvar rose = clojure.test.check.generators.call_gen(gen,rng1,size__$1);\nvar root = clojure.test.check.rose_tree.root(rose);\nvar k = (key_fn.cljs$core$IFn$_invoke$arity$1 ? key_fn.cljs$core$IFn$_invoke$arity$1(root) : key_fn.call(null,root));\nif(clojure.test.check.generators.transient_set_contains_QMARK_(s,k)){\nvar G__46439 = rose_trees;\nvar G__46440 = s;\nvar G__46441 = rng2;\nvar G__46442 = (size__$1 + (1));\nvar G__46443 = (tries + (1));\nrose_trees = G__46439;\ns = G__46440;\nrng__$1 = G__46441;\nsize__$1 = G__46442;\ntries = G__46443;\ncontinue;\n} else {\nvar G__46444 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(rose_trees,rose);\nvar G__46445 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(s,k);\nvar G__46446 = rng2;\nvar G__46447 = size__$1;\nvar G__46448 = (0);\nrose_trees = G__46444;\ns = G__46445;\nrng__$1 = G__46446;\nsize__$1 = G__46447;\ntries = G__46448;\ncontinue;\n}\n\n}\n}\nbreak;\n}\n});\n/**\n * Like clojure.core/distinct? but takes a collection instead of varargs,\n *   and returns true for empty collections.\n */\nclojure.test.check.generators.distinct_by_QMARK_ = (function clojure$test$check$generators$distinct_by_QMARK_(f,coll){\nvar or__5045__auto__ = cljs.core.empty_QMARK_(coll);\nif(or__5045__auto__){\nreturn or__5045__auto__;\n} else {\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.distinct_QMARK_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,coll));\n}\n});\n/**\n * Returns a shuffled version of coll according to the rng.\n * \n *   Note that this is not a generator, it is just a utility function.\n */\nclojure.test.check.generators.the_shuffle_fn = (function clojure$test$check$generators$the_shuffle_fn(rng,coll){\nvar empty_coll = cljs.core.empty(coll);\nvar v = cljs.core.vec(coll);\nvar card = cljs.core.count(coll);\nvar dec_card = (card - (1));\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(empty_coll,cljs.core.first(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__46099,idx){\nvar vec__46101 = p__46099;\nvar v__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46101,(0),null);\nvar rng__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46101,(1),null);\nvar vec__46104 = clojure.test.check.random.split(rng__$1);\nvar rng1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46104,(0),null);\nvar rng2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46104,(1),null);\nvar swap_idx = clojure.test.check.generators.rand_range(rng1,idx,dec_card);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [clojure.test.check.generators.swap(v__$1,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [idx,swap_idx], null)),rng2], null);\n}),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [v,rng], null),cljs.core.range.cljs$core$IFn$_invoke$arity$1(card))));\n});\nclojure.test.check.generators.coll_distinct_by = (function clojure$test$check$generators$coll_distinct_by(empty_coll,key_fn,allows_dupes_QMARK_,ordered_QMARK_,gen,p__46117){\nvar map__46118 = p__46117;\nvar map__46118__$1 = cljs.core.__destructure_map(map__46118);\nvar num_elements = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46118__$1,new cljs.core.Keyword(null,\"num-elements\",\"num-elements\",1960422107));\nvar min_elements = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46118__$1,new cljs.core.Keyword(null,\"min-elements\",\"min-elements\",949370780));\nvar max_elements = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46118__$1,new cljs.core.Keyword(null,\"max-elements\",\"max-elements\",433034073));\nvar max_tries = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__46118__$1,new cljs.core.Keyword(null,\"max-tries\",\"max-tries\",-1824441792),(10));\nvar ex_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__46118__$1,new cljs.core.Keyword(null,\"ex-fn\",\"ex-fn\",-284925510),(function (p1__46108_SHARP_){\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"Couldn't generate enough distinct elements!\",p1__46108_SHARP_);\n}));\nvar shuffle_fn = (cljs.core.truth_(ordered_QMARK_)?clojure.test.check.generators.the_shuffle_fn:(function (_rng,coll){\nreturn coll;\n}));\nvar hard_min_elements = (function (){var or__5045__auto__ = num_elements;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nvar or__5045__auto____$1 = min_elements;\nif(cljs.core.truth_(or__5045__auto____$1)){\nreturn or__5045__auto____$1;\n} else {\nreturn (1);\n}\n}\n})();\nif(cljs.core.truth_(num_elements)){\nvar size_pred = (function (p1__46109_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(num_elements,cljs.core.count(p1__46109_SHARP_));\n});\nif((((min_elements == null)) && ((max_elements == null)))){\n} else {\nthrow (new Error(\"Assert failed: (and (nil? min-elements) (nil? max-elements))\"));\n}\n\nreturn clojure.test.check.generators.make_gen((function (rng,gen_size){\nreturn clojure.test.check.rose_tree.filter((cljs.core.truth_(allows_dupes_QMARK_)?cljs.core.every_pred.cljs$core$IFn$_invoke$arity$2(size_pred,(function (p1__46110_SHARP_){\nreturn clojure.test.check.generators.distinct_by_QMARK_(key_fn,p1__46110_SHARP_);\n})):size_pred),clojure.test.check.generators.coll_distinct_by_STAR_(empty_coll,key_fn,shuffle_fn,gen,rng,gen_size,num_elements,hard_min_elements,max_tries,ex_fn));\n}));\n} else {\nvar min_elements__$1 = (function (){var or__5045__auto__ = min_elements;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn (0);\n}\n})();\nvar size_pred = (cljs.core.truth_(max_elements)?(function (p1__46111_SHARP_){\nreturn (((min_elements__$1 <= cljs.core.count(p1__46111_SHARP_))) && ((cljs.core.count(p1__46111_SHARP_) <= max_elements)));\n}):(function (p1__46112_SHARP_){\nreturn (min_elements__$1 <= cljs.core.count(p1__46112_SHARP_));\n}));\nreturn clojure.test.check.generators.gen_bind((cljs.core.truth_(max_elements)?clojure.test.check.generators.choose(min_elements__$1,max_elements):clojure.test.check.generators.sized((function (p1__46113_SHARP_){\nreturn clojure.test.check.generators.choose(min_elements__$1,(min_elements__$1 + p1__46113_SHARP_));\n}))),(function (num_elements_rose){\nvar num_elements__$1 = clojure.test.check.rose_tree.root(num_elements_rose);\nreturn clojure.test.check.generators.make_gen((function (rng,gen_size){\nreturn clojure.test.check.rose_tree.filter((cljs.core.truth_(allows_dupes_QMARK_)?cljs.core.every_pred.cljs$core$IFn$_invoke$arity$2(size_pred,(function (p1__46115_SHARP_){\nreturn clojure.test.check.generators.distinct_by_QMARK_(key_fn,p1__46115_SHARP_);\n})):size_pred),clojure.test.check.generators.coll_distinct_by_STAR_(empty_coll,key_fn,shuffle_fn,gen,rng,gen_size,num_elements__$1,hard_min_elements,max_tries,ex_fn));\n}));\n}));\n}\n});\n/**\n * Generates a vector of elements from the given generator, with the\n *   guarantee that the elements will be distinct.\n * \n *   If the generator cannot or is unlikely to produce enough distinct\n *   elements, this generator will fail in the same way as `such-that`.\n * \n *   Available options:\n * \n *  :num-elements  the fixed size of generated vectors\n *  :min-elements  the min size of generated vectors\n *  :max-elements  the max size of generated vectors\n *  :max-tries     the number of times the generator will be tried before\n *                 failing when it does not produce distinct elements\n *                 (default 10)\n *  :ex-fn         a function of one arg that will be called if test.check cannot\n *                 generate enough distinct values; it will be passed a map with\n *                 `:gen`, `:num-elements`, and `:max-tries` and should return an\n *                 exception\n */\nclojure.test.check.generators.vector_distinct = (function clojure$test$check$generators$vector_distinct(var_args){\nvar G__46126 = arguments.length;\nswitch (G__46126) {\ncase 1:\nreturn clojure.test.check.generators.vector_distinct.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.vector_distinct.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.vector_distinct.cljs$core$IFn$_invoke$arity$1 = (function (gen){\nreturn clojure.test.check.generators.vector_distinct.cljs$core$IFn$_invoke$arity$2(gen,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(clojure.test.check.generators.vector_distinct.cljs$core$IFn$_invoke$arity$2 = (function (gen,opts){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to vector-distinct must be a generator!\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.coll_distinct_by(cljs.core.PersistentVector.EMPTY,cljs.core.identity,true,true,gen,opts);\n}));\n\n(clojure.test.check.generators.vector_distinct.cljs$lang$maxFixedArity = 2);\n\n/**\n * Generates a list of elements from the given generator, with the\n *   guarantee that the elements will be distinct.\n * \n *   If the generator cannot or is unlikely to produce enough distinct\n *   elements, this generator will fail in the same way as `such-that`.\n * \n *   Available options:\n * \n *  :num-elements  the fixed size of generated list\n *  :min-elements  the min size of generated list\n *  :max-elements  the max size of generated list\n *  :max-tries     the number of times the generator will be tried before\n *                 failing when it does not produce distinct elements\n *                 (default 10)\n *  :ex-fn         a function of one arg that will be called if test.check cannot\n *                 generate enough distinct values; it will be passed a map with\n *                 `:gen`, `:num-elements`, and `:max-tries` and should return an\n *                 exception\n */\nclojure.test.check.generators.list_distinct = (function clojure$test$check$generators$list_distinct(var_args){\nvar G__46131 = arguments.length;\nswitch (G__46131) {\ncase 1:\nreturn clojure.test.check.generators.list_distinct.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.list_distinct.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.list_distinct.cljs$core$IFn$_invoke$arity$1 = (function (gen){\nreturn clojure.test.check.generators.list_distinct.cljs$core$IFn$_invoke$arity$2(gen,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(clojure.test.check.generators.list_distinct.cljs$core$IFn$_invoke$arity$2 = (function (gen,opts){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to list-distinct must be a generator!\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.coll_distinct_by(cljs.core.List.EMPTY,cljs.core.identity,true,true,gen,opts);\n}));\n\n(clojure.test.check.generators.list_distinct.cljs$lang$maxFixedArity = 2);\n\n/**\n * Generates a vector of elements from the given generator, with the\n *   guarantee that (map key-fn the-vector) will be distinct.\n * \n *   If the generator cannot or is unlikely to produce enough distinct\n *   elements, this generator will fail in the same way as `such-that`.\n * \n *   Available options:\n * \n *  :num-elements  the fixed size of generated vectors\n *  :min-elements  the min size of generated vectors\n *  :max-elements  the max size of generated vectors\n *  :max-tries     the number of times the generator will be tried before\n *                 failing when it does not produce distinct elements\n *                 (default 10)\n *  :ex-fn         a function of one arg that will be called if test.check cannot\n *                 generate enough distinct values; it will be passed a map with\n *                 `:gen`, `:num-elements`, and `:max-tries` and should return an\n *                 exception\n */\nclojure.test.check.generators.vector_distinct_by = (function clojure$test$check$generators$vector_distinct_by(var_args){\nvar G__46134 = arguments.length;\nswitch (G__46134) {\ncase 2:\nreturn clojure.test.check.generators.vector_distinct_by.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.test.check.generators.vector_distinct_by.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.vector_distinct_by.cljs$core$IFn$_invoke$arity$2 = (function (key_fn,gen){\nreturn clojure.test.check.generators.vector_distinct_by.cljs$core$IFn$_invoke$arity$3(key_fn,gen,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(clojure.test.check.generators.vector_distinct_by.cljs$core$IFn$_invoke$arity$3 = (function (key_fn,gen,opts){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Second arg to vector-distinct-by must be a generator!\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.coll_distinct_by(cljs.core.PersistentVector.EMPTY,key_fn,true,true,gen,opts);\n}));\n\n(clojure.test.check.generators.vector_distinct_by.cljs$lang$maxFixedArity = 3);\n\n/**\n * Generates a list of elements from the given generator, with the\n *   guarantee that (map key-fn the-list) will be distinct.\n * \n *   If the generator cannot or is unlikely to produce enough distinct\n *   elements, this generator will fail in the same way as `such-that`.\n * \n *   Available options:\n * \n *  :num-elements  the fixed size of generated list\n *  :min-elements  the min size of generated list\n *  :max-elements  the max size of generated list\n *  :max-tries     the number of times the generator will be tried before\n *                 failing when it does not produce distinct elements\n *                 (default 10)\n *  :ex-fn         a function of one arg that will be called if test.check cannot\n *                 generate enough distinct values; it will be passed a map with\n *                 `:gen`, `:num-elements`, and `:max-tries` and should return an\n *                 exception\n */\nclojure.test.check.generators.list_distinct_by = (function clojure$test$check$generators$list_distinct_by(var_args){\nvar G__46138 = arguments.length;\nswitch (G__46138) {\ncase 2:\nreturn clojure.test.check.generators.list_distinct_by.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.test.check.generators.list_distinct_by.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.list_distinct_by.cljs$core$IFn$_invoke$arity$2 = (function (key_fn,gen){\nreturn clojure.test.check.generators.list_distinct_by.cljs$core$IFn$_invoke$arity$3(key_fn,gen,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(clojure.test.check.generators.list_distinct_by.cljs$core$IFn$_invoke$arity$3 = (function (key_fn,gen,opts){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Second arg to list-distinct-by must be a generator!\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.coll_distinct_by(cljs.core.List.EMPTY,key_fn,true,true,gen,opts);\n}));\n\n(clojure.test.check.generators.list_distinct_by.cljs$lang$maxFixedArity = 3);\n\n/**\n * Generates a set of elements from the given generator.\n * \n *   If the generator cannot or is unlikely to produce enough distinct\n *   elements, this generator will fail in the same way as `such-that`.\n * \n *   Available options:\n * \n *  :num-elements  the fixed size of generated set\n *  :min-elements  the min size of generated set\n *  :max-elements  the max size of generated set\n *  :max-tries     the number of times the generator will be tried before\n *                 failing when it does not produce distinct elements\n *                 (default 10)\n *  :ex-fn         a function of one arg that will be called if test.check cannot\n *                 generate enough distinct values; it will be passed a map with\n *                 `:gen`, `:num-elements`, and `:max-tries` and should return an\n *                 exception\n */\nclojure.test.check.generators.set = (function clojure$test$check$generators$set(var_args){\nvar G__46142 = arguments.length;\nswitch (G__46142) {\ncase 1:\nreturn clojure.test.check.generators.set.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.set.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.set.cljs$core$IFn$_invoke$arity$1 = (function (gen){\nreturn clojure.test.check.generators.set.cljs$core$IFn$_invoke$arity$2(gen,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(clojure.test.check.generators.set.cljs$core$IFn$_invoke$arity$2 = (function (gen,opts){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to set must be a generator!\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.coll_distinct_by(cljs.core.PersistentHashSet.EMPTY,cljs.core.identity,false,false,gen,opts);\n}));\n\n(clojure.test.check.generators.set.cljs$lang$maxFixedArity = 2);\n\n/**\n * Generates a sorted set of elements from the given generator.\n * \n *   If the generator cannot or is unlikely to produce enough distinct\n *   elements, this generator will fail in the same way as `such-that`.\n * \n *   Available options:\n * \n *  :num-elements  the fixed size of generated set\n *  :min-elements  the min size of generated set\n *  :max-elements  the max size of generated set\n *  :max-tries     the number of times the generator will be tried before\n *                 failing when it does not produce distinct elements\n *                 (default 10)\n *  :ex-fn         a function of one arg that will be called if test.check cannot\n *                 generate enough distinct values; it will be passed a map with\n *                 `:gen`, `:num-elements`, and `:max-tries` and should return an\n *                 exception\n */\nclojure.test.check.generators.sorted_set = (function clojure$test$check$generators$sorted_set(var_args){\nvar G__46146 = arguments.length;\nswitch (G__46146) {\ncase 1:\nreturn clojure.test.check.generators.sorted_set.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn clojure.test.check.generators.sorted_set.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.sorted_set.cljs$core$IFn$_invoke$arity$1 = (function (gen){\nreturn clojure.test.check.generators.sorted_set.cljs$core$IFn$_invoke$arity$2(gen,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(clojure.test.check.generators.sorted_set.cljs$core$IFn$_invoke$arity$2 = (function (gen,opts){\nif(clojure.test.check.generators.generator_QMARK_(gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"First arg to sorted-set must be a generator!\",\"\\n\",\"(generator? gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.coll_distinct_by(cljs.core.sorted_set(),cljs.core.identity,false,false,gen,opts);\n}));\n\n(clojure.test.check.generators.sorted_set.cljs$lang$maxFixedArity = 2);\n\n/**\n * Creates a generator that generates maps, with keys chosen from\n *   `key-gen` and values chosen from `val-gen`.\n * \n *   If the key generator cannot or is unlikely to produce enough distinct\n *   elements, this generator will fail in the same way as `such-that`.\n * \n *   Available options:\n * \n *  :num-elements  the fixed size of generated maps\n *  :min-elements  the min size of generated maps\n *  :max-elements  the max size of generated maps\n *  :max-tries     the number of times the generator will be tried before\n *                 failing when it does not produce distinct elements\n *                 (default 10)\n *  :ex-fn         a function of one arg that will be called if test.check cannot\n *                 generate enough distinct keys; it will be passed a map with\n *                 `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n *                 should return an exception\n */\nclojure.test.check.generators.map = (function clojure$test$check$generators$map(var_args){\nvar G__46151 = arguments.length;\nswitch (G__46151) {\ncase 2:\nreturn clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$2 = (function (key_gen,val_gen){\nreturn clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$3(key_gen,val_gen,cljs.core.PersistentArrayMap.EMPTY);\n}));\n\n(clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$3 = (function (key_gen,val_gen,opts){\nreturn clojure.test.check.generators.coll_distinct_by(cljs.core.PersistentArrayMap.EMPTY,cljs.core.first,false,false,clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([key_gen,val_gen], 0)),opts);\n}));\n\n(clojure.test.check.generators.map.cljs$lang$maxFixedArity = 3);\n\n/**\n * Generates a single uniformly random long, does not shrink.\n */\nclojure.test.check.generators.gen_raw_long = clojure.test.check.generators.make_gen((function (rnd,_size){\nreturn clojure.test.check.rose_tree.pure(clojure.test.check.random.rand_long(rnd));\n}));\nclojure.test.check.generators.MAX_INTEGER = (cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._STAR_,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2((53),(2))) - (1));\nclojure.test.check.generators.MIN_INTEGER = (- clojure.test.check.generators.MAX_INTEGER);\nclojure.test.check.generators.abs = (function clojure$test$check$generators$abs(x){\nreturn Math.abs(x);\n});\nclojure.test.check.generators.long__GT_large_integer = (function clojure$test$check$generators$long__GT_large_integer(bit_count,x,min,max){\nvar res = (function (){var G__46159 = x.shiftRight(((64) - bit_count)).toNumber();\nif((min === (0))){\nreturn clojure.test.check.generators.abs(G__46159);\n} else {\nreturn G__46159;\n}\n})();\nwhile(true){\nif((((min <= res)) && ((res <= max)))){\nreturn res;\n} else {\nvar res_SINGLEQUOTE_ = (- res);\nif((((min <= res_SINGLEQUOTE_)) && ((res_SINGLEQUOTE_ <= max)))){\nreturn res_SINGLEQUOTE_;\n} else {\nvar G__46462 = ((function (){var G__46161 = res;\nif(cljs.core.odd_QMARK_(res)){\nvar fexpr__46162 = (((res < (0)))?cljs.core.inc:cljs.core.dec);\nreturn (fexpr__46162.cljs$core$IFn$_invoke$arity$1 ? fexpr__46162.cljs$core$IFn$_invoke$arity$1(G__46161) : fexpr__46162.call(null,G__46161));\n} else {\nreturn G__46161;\n}\n})() / (2));\nres = G__46462;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Like large-integer*, but assumes range includes zero.\n */\nclojure.test.check.generators.large_integer_STAR__STAR_ = (function clojure$test$check$generators$large_integer_STAR__STAR_(min,max){\nreturn clojure.test.check.generators.sized((function (size){\nvar size__$1 = (function (){var x__5130__auto__ = size;\nvar y__5131__auto__ = (1);\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})();\nvar max_bit_count = (function (){var x__5133__auto__ = size__$1;\nvar y__5134__auto__ = (54);\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})();\nreturn clojure.test.check.generators.gen_fmap((function (rose){\nvar vec__46167 = clojure.test.check.rose_tree.root(rose);\nvar bit_count = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46167,(0),null);\nvar x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46167,(1),null);\nreturn clojure.test.check.generators.int_rose_tree(clojure.test.check.generators.long__GT_large_integer(bit_count,x,min,max));\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.test.check.generators.choose((1),max_bit_count),clojure.test.check.generators.gen_raw_long], 0)));\n}));\n});\n/**\n * Like large-integer, but accepts options:\n * \n *  :min  the minimum integer (inclusive)\n *  :max  the maximum integer (inclusive)\n * \n *   Both :min and :max are optional.\n * \n *    (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n *    => (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)\n */\nclojure.test.check.generators.large_integer_STAR_ = (function clojure$test$check$generators$large_integer_STAR_(p__46175){\nvar map__46176 = p__46175;\nvar map__46176__$1 = cljs.core.__destructure_map(map__46176);\nvar min = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46176__$1,new cljs.core.Keyword(null,\"min\",\"min\",444991522));\nvar max = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46176__$1,new cljs.core.Keyword(null,\"max\",\"max\",61366548));\nvar min__$1 = (function (){var or__5045__auto__ = min;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn clojure.test.check.generators.MIN_INTEGER;\n}\n})();\nvar max__$1 = (function (){var or__5045__auto__ = max;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn clojure.test.check.generators.MAX_INTEGER;\n}\n})();\nif((min__$1 <= max__$1)){\n} else {\nthrow (new Error(\"Assert failed: (<= min max)\"));\n}\n\nreturn clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2((function (p1__46170_SHARP_){\nreturn (((min__$1 <= p1__46170_SHARP_)) && ((p1__46170_SHARP_ <= max__$1)));\n}),(((((min__$1 <= (0))) && (((0) <= max__$1))))?clojure.test.check.generators.large_integer_STAR__STAR_(min__$1,max__$1):(((max__$1 < (0)))?clojure.test.check.generators.fmap((function (p1__46171_SHARP_){\nreturn (max__$1 + p1__46171_SHARP_);\n}),clojure.test.check.generators.large_integer_STAR__STAR_((min__$1 - max__$1),(0))):clojure.test.check.generators.fmap((function (p1__46174_SHARP_){\nreturn (min__$1 + p1__46174_SHARP_);\n}),clojure.test.check.generators.large_integer_STAR__STAR_((0),(max__$1 - min__$1))))));\n});\n/**\n * Generates a platform-native integer from the full available range\n *   (in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and\n *   (2^53 - 1)).\n * \n *   Use large-integer* for more control.\n */\nclojure.test.check.generators.large_integer = clojure.test.check.generators.large_integer_STAR_(cljs.core.PersistentArrayMap.EMPTY);\nclojure.test.check.generators.POS_INFINITY = Number.POSITIVE_INFINITY;\nclojure.test.check.generators.NEG_INFINITY = Number.NEGATIVE_INFINITY;\nclojure.test.check.generators.MAX_POS_VALUE = Number.MAX_VALUE;\nclojure.test.check.generators.MIN_NEG_VALUE = (- clojure.test.check.generators.MAX_POS_VALUE);\nclojure.test.check.generators.NAN = Number.NaN;\n/**\n * Generates an integer uniformly in the range 0..(2^bit-count-1).\n */\nclojure.test.check.generators.uniform_integer = (function clojure$test$check$generators$uniform_integer(bit_count){\nif((bit_count <= (32))){\nreturn clojure.test.check.generators.choose((0),(function (){var G__46182 = cljs.core.long$(bit_count);\nswitch (G__46182) {\ncase (32):\nreturn (4294967295);\n\nbreak;\ncase (31):\nreturn (2147483647);\n\nbreak;\ndefault:\nreturn (((1) << bit_count) - (1));\n\n}\n})());\n} else {\nreturn clojure.test.check.generators.fmap((function (p__46184){\nvar vec__46185 = p__46184;\nvar upper = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46185,(0),null);\nvar lower = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46185,(1),null);\nreturn ((upper * (4294967296)) + lower);\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([(function (){var G__46188 = (bit_count - (32));\nreturn (clojure.test.check.generators.uniform_integer.cljs$core$IFn$_invoke$arity$1 ? clojure.test.check.generators.uniform_integer.cljs$core$IFn$_invoke$arity$1(G__46188) : clojure.test.check.generators.uniform_integer.call(null,G__46188));\n})(),(clojure.test.check.generators.uniform_integer.cljs$core$IFn$_invoke$arity$1 ? clojure.test.check.generators.uniform_integer.cljs$core$IFn$_invoke$arity$1((32)) : clojure.test.check.generators.uniform_integer.call(null,(32)))], 0)));\n}\n});\nclojure.test.check.generators.scalb = (function clojure$test$check$generators$scalb(x,exp){\nreturn (x * Math.pow((2),exp));\n});\n/**\n * Bit-reverses an integer in the range [0, 2^52).\n */\nclojure.test.check.generators.fifty_two_bit_reverse = (function clojure$test$check$generators$fifty_two_bit_reverse(n){\nvar out = (0);\nvar n__$1 = n;\nvar out_shifter = Math.pow((2),(52));\nwhile(true){\nif((n__$1 < (1))){\nreturn (out * out_shifter);\n} else {\nvar G__46471 = ((out * (2)) + (n__$1 & (1)));\nvar G__46472 = (n__$1 / (2));\nvar G__46473 = (out_shifter / (2));\nout = G__46471;\nn__$1 = G__46472;\nout_shifter = G__46473;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Generates a 52-bit non-negative integer that shrinks toward having\n *   fewer lower-order bits (and shrinks to 0 if possible).\n */\nclojure.test.check.generators.backwards_shrinking_significand = clojure.test.check.generators.fmap(clojure.test.check.generators.fifty_two_bit_reverse,clojure.test.check.generators.sized((function (size){\nreturn clojure.test.check.generators.gen_bind(clojure.test.check.generators.choose((0),(function (){var x__5133__auto__ = size;\nvar y__5134__auto__ = (52);\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})()),(function (rose){\nreturn clojure.test.check.generators.uniform_integer(clojure.test.check.rose_tree.root(rose));\n}));\n})));\nclojure.test.check.generators.get_exponent = (function clojure$test$check$generators$get_exponent(x){\nif((x === (0))){\nreturn (-1023);\n} else {\nvar x__$1 = Math.abs(x);\nvar res = Math.floor((Math.log(x__$1) * Math.LOG2E));\nvar t = clojure.test.check.generators.scalb(x__$1,(- res));\nif((t < (1))){\nreturn (res - (1));\n} else {\nif(((2) <= t)){\nreturn (res + (1));\n} else {\nreturn res;\n\n}\n}\n}\n});\n/**\n * Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n *   or -1. Only generates values for exp and sign for which there are\n *   doubles within the given bounds.\n */\nclojure.test.check.generators.double_exp_and_sign = (function clojure$test$check$generators$double_exp_and_sign(lower_bound,upper_bound){\nvar gen_exp = (function clojure$test$check$generators$double_exp_and_sign_$_gen_exp(lb,ub){\nreturn clojure.test.check.generators.sized((function (size){\nvar qs8 = ((1) << cljs.core.quot((function (){var x__5133__auto__ = (200);\nvar y__5134__auto__ = size;\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})(),(8)));\nif((((lb <= (0))) && (((0) <= ub)))){\nreturn clojure.test.check.generators.choose((function (){var x__5130__auto__ = lb;\nvar y__5131__auto__ = (- qs8);\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})(),(function (){var x__5133__auto__ = ub;\nvar y__5134__auto__ = qs8;\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})());\n} else {\nif((ub < (0))){\nreturn clojure.test.check.generators.choose((function (){var x__5130__auto__ = lb;\nvar y__5131__auto__ = (ub - qs8);\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})(),ub);\n} else {\nreturn clojure.test.check.generators.choose(lb,(function (){var x__5133__auto__ = ub;\nvar y__5134__auto__ = (lb + qs8);\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})());\n\n}\n}\n}));\n});\nif((((lower_bound == null)) && ((upper_bound == null)))){\nreturn clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([gen_exp((-1023),(1023)),clojure.test.check.generators.elements(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [1.0,-1.0], null))], 0));\n} else {\nvar lower_bound__$1 = (function (){var or__5045__auto__ = lower_bound;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn clojure.test.check.generators.MIN_NEG_VALUE;\n}\n})();\nvar upper_bound__$1 = (function (){var or__5045__auto__ = upper_bound;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn clojure.test.check.generators.MAX_POS_VALUE;\n}\n})();\nvar lbexp = (function (){var x__5130__auto__ = (-1023);\nvar y__5131__auto__ = clojure.test.check.generators.get_exponent(lower_bound__$1);\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})();\nvar ubexp = (function (){var x__5130__auto__ = (-1023);\nvar y__5131__auto__ = clojure.test.check.generators.get_exponent(upper_bound__$1);\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})();\nif((0.0 <= lower_bound__$1)){\nreturn clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([gen_exp(lbexp,ubexp),clojure.test.check.generators.return$(1.0)], 0));\n} else {\nif((upper_bound__$1 <= 0.0)){\nreturn clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([gen_exp(ubexp,lbexp),clojure.test.check.generators.return$(-1.0)], 0));\n} else {\nreturn clojure.test.check.generators.fmap((function (p__46210){\nvar vec__46211 = p__46210;\nvar exp = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46211,(0),null);\nvar sign = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46211,(1),null);\nvar pair = vec__46211;\nif((((((sign < (0))) && ((lbexp < exp)))) || ((((sign > (0))) && ((ubexp < exp)))))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [exp,(- sign)], null);\n} else {\nreturn pair;\n}\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([gen_exp((-1023),(function (){var x__5130__auto__ = ubexp;\nvar y__5131__auto__ = lbexp;\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})()),clojure.test.check.generators.elements(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [1.0,-1.0], null))], 0)));\n\n}\n}\n}\n});\n/**\n * Returns [low high], the smallest and largest numbers in the given\n *   range.\n */\nclojure.test.check.generators.block_bounds = (function clojure$test$check$generators$block_bounds(exp,sign){\nif((sign < (0))){\nvar vec__46234 = (function (){var G__46237 = exp;\nvar G__46238 = (- sign);\nreturn (clojure.test.check.generators.block_bounds.cljs$core$IFn$_invoke$arity$2 ? clojure.test.check.generators.block_bounds.cljs$core$IFn$_invoke$arity$2(G__46237,G__46238) : clojure.test.check.generators.block_bounds.call(null,G__46237,G__46238));\n})();\nvar low = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46234,(0),null);\nvar high = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46234,(1),null);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(- high),(- low)], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((-1023),exp)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [0.0,clojure.test.check.generators.scalb((clojure.test.check.generators.scalb(1.0,(52)) - (1)),(-1074))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [clojure.test.check.generators.scalb(1.0,exp),clojure.test.check.generators.scalb((clojure.test.check.generators.scalb(1.0,(52)) - (1)),(exp - (51)))], null);\n}\n}\n});\nclojure.test.check.generators.double_finite = (function clojure$test$check$generators$double_finite(lower_bound,upper_bound){\nif((((lower_bound == null)) || ((((upper_bound == null)) || ((lower_bound <= upper_bound)))))){\n} else {\nthrow (new Error(\"Assert failed: (or (nil? lower-bound) (nil? upper-bound) (<= lower-bound upper-bound))\"));\n}\n\nvar pred = (cljs.core.truth_(lower_bound)?(cljs.core.truth_(upper_bound)?(function (p1__46251_SHARP_){\nreturn (((lower_bound <= p1__46251_SHARP_)) && ((p1__46251_SHARP_ <= upper_bound)));\n}):(function (p1__46252_SHARP_){\nreturn (lower_bound <= p1__46252_SHARP_);\n})):(cljs.core.truth_(upper_bound)?(function (p1__46253_SHARP_){\nreturn (p1__46253_SHARP_ <= upper_bound);\n}):null));\nvar gen = clojure.test.check.generators.fmap((function (p__46270){\nvar vec__46275 = p__46270;\nvar vec__46278 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46275,(0),null);\nvar exp = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46278,(0),null);\nvar sign = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46278,(1),null);\nvar significand = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46275,(1),null);\nvar base = ((significand / Math.pow((2),(52))) + (1));\nvar x = (clojure.test.check.generators.scalb(base,exp) * sign);\nif(cljs.core.truth_((function (){var or__5045__auto__ = (pred == null);\nif(or__5045__auto__){\nreturn or__5045__auto__;\n} else {\nreturn (pred.cljs$core$IFn$_invoke$arity$1 ? pred.cljs$core$IFn$_invoke$arity$1(x) : pred.call(null,x));\n}\n})())){\nreturn x;\n} else {\nvar vec__46285 = clojure.test.check.generators.block_bounds(exp,sign);\nvar low = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46285,(0),null);\nvar high = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46285,(1),null);\nvar block_lb = (function (){var G__46290 = low;\nif(cljs.core.truth_(lower_bound)){\nvar x__5130__auto__ = G__46290;\nvar y__5131__auto__ = lower_bound;\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n} else {\nreturn G__46290;\n}\n})();\nvar block_ub = (function (){var G__46295 = high;\nif(cljs.core.truth_(upper_bound)){\nvar x__5133__auto__ = G__46295;\nvar y__5134__auto__ = upper_bound;\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n} else {\nreturn G__46295;\n}\n})();\nvar x__$1 = (block_lb + ((block_ub - block_lb) * (base - (1))));\nvar x__5130__auto__ = (function (){var x__5133__auto__ = x__$1;\nvar y__5134__auto__ = block_ub;\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})();\nvar y__5131__auto__ = block_lb;\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n}\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.test.check.generators.double_exp_and_sign(lower_bound,upper_bound),clojure.test.check.generators.backwards_shrinking_significand], 0)));\nvar G__46298 = gen;\nif(cljs.core.truth_(pred)){\nreturn clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2(pred,G__46298);\n} else {\nreturn G__46298;\n}\n});\n/**\n * Generates a 64-bit floating point number. Options:\n * \n *  :infinite? - whether +/- infinity can be generated (default true)\n *  :NaN?      - whether NaN can be generated (default true)\n *  :min       - minimum value (inclusive, default none)\n *  :max       - maximum value (inclusive, default none)\n * \n *   Note that the min/max options must be finite numbers. Supplying a\n *   min precludes -Infinity, and supplying a max precludes +Infinity.\n */\nclojure.test.check.generators.double_STAR_ = (function clojure$test$check$generators$double_STAR_(p__46305){\nvar map__46310 = p__46305;\nvar map__46310__$1 = cljs.core.__destructure_map(map__46310);\nvar infinite_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__46310__$1,new cljs.core.Keyword(null,\"infinite?\",\"infinite?\",-2017886608),true);\nvar NaN_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__46310__$1,new cljs.core.Keyword(null,\"NaN?\",\"NaN?\",-1917767651),true);\nvar min = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46310__$1,new cljs.core.Keyword(null,\"min\",\"min\",444991522));\nvar max = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46310__$1,new cljs.core.Keyword(null,\"max\",\"max\",61366548));\nvar frequency_arg = (function (){var G__46311 = new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(95),clojure.test.check.generators.double_finite(min,max)], null)], null);\nvar G__46311__$1 = (((((min == null))?(((max == null)) || ((0.0 <= max))):(((max == null))?(min <= 0.0):(((min <= 0.0)) && ((0.0 <= max))))))?cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic(G__46311,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.return$(0.0)], null),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.return$(-0.0)], null)], 0)):G__46311);\nvar G__46311__$2 = (cljs.core.truth_((function (){var and__5043__auto__ = infinite_QMARK_;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn (max == null);\n} else {\nreturn and__5043__auto__;\n}\n})())?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(G__46311__$1,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.return$(clojure.test.check.generators.POS_INFINITY)], null)):G__46311__$1);\nvar G__46311__$3 = (cljs.core.truth_((function (){var and__5043__auto__ = infinite_QMARK_;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn (min == null);\n} else {\nreturn and__5043__auto__;\n}\n})())?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(G__46311__$2,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.return$(clojure.test.check.generators.NEG_INFINITY)], null)):G__46311__$2);\nif(cljs.core.truth_(NaN_QMARK_)){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(G__46311__$3,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.return$(clojure.test.check.generators.NAN)], null));\n} else {\nreturn G__46311__$3;\n}\n})();\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2((1),cljs.core.count(frequency_arg))){\nreturn cljs.core.second(cljs.core.first(frequency_arg));\n} else {\nreturn clojure.test.check.generators.frequency(frequency_arg);\n}\n});\n/**\n * Generates 64-bit floating point numbers from the entire range,\n *   including +/- infinity and NaN. Use double* for more control.\n */\nclojure.test.check.generators.double$ = clojure.test.check.generators.double_STAR_(cljs.core.PersistentArrayMap.EMPTY);\n/**\n * Generates character from 0-255.\n */\nclojure.test.check.generators.char$ = clojure.test.check.generators.fmap(cljs.core.char$,clojure.test.check.generators.choose((0),(255)));\n/**\n * Generates only ascii characters.\n */\nclojure.test.check.generators.char_ascii = clojure.test.check.generators.fmap(cljs.core.char$,clojure.test.check.generators.choose((32),(126)));\n/**\n * Generates alphanumeric characters.\n */\nclojure.test.check.generators.char_alphanumeric = clojure.test.check.generators.fmap(cljs.core.char$,clojure.test.check.generators.one_of(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [clojure.test.check.generators.choose((48),(57)),clojure.test.check.generators.choose((65),(90)),clojure.test.check.generators.choose((97),(122))], null)));\n/**\n * Deprecated - use char-alphanumeric instead.\n * \n *   Generates alphanumeric characters.\n */\nclojure.test.check.generators.char_alpha_numeric = clojure.test.check.generators.char_alphanumeric;\n/**\n * Generates alpha characters.\n */\nclojure.test.check.generators.char_alpha = clojure.test.check.generators.fmap(cljs.core.char$,clojure.test.check.generators.one_of(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [clojure.test.check.generators.choose((65),(90)),clojure.test.check.generators.choose((97),(122))], null)));\n/**\n * Generates non-alphanumeric characters that can be in a symbol.\n */\nclojure.test.check.generators.char_symbol_special = clojure.test.check.generators.elements(new cljs.core.PersistentVector(null, 7, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"*\",\"+\",\"!\",\"-\",\"_\",\"?\",\".\"], null));\n/**\n * Generates characters that can be the char following first of a keyword or symbol.\n */\nclojure.test.check.generators.char_symbol_noninitial = clojure.test.check.generators.frequency(new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(14),clojure.test.check.generators.char_alphanumeric], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(7),clojure.test.check.generators.char_symbol_special], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.return$(\":\")], null)], null));\n/**\n * Generates characters that can be the first char of a keyword or symbol.\n */\nclojure.test.check.generators.char_symbol_initial = clojure.test.check.generators.frequency(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(2),clojure.test.check.generators.char_alpha], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.char_symbol_special], null)], null));\n/**\n * Generates strings. May generate unprintable characters.\n */\nclojure.test.check.generators.string = clojure.test.check.generators.fmap(clojure.string.join,clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1(clojure.test.check.generators.char$));\n/**\n * Generates ascii strings.\n */\nclojure.test.check.generators.string_ascii = clojure.test.check.generators.fmap(clojure.string.join,clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1(clojure.test.check.generators.char_ascii));\n/**\n * Generates alphanumeric strings.\n */\nclojure.test.check.generators.string_alphanumeric = clojure.test.check.generators.fmap(clojure.string.join,clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1(clojure.test.check.generators.char_alphanumeric));\n/**\n * Deprecated - use string-alphanumeric instead.\n * \n *   Generates alphanumeric strings.\n */\nclojure.test.check.generators.string_alpha_numeric = clojure.test.check.generators.string_alphanumeric;\nclojure.test.check.generators.digit_QMARK_ = (function clojure$test$check$generators$digit_QMARK_(d){\nreturn goog.string.isNumeric(d);\n});\n/**\n * Returns true if c is \\+ or \\- and d is non-nil and a digit.\n * \n *   Symbols that start with +3 or -2 are not readable because they look\n *   like numbers.\n */\nclojure.test.check.generators._PLUS__or___digit_QMARK_ = (function clojure$test$check$generators$_PLUS__or___digit_QMARK_(c,d){\nreturn cljs.core.boolean$((function (){var and__5043__auto__ = d;\nif(cljs.core.truth_(and__5043__auto__)){\nvar and__5043__auto____$1 = (((\"+\" === c)) || ((\"-\" === c)));\nif(and__5043__auto____$1){\nreturn clojure.test.check.generators.digit_QMARK_(d);\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n})());\n});\n/**\n * Generates a namespace string for a symbol/keyword.\n */\nclojure.test.check.generators.symbol_name_or_namespace = clojure.test.check.generators.fmap((function (p__46329){\nvar vec__46330 = p__46329;\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46330,(0),null);\nvar cs = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46330,(1),null);\nvar s = clojure.string.join.cljs$core$IFn$_invoke$arity$1(cljs.core.cons(c,cs));\nreturn clojure.string.replace(clojure.string.replace(s,/:{2,}/,\":\"),/:$/,\"\");\n}),clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2((function (p__46333){\nvar vec__46334 = p__46333;\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46334,(0),null);\nvar vec__46337 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46334,(1),null);\nvar d = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46337,(0),null);\nreturn (!(clojure.test.check.generators._PLUS__or___digit_QMARK_(c,d)));\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.test.check.generators.char_symbol_initial,clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1(clojure.test.check.generators.char_symbol_noninitial)], 0))));\n/**\n * Scales the sizing down on a keyword or symbol generator so as to\n *   make it reasonable.\n */\nclojure.test.check.generators.resize_symbolish_generator = (function clojure$test$check$generators$resize_symbolish_generator(g){\nreturn clojure.test.check.generators.scale((function (p1__46340_SHARP_){\nreturn cljs.core.long$(Math.pow(p1__46340_SHARP_,0.6));\n}),g);\n});\n/**\n * Generates keywords without namespaces.\n */\nclojure.test.check.generators.keyword = clojure.test.check.generators.resize_symbolish_generator(clojure.test.check.generators.fmap(cljs.core.keyword,clojure.test.check.generators.symbol_name_or_namespace));\n/**\n * Generates keywords with namespaces.\n */\nclojure.test.check.generators.keyword_ns = clojure.test.check.generators.resize_symbolish_generator(clojure.test.check.generators.fmap((function (p__46341){\nvar vec__46342 = p__46341;\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46342,(0),null);\nvar name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46342,(1),null);\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$2(ns,name);\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.test.check.generators.symbol_name_or_namespace,clojure.test.check.generators.symbol_name_or_namespace], 0))));\n/**\n * Generates symbols without namespaces.\n */\nclojure.test.check.generators.symbol = clojure.test.check.generators.frequency(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(100),clojure.test.check.generators.resize_symbolish_generator(clojure.test.check.generators.fmap(cljs.core.symbol,clojure.test.check.generators.symbol_name_or_namespace))], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),clojure.test.check.generators.return$(new cljs.core.Symbol(null,\"/\",\"/\",-1371932971,null))], null)], null));\n/**\n * Generates symbols with namespaces.\n */\nclojure.test.check.generators.symbol_ns = clojure.test.check.generators.resize_symbolish_generator(clojure.test.check.generators.fmap((function (p__46345){\nvar vec__46346 = p__46345;\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46346,(0),null);\nvar name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46346,(1),null);\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(ns,name);\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.test.check.generators.symbol_name_or_namespace,clojure.test.check.generators.symbol_name_or_namespace], 0))));\n/**\n * Generates a small ratio (or integer) using gen/small-integer. Shrinks\n *   toward simpler ratios, which may be larger or smaller.\n */\nclojure.test.check.generators.ratio = clojure.test.check.generators.fmap((function (p__46349){\nvar vec__46350 = p__46349;\nvar a = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46350,(0),null);\nvar b = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46350,(1),null);\nreturn (a / b);\n}),clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([clojure.test.check.generators.small_integer,clojure.test.check.generators.fmap(cljs.core.inc,clojure.test.check.generators.nat)], 0)));\n/**\n * Generates a random type-4 UUID. Does not shrink.\n */\nclojure.test.check.generators.uuid = clojure.test.check.generators.no_shrink(clojure.test.check.generators.fmap((function (nibbles){\nvar hex = (function clojure$test$check$generators$hex(idx){\nreturn (nibbles.cljs$core$IFn$_invoke$arity$1 ? nibbles.cljs$core$IFn$_invoke$arity$1(idx) : nibbles.call(null,idx)).toString((16));\n});\nvar rhex = (((nibbles.cljs$core$IFn$_invoke$arity$1 ? nibbles.cljs$core$IFn$_invoke$arity$1((15)) : nibbles.call(null,(15))) & (3)) + (8)).toString((16));\nreturn cljs.core.uuid([cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((0))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((1))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((2))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((3))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((4))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((5))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((6))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((7))),\"-\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((8))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((9))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((10))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((11))),\"-\",\"4\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((12))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((13))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((14))),\"-\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(rhex),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((16))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((17))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((18))),\"-\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((19))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((20))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((21))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((22))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((23))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((24))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((25))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((26))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((27))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((28))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((29))),cljs.core.str.cljs$core$IFn$_invoke$arity$1(hex((30)))].join(''));\n}),clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.choose((0),(15)),(31))));\nclojure.test.check.generators.base_simple_type = (function clojure$test$check$generators$base_simple_type(double_gen,char_gen,string_gen){\nreturn clojure.test.check.generators.one_of(new cljs.core.PersistentVector(null, 12, 5, cljs.core.PersistentVector.EMPTY_NODE, [clojure.test.check.generators.int$,clojure.test.check.generators.large_integer,double_gen,char_gen,string_gen,clojure.test.check.generators.ratio,clojure.test.check.generators.boolean$,clojure.test.check.generators.keyword,clojure.test.check.generators.keyword_ns,clojure.test.check.generators.symbol,clojure.test.check.generators.symbol_ns,clojure.test.check.generators.uuid], null));\n});\n/**\n * Generates a variety of scalar types.\n */\nclojure.test.check.generators.simple_type = clojure.test.check.generators.base_simple_type(clojure.test.check.generators.double$,clojure.test.check.generators.char$,clojure.test.check.generators.string);\n/**\n * Generates a variety of scalar types, with printable strings.\n */\nclojure.test.check.generators.simple_type_printable = clojure.test.check.generators.base_simple_type(clojure.test.check.generators.double$,clojure.test.check.generators.char_ascii,clojure.test.check.generators.string_ascii);\n/**\n * Like gen/simple-type, but only generates objects that can be\n *   equal to other objects (e.g., not a NaN).\n */\nclojure.test.check.generators.simple_type_equatable = clojure.test.check.generators.base_simple_type(clojure.test.check.generators.double_STAR_(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"NaN?\",\"NaN?\",-1917767651),false], null)),clojure.test.check.generators.char$,clojure.test.check.generators.string);\n/**\n * Like gen/simple-type-printable, but only generates objects that\n *   can be equal to other objects (e.g., not a NaN).\n */\nclojure.test.check.generators.simple_type_printable_equatable = clojure.test.check.generators.base_simple_type(clojure.test.check.generators.double_STAR_(new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"NaN?\",\"NaN?\",-1917767651),false], null)),clojure.test.check.generators.char_ascii,clojure.test.check.generators.string_ascii);\nclojure.test.check.generators.hashable_QMARK_ = (function clojure$test$check$generators$hashable_QMARK_(x){\nif(typeof x === 'number'){\nreturn cljs.core.not((function (){var or__5045__auto__ = isNaN(x);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.NEG_INFINITY,x)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.POS_INFINITY,x)));\n}\n})());\n} else {\nreturn true;\n}\n});\nclojure.test.check.generators.container_type = (function clojure$test$check$generators$container_type(inner_type){\nreturn clojure.test.check.generators.one_of(new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1(inner_type),clojure.test.check.generators.list(inner_type),clojure.test.check.generators.set.cljs$core$IFn$_invoke$arity$1(clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.hashable_QMARK_,inner_type)),clojure.test.check.generators.scale((function (p1__46355_SHARP_){\nreturn cljs.core.quot(p1__46355_SHARP_,(2));\n}),clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2(clojure.test.check.generators.hashable_QMARK_,inner_type),inner_type))], null));\n});\nclojure.test.check.generators.size__GT_max_leaf_count = (function clojure$test$check$generators$size__GT_max_leaf_count(size){\nreturn cljs.core.long$(Math.pow(size,1.1));\n});\nvar log2_46500 = Math.log((2));\n/**\n * Returns (not generates) a random collection of integers `xs`\n *   greater than 1 such that (<= (apply * xs) n).\n */\nclojure.test.check.generators.random_pseudofactoring = (function clojure$test$check$generators$random_pseudofactoring(n,rng){\nif((n <= (2))){\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [n], null);\n} else {\nvar log = Math.log(n);\nvar vec__46357 = clojure.test.check.random.split(rng);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46357,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46357,(1),null);\nvar n1 = cljs.core.long$(Math.exp(((clojure.test.check.random.rand_double(r1) * (log - log2_46500)) + log2_46500)));\nvar n2 = cljs.core.quot(n,n1);\nif(((((1) < n1)) && (((1) < n2)))){\nreturn cljs.core.cons(n1,(clojure.test.check.generators.random_pseudofactoring.cljs$core$IFn$_invoke$arity$2 ? clojure.test.check.generators.random_pseudofactoring.cljs$core$IFn$_invoke$arity$2(n2,r2) : clojure.test.check.generators.random_pseudofactoring.call(null,n2,r2)));\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [n], null);\n}\n}\n});\n/**\n * Like sized, but passes an rng instead of a size.\n */\nclojure.test.check.generators.randomized = (function clojure$test$check$generators$randomized(func){\nreturn clojure.test.check.generators.make_gen((function (rng,size){\nvar vec__46360 = clojure.test.check.random.split(rng);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46360,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46360,(1),null);\nreturn clojure.test.check.generators.call_gen((func.cljs$core$IFn$_invoke$arity$1 ? func.cljs$core$IFn$_invoke$arity$1(r1) : func.call(null,r1)),r2,size);\n}));\n});\n/**\n * This is a helper for writing recursive (tree-shaped) generators. The first\n *   argument should be a function that takes a generator as an argument, and\n *   produces another generator that 'contains' that generator. The vector function\n *   in this namespace is a simple example. The second argument is a scalar\n *   generator, like boolean. For example, to produce a tree of booleans:\n * \n *  (gen/recursive-gen gen/vector gen/boolean)\n * \n *   Vectors or maps either recurring or containing booleans or integers:\n * \n *  (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n *                                              (gen/map inner inner)]))\n *                     (gen/one-of [gen/boolean gen/small-integer]))\n * \n *   Note that raw scalar values will be generated as well. To prevent this, you\n *   can wrap the returned generator with the function passed as the first arg,\n *   e.g.:\n * \n *  (gen/vector (gen/recursive-gen gen/vector gen/boolean))\n */\nclojure.test.check.generators.recursive_gen = (function clojure$test$check$generators$recursive_gen(container_gen_fn,scalar_gen){\nif(clojure.test.check.generators.generator_QMARK_(scalar_gen)){\n} else {\nthrow (new Error([\"Assert failed: \",\"Second arg to recursive-gen must be a generator\",\"\\n\",\"(generator? scalar-gen)\"].join('')));\n}\n\nreturn clojure.test.check.generators.sized((function (size){\nreturn clojure.test.check.generators.bind(clojure.test.check.generators.choose((0),clojure.test.check.generators.size__GT_max_leaf_count(size)),(function (max_leaf_count){\nreturn clojure.test.check.generators.randomized((function (rng){\nvar sizes = clojure.test.check.generators.random_pseudofactoring(max_leaf_count,rng);\nvar sized_scalar_gen = clojure.test.check.generators.resize(size,scalar_gen);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (g,size__$1){\nreturn clojure.test.check.generators.bind(clojure.test.check.generators.choose((0),(10)),(function (x){\nif((x === (0))){\nreturn sized_scalar_gen;\n} else {\nreturn clojure.test.check.generators.resize(size__$1,(container_gen_fn.cljs$core$IFn$_invoke$arity$1 ? container_gen_fn.cljs$core$IFn$_invoke$arity$1(g) : container_gen_fn.call(null,g)));\n}\n}));\n}),sized_scalar_gen,sizes);\n}));\n}));\n}));\n});\n/**\n * A recursive generator that will generate many different, often nested, values\n */\nclojure.test.check.generators.any = clojure.test.check.generators.recursive_gen(clojure.test.check.generators.container_type,clojure.test.check.generators.simple_type);\n/**\n * Like any, but avoids characters that the shell will interpret as actions,\n *   like 7 and 14 (bell and alternate character set command)\n */\nclojure.test.check.generators.any_printable = clojure.test.check.generators.recursive_gen(clojure.test.check.generators.container_type,clojure.test.check.generators.simple_type_printable);\n/**\n * Like any, but only generates objects that can be equal to other objects (e.g., do\n *   not contain a NaN)\n */\nclojure.test.check.generators.any_equatable = clojure.test.check.generators.recursive_gen(clojure.test.check.generators.container_type,clojure.test.check.generators.simple_type_equatable);\n/**\n * Like any, but avoids characters that the shell will interpret as actions,\n *   like 7 and 14 (bell and alternate character set command), and only generates\n *   objects that can be equal to other objects (e.g., do not contain a NaN)\n */\nclojure.test.check.generators.any_printable_equatable = clojure.test.check.generators.recursive_gen(clojure.test.check.generators.container_type,clojure.test.check.generators.simple_type_printable_equatable);\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check/generators.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",34],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.core","~$cljs.core","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.core.match","~$cljs.core.match"],"~:use-macros",["^ ","~$let","~$clojure.test.check.generators"],"~:excludes",["~#set",["~$uuid","~$set","~$namespace","~$boolean","~$map","~$char","~$shuffle","^I","~$double","~$int","~$symbol","~$sorted-set","~$vector","~$not-empty","~$list","~$abs","~$keyword","~$hash-map","~$byte","~$sequence","~$bytes"]],"~:macros",["^ ","^I",["^ ","~:added","0.9.0","~:ns","^J","~:name","~$clojure.test.check.generators/let","^6","clojure/test/check/generators.cljc","^8",1,"^7",1721,"~:macro",true,"~:arglists",["~#list",[["~$bindings","~$&","~$body"]]],"~:doc","Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \"users\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (->> users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))"]],"^18","^J","~:reader-aliases",["^ "],"~:op","^17","~:imports",null,"~:requires",["^ ","~$gstring","~$goog.string","~$rose","~$clojure.test.check.rose-tree","^1G","^1G","^1E","^1E","^C","^C","~$goog","^1H","~$clojure.test.check.random","^1I","~$string","~$clojure.string","^1K","^1K","~$random","^1I","~$core","^C"],"~:seen",["^L",["~:require","~:require-macros"]],"~:uses",null,"^1P",["^ ","^C","^C","^1M","^C","^J","^J"],"~:form",["^1<",["~$ns","^J",["^1<",["~:refer-clojure","~:exclude",["^[","^U","^X","^Z","^11","^Q","^10","^R","^P","^12","^14","^13","^S","^Y","^V","^O","^N","^W","^M","^T","^I"]]],["^1<",["^1O",["^C","~:as","^1M","~:include-macros",true],["^1K","^1V","^1J"],["^1I","^1V","^1L"],["^1G","^1V","^1F"],["^1E","^1V","^1D"],["^1K"]]],["^1<",["^1P",["^J","~:refer",["^I"]]]]]],"~:flags",["^ ","^1O",["^L",[]],"^1P",["^L",[]]],"~:js-deps",["^ "],"~:deps",["^1H","^C","^1K","^1I","^1G","^1E"]],"^17","^J","~:resource-id",["~:shadow.build.classpath/resource","clojure/test/check/generators.cljc"],"~:compiled-at",1692014592085,"^1@",["^ ","^1D","^1E","^1F","^1G","^1G","^1G","^1E","^1E","^C","^C","^J","^J","^1H","^1H","^1I","^1I","^1J","^1K","^1K","^1K","^1L","^1I","^1M","^C"],"~:resource-name","clojure/test/check/generators.cljc","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.generators\n  (:refer-clojure :exclude [abs int vector list hash-map map keyword\n                            char boolean byte bytes sequence\n                            shuffle not-empty symbol namespace\n                            set sorted-set uuid double let])\n  (:require [#?(:clj clojure.core :cljs cljs.core) :as core\n             #?@(:cljs [:include-macros true])]\n            [clojure.string :as string]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.rose-tree :as rose]\n            #?@(:cljs [[goog.string :as gstring]\n                       [clojure.string]]))\n  #?(:cljs (:require-macros [clojure.test.check.generators :refer [let]])))\n\n;; Gen\n;; (internal functions)\n;; ---------------------------------------------------------------------------\n\n(defrecord Generator [gen])\n\n(defn generator?\n  \"Test if `x` is a generator. Generators should be treated as opaque values.\"\n  [x]\n  (instance? Generator x))\n\n(defn- make-gen\n  [generator-fn]\n  (Generator. generator-fn))\n\n(defn call-gen\n  \"Internal function.\"\n  {:no-doc true}\n  [{generator-fn :gen} rnd size]\n  (generator-fn rnd size))\n\n(defn gen-pure\n  \"Internal function.\"\n  {:no-doc true}\n  [value]\n  (make-gen\n   (fn [rnd size]\n     value)))\n\n(defn gen-fmap\n  \"Internal function.\"\n  {:no-doc true}\n  [k {h :gen}]\n  (make-gen\n   (fn [rnd size]\n     (k (h rnd size)))))\n\n(defn gen-bind\n  \"Internal function.\"\n  {:no-doc true}\n  [{h :gen} k]\n  (make-gen\n   (fn [rnd size]\n     (core/let [[r1 r2] (random/split rnd)\n                inner (h r1 size)\n                {result :gen} (k inner)]\n       (result r2 size)))))\n\n(defn lazy-random-states\n  \"Internal function.\n\n  Given a random number generator, returns an infinite lazy sequence\n  of random number generators.\"\n  {:no-doc true}\n  [rr]\n  (lazy-seq\n   (core/let [[r1 r2] (random/split rr)]\n     (cons r1\n           (lazy-random-states r2)))))\n\n(defn- gen-tuple\n  \"Takes a collection of generators and returns a generator of vectors.\"\n  [gens]\n  (make-gen\n   (fn [rnd size]\n     (mapv #(call-gen % %2 size) gens (random/split-n rnd (count gens))))))\n\n;; Exported generator functions\n;; ---------------------------------------------------------------------------\n\n(defn fmap\n  \"Returns a generator like `gen` but with values transformed by `f`.\n  E.g.:\n\n      (gen/sample (gen/fmap str gen/nat))\n      => (\\\"0\\\" \\\"1\\\" \\\"0\\\" \\\"1\\\" \\\"4\\\" \\\"3\\\" \\\"6\\\" \\\"6\\\" \\\"4\\\" \\\"2\\\")\n\n  Also see gen/let for a macro with similar functionality.\"\n  [f gen]\n  (assert (generator? gen) \"Second arg to fmap must be a generator\")\n  (gen-fmap #(rose/fmap f %) gen))\n\n(defn return\n  \"Creates a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators. E.g.:\n\n      (gen/sample (gen/return 42))\n      => (42 42 42 42 42 42 42 42 42 42)\"\n  [value]\n  (gen-pure (rose/pure value)))\n\n(defn- bind-helper\n  [f]\n  (fn [rose]\n    (gen-fmap rose/join\n              (make-gen\n               (fn [rnd size]\n                 (rose/fmap #(call-gen (f %) rnd size)\n                            rose))))))\n\n(defn bind\n  \"Creates a new generator that passes the result of `gen` into function\n  `f`. `f` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator of permutations which first generates a\n  `num-elements` and then generates a shuffling of `(range num-elements)`:\n\n      (gen/bind gen/nat\n                ;; this function takes a value generated by\n                ;; the generator above and returns a new generator\n                ;; which shuffles the collection returned by `range`\n                (fn [num-elements]\n                  (gen/shuffle (range num-elements))))\n\n  Also see gen/let for a macro with similar functionality.\"\n  [generator f]\n  (assert (generator? generator) \"First arg to bind must be a generator\")\n  (gen-bind generator (bind-helper f)))\n\n;; Helpers\n;; ---------------------------------------------------------------------------\n\n(defn make-size-range-seq\n  \"Internal function.\"\n  {:no-doc true}\n  [max-size]\n  (cycle (range 0 max-size)))\n\n(defn sample-seq\n  \"Returns an infinite sequence of realized values from `generator`.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\"\n  ([generator] (sample-seq generator 200))\n  ([generator max-size]\n   (core/let [r (random/make-random)\n              size-seq (make-size-range-seq max-size)]\n     (core/map #(rose/root (call-gen generator %1 %2))\n               (lazy-random-states r)\n               size-seq))))\n\n(defn sample\n  \"Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\n\n  The sequence starts with small values from the generator, which\n  probably do not reflect the variety of values that will be generated\n  during a longer test run.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\"\n  ([generator]\n   (sample generator 10))\n  ([generator num-samples]\n   (assert (generator? generator) \"First arg to sample must be a generator\")\n   (take num-samples (sample-seq generator))))\n\n(defn generate\n  \"Returns a single sample value from the generator.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\n\n  Optional args:\n\n  - size: the abstract size parameter, defaults to 30\n  - seed: the seed for the random number generator, an integer\"\n  {:added \"0.8.0\"}\n  ([generator]\n   (generate generator 30))\n  ([generator size]\n   (core/let [rng (random/make-random)]\n     (rose/root (call-gen generator rng size))))\n  ([generator size seed]\n   (core/let [rng (random/make-random seed)]\n     (rose/root (call-gen generator rng size)))))\n\n;; Internal Helpers\n;; ---------------------------------------------------------------------------\n\n(defn- halfs\n  [n]\n  (take-while #(not= 0 %) (iterate #(quot % 2) n)))\n\n(defn- shrink-int\n  [integer]\n  (core/map #(- integer %) (halfs integer)))\n\n(defn- int-rose-tree\n  [value]\n  (rose/make-rose value (core/map int-rose-tree (shrink-int value))))\n\n;; calc-long is factored out to support testing the surprisingly tricky double math.  Note:\n;; An extreme long value does not have a precision-preserving representation as a double.\n;; Be careful about changing this code unless you understand what's happening in these\n;; examples:\n;;\n;; (= (long (- Integer/MAX_VALUE (double (- Integer/MAX_VALUE 10)))) 10)\n;; (= (long (- Long/MAX_VALUE (double (- Long/MAX_VALUE 10)))) 0)\n\n(defn- calc-long\n  [factor lower upper]\n  ;; these pre- and post-conditions are disabled for deployment\n  #_ {:pre [(float? factor) (>= factor 0.0) (< factor 1.0)\n            (integer? lower) (integer? upper) (<= lower upper)]\n      :post [(integer? %)]}\n  ;; Use -' on width to maintain accuracy with overflow protection.\n  #?(:clj\n     (core/let [width (-' upper lower -1)]\n       ;; Preserve long precision if the width is in the long range.  Otherwise, we must accept\n       ;; less precision because doubles don't have enough bits to preserve long equivalence at\n       ;; extreme values.\n       (if (< width Long/MAX_VALUE)\n         (+ lower (long (Math/floor (* factor width))))\n         ;; Clamp down to upper because double math.\n         (min upper (long (Math/floor (+ lower (* factor width)))))))\n\n     :cljs\n     (long (Math/floor (+ lower (- (* factor (+ 1.0 upper))\n                                   (* factor lower)))))))\n\n(defn- rand-range\n  [rnd lower upper]\n  {:pre [(<= lower upper)]}\n  (calc-long (random/rand-double rnd) lower upper))\n\n(defn sized\n  \"Creates a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\n\n  Examples:\n\n      ;; generates vectors of booleans where the length always exactly\n      ;; matches the `size` parameter\n      (gen/sample (gen/sized (fn [size] (gen/vector gen/boolean size))))\n      => ([]\n          [false]\n          [true true]\n          [false true false]\n          [false true true true]\n          [false false true true false]\n          [false true false true true false]\n          [true false true true true false false]\n          [true true false false false true false false]\n          [false false false true true false true false true])\"\n  [sized-gen]\n  (make-gen\n   (fn [rnd size]\n     (core/let [sized-gen (sized-gen size)]\n       (call-gen sized-gen rnd size)))))\n\n;; Combinators and helpers\n;; ---------------------------------------------------------------------------\n\n(defn resize\n  \"Creates a new generator with `size` always bound to `n`.\n\n      (gen/sample (gen/set (gen/resize 200 gen/double)))\n      => (#{}\n          #{-4.994772362980037E147}\n          #{-4.234418056487335E-146}\n          #{}\n          #{}\n          #{}\n          #{NaN}\n          #{8.142414100982609E-63}\n          #{-3.58429955903876E-159 2.8563794617604296E-154\n            4.1021360195776005E-100 1.9084564045332549E-38}\n          #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})\"\n  [n generator]\n  (assert (generator? generator) \"Second arg to resize must be a generator\")\n  (core/let [{:keys [gen]} generator]\n    (make-gen\n     (fn [rnd _size]\n       (gen rnd n)))))\n\n(defn scale\n  \"Creates a new generator that modifies the size parameter by the\n  given function. Intended to support generators with sizes that need\n  to grow at different rates compared to the normal linear scaling.\n\n      (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n                             gen/nat\n                             (gen/scale #(* % 10) gen/nat)))\n      => ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n          [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])\"\n  {:added \"0.8.0\"}\n  ([f generator]\n   (sized (fn [n] (resize (f n) generator)))))\n\n(defn choose\n  #?(:clj\n     \"Creates a generator that generates integers uniformly in the range\n     `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)\"\n\n     :cljs\n     \"Creates a generator that generates integer numbers uniformly in\n     the range `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)\")\n  [lower upper]\n  ;; cast to long to support doubles as arguments per TCHECK-73\n  (core/let #?(:clj\n               [lower (long lower)\n                upper (long upper)]\n\n               :cljs ;; does nothing, no long in cljs\n               [])\n    (make-gen\n     (fn [rnd _size]\n       (core/let [value (rand-range rnd lower upper)]\n         (rose/filter\n          #(and (>= % lower) (<= % upper))\n          (int-rose-tree value)))))))\n\n(defn one-of\n  \"Creates a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n      (gen/sample (gen/one-of [gen/small-integer gen/boolean (gen/vector gen/small-integer)]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)\"\n  [generators]\n  (assert (every? generator? generators)\n          \"Arg to one-of must be a collection of generators\")\n  (assert (seq generators)\n          \"one-of cannot be called with an empty collection\")\n  (bind (choose 0 (dec (count generators)))\n        #(nth generators %)))\n\n(defn- pick\n  \"Returns an index into the `likelihoods` sequence.\"\n  [likelihoods n]\n  (->> likelihoods\n       (reductions + 0)\n       (rest)\n       (take-while #(<= % n))\n       (count)))\n\n(defn frequency\n  \"Creates a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods. Shrinks toward\n  choosing an earlier generator, as well as shrinking the value generated\n  by the chosen generator.\n\n  Examples:\n\n      (gen/sample (gen/frequency [[5 gen/small-integer] [3 (gen/vector gen/small-integer)] [2 gen/boolean]]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)\"\n  [pairs]\n  (assert (every? (fn [[x g]] (and (number? x) (generator? g)))\n                  pairs)\n          \"Arg to frequency must be a list of [num generator] pairs\")\n  (core/let [pairs (filter (comp pos? first) pairs)\n             total (apply + (core/map first pairs))]\n    (assert (seq pairs)\n            \"frequency must be called with at least one non-zero weight\")\n    ;; low-level impl for shrinking control\n    (make-gen\n     (fn [rnd size]\n       (call-gen\n        (gen-bind (choose 0 (dec total))\n                  (fn [x]\n                    (core/let [idx (pick (core/map first pairs) (rose/root x))]\n                      (gen-fmap (fn [rose]\n                                  (rose/make-rose (rose/root rose)\n                                                  (lazy-seq\n                                                   (concat\n                                                    ;; try to shrink to earlier generators first\n                                                    (for [idx (range idx)]\n                                                      (call-gen (second (nth pairs idx))\n                                                                rnd\n                                                                size))\n                                                    (rose/children rose)))))\n                                (second (nth pairs idx))))))\n        rnd size)))))\n\n(defn elements\n  \"Creates a generator that randomly chooses an element from `coll`.\n\n      (gen/sample (gen/elements [:foo :bar :baz]))\n      => (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)\"\n  [coll]\n  (assert (seq coll) \"elements cannot be called with an empty collection\")\n  (core/let [v (vec coll)]\n    (gen-fmap #(rose/fmap v %)\n              (choose 0 (dec (count v))))))\n\n(defn- such-that-helper\n  [pred gen {:keys [ex-fn max-tries]} rng size]\n  (loop [tries-left max-tries\n         rng rng\n         size size]\n    (if (zero? tries-left)\n      (throw (ex-fn {:pred pred, :gen, gen :max-tries max-tries}))\n      (core/let [[r1 r2] (random/split rng)\n                 value (call-gen gen r1 size)]\n        (if (pred (rose/root value))\n          (rose/filter pred value)\n          (recur (dec tries-left) r2 (inc size)))))))\n\n(def ^:private\n  default-such-that-opts\n  {:ex-fn (fn [{:keys [max-tries] :as arg}]\n            (ex-info (str \"Couldn't satisfy such-that predicate after \"\n                          max-tries \" tries.\")\n                     arg))\n   :max-tries 10})\n\n(defn such-that\n  \"Creates a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be thrown. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/small-integer))\n\n  You can customize `such-that` by passing an optional third argument, which can\n  either be an integer representing the maximum number of times test.check\n  will try to generate a value matching the predicate, or a map:\n\n      :max-tries  positive integer, the maximum number of tries (default 10)\n      :ex-fn      a function of one arg that will be called if test.check cannot\n                  generate a matching value; it will be passed a map with `:gen`,\n                  `:pred`, and `:max-tries` and should return an exception\"\n  ([pred gen]\n   (such-that pred gen 10))\n  ([pred gen max-tries-or-opts]\n   (core/let [opts (cond (integer? max-tries-or-opts)\n                         {:max-tries max-tries-or-opts}\n\n                         (map? max-tries-or-opts)\n                         max-tries-or-opts\n\n                         :else\n                         (throw (ex-info \"Bad argument to such-that!\" {:max-tries-or-opts\n                                                                       max-tries-or-opts})))\n              opts (merge default-such-that-opts opts)]\n     (assert (generator? gen) \"Second arg to such-that must be a generator\")\n     (make-gen\n      (fn [rand-seed size]\n        (such-that-helper pred gen opts rand-seed size))))))\n\n(defn not-empty\n  \"Modifies a generator so that it doesn't generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n      => ([false]\n          [false false]\n          [false false]\n          [false false false]\n          [false false false false]\n          [false true true]\n          [true false false false]\n          [true]\n          [true true true false false true false]\n          [false true true true false true true true false])\"\n  [gen]\n  (assert (generator? gen) \"Arg to not-empty must be a generator\")\n  (such-that core/not-empty gen))\n\n(defn no-shrink\n  \"Creates a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain.\"\n  [gen]\n  (assert (generator? gen) \"Arg to no-shrink must be a generator\")\n  (gen-fmap (fn [rose]\n              (rose/make-rose (rose/root rose) []))\n            gen))\n\n(defn shrink-2\n  \"Creates a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level).\"\n  [gen]\n  (assert (generator? gen) \"Arg to shrink-2 must be a generator\")\n  (gen-fmap rose/collapse gen))\n\n(def boolean\n  \"Generates one of `true` or `false`. Shrinks to `false`.\"\n  (elements [false true]))\n\n(defn tuple\n  \"Creates a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the vector will never shrink in count.\n\n  Examples:\n\n      (def t (gen/tuple gen/small-integer gen/boolean))\n      (sample t)\n      ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; =>  [3 true] [-4 false] [9 true]))\"\n  [& generators]\n  (assert (every? generator? generators)\n          \"Args to tuple must be generators\")\n  (gen-fmap (fn [roses]\n              (rose/zip core/vector roses))\n            (gen-tuple generators)))\n\n(def nat\n  \"Generates non-negative integers bounded by the generator's `size`\n  parameter. Shrinks to zero.\"\n  (sized (fn [size] (choose 0 size)))\n  #_\n  (fmap #(Math/abs (long %)) int))\n\n(def ^{:added \"0.10.0\"} small-integer\n  \"Generates a positive or negative integer bounded by the generator's\n  `size` parameter. Shrinks to zero.\"\n  (sized (fn [size] (choose (- size) size))))\n\n;; The following five are deprecated due to being confusingly named,\n;; and in some cases not being very useful.\n(def ^{:deprecated \"0.10.0\"} int\n  \"Deprecated - use gen/small-integer instead.\n\n  Generates a positive or negative integer bounded by the generator's\n  `size` parameter.\"\n  small-integer)\n\n(def ^{:deprecated \"0.10.0\"} pos-int\n  \"Deprecated - use gen/nat instead (see also gen/large-integer).\n\n  (this generator, despite its name, can generate 0)\n\n  Generates nonnegative integers bounded by the generator's `size` parameter.\"\n  nat)\n\n(def ^{:deprecated \"0.10.0\"} neg-int\n  \"Deprecated - use (gen/fmap - gen/nat) instead (see also gen/large-integer).\n\n  (this generator, despite its name, can generate 0)\n\n  Generates nonpositive integers bounded by the generator's `size` parameter.\"\n  (fmap #(* -1 %) nat))\n\n(def ^{:deprecated \"0.10.0\"} s-pos-int\n  \"Deprecated - use (gen/fmap inc gen/nat) instead (see also gen/large-integer).\n\n  Generates positive integers bounded by the generator's `size` + 1\"\n  (fmap inc nat))\n\n(def ^{:deprecated \"0.10.0\"} s-neg-int\n  \"Deprecated - use (gen/fmap (comp dec -) gen/nat) instead (see also gen/large-integer).\n\n  Generates negative integers bounded by the generator's `size` + 1\"\n  (fmap dec neg-int))\n\n(defn vector\n  \"Creates a generator of vectors whose elements are chosen from\n  `generator`. The count of the vector will be bounded by the `size`\n  generator parameter.\"\n  ([generator]\n   (assert (generator? generator) \"Arg to vector must be a generator\")\n   (gen-bind\n    (sized #(choose 0 %))\n    (fn [num-elements-rose]\n      (gen-fmap (fn [roses]\n                  (rose/shrink-vector core/vector\n                                      roses))\n                (gen-tuple (repeat (rose/root num-elements-rose)\n                                   generator))))))\n  ([generator num-elements]\n   (assert (generator? generator) \"First arg to vector must be a generator\")\n   (apply tuple (repeat num-elements generator)))\n  ([generator min-elements max-elements]\n   (assert (generator? generator) \"First arg to vector must be a generator\")\n   (gen-bind\n    (choose min-elements max-elements)\n    (fn [num-elements-rose]\n      (gen-fmap (fn [roses]\n                  (rose/filter\n                   (fn [v] (and (>= (count v) min-elements)\n                                (<= (count v) max-elements)))\n                   (rose/shrink-vector core/vector\n                                       roses)))\n                (gen-tuple (repeat (rose/root num-elements-rose)\n                                   generator)))))))\n\n(defn list\n  \"Like `vector`, but generates lists.\"\n  [generator]\n  (assert (generator? generator) \"First arg to list must be a generator\")\n  (gen-bind (sized #(choose 0 %))\n            (fn [num-elements-rose]\n              (gen-fmap (fn [roses]\n                          (rose/shrink-vector core/list\n                                              roses))\n                        (gen-tuple (repeat (rose/root num-elements-rose)\n                                           generator))))))\n\n(defn- swap\n  [coll [i1 i2]]\n  (assoc coll i2 (coll i1) i1 (coll i2)))\n\n(defn\n  ^{:added \"0.6.0\"}\n  shuffle\n  \"Creates a generator that generates random permutations of\n  `coll`. Shrinks toward the original collection: `coll`. `coll` will\n  be coerced to a vector.\"\n  [coll]\n  (core/let [coll (if (vector? coll) coll (vec coll))\n             index-gen (choose 0 (dec (count coll)))]\n    (fmap #(reduce swap coll %)\n          ;; a vector of swap instructions, with count between\n          ;; zero and 2 * count. This means that the average number\n          ;; of instructions is count, which should provide sufficient\n          ;; (though perhaps not 'perfect') shuffling. This still gives us\n          ;; nice, relatively quick shrinks.\n          (vector (tuple index-gen index-gen) 0 (* 2 (count coll))))))\n\n;; NOTE cljs: Comment out for now - David\n\n#?(:clj\n   (def byte\n     \"Generates `java.lang.Byte`s, using the full byte-range.\"\n     (fmap core/byte (choose Byte/MIN_VALUE Byte/MAX_VALUE))))\n\n#?(:clj\n   (def bytes\n     \"Generates byte-arrays.\"\n     (fmap core/byte-array (vector byte))))\n\n(defn hash-map\n  \"Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n       (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n       => ({:a false, :b 0}\n           {:a true,  :b 1}\n           {:a false, :b 2}\n           {:a true,  :b 2}\n           {:a false, :b 4}\n           {:a false, :b 2}\n           {:a true,  :b 3}\n           {:a true,  :b 4}\n           {:a false, :b 1}\n           {:a false, :b 0})\"\n  [& kvs]\n  (assert (even? (count kvs)))\n  (core/let [ks (take-nth 2 kvs)\n             vs (take-nth 2 (rest kvs))]\n    (assert (every? generator? vs)\n            \"Value args to hash-map must be generators\")\n    (fmap #(zipmap ks %)\n          (apply tuple vs))))\n\n;; Collections of distinct elements\n;; (has to be done in a low-level way (instead of with combinators)\n;;  and is subject to the same kind of failure as such-that)\n;; ---------------------------------------------------------------------------\n\n(defn ^:private transient-set-contains?\n  [s k]\n  #? (:clj\n      (.contains ^clojure.lang.ITransientSet s k)\n      :cljs\n      (some? (-lookup s k))))\n\n(defn ^:private coll-distinct-by*\n  \"Returns a rose tree.\"\n  [empty-coll key-fn shuffle-fn gen rng size num-elements min-elements max-tries ex-fn]\n  {:pre [gen (:gen gen)]}\n  (loop [rose-trees (transient [])\n         s (transient #{})\n         rng rng\n         size size\n         tries 0]\n    (cond (and (= max-tries tries)\n               (< (count rose-trees) min-elements))\n          (throw (ex-fn {:gen gen\n                         :max-tries max-tries\n                         :num-elements num-elements}))\n\n          (or (= max-tries tries)\n              (= (count rose-trees) num-elements))\n          (->> (persistent! rose-trees)\n               ;; we shuffle the rose trees so that we aren't biased\n               ;; toward generating \"smaller\" elements earlier in the\n               ;; collection (only applies to ordered collections)\n               ;;\n               ;; shuffling the rose trees is more efficient than\n               ;; (bind ... shuffle) because we only perform the\n               ;; shuffling once and we have no need to shrink the\n               ;; shufling.\n               (shuffle-fn rng)\n               (rose/shrink-vector #(into empty-coll %&)))\n\n          :else\n          (core/let [[rng1 rng2] (random/split rng)\n                     rose (call-gen gen rng1 size)\n                     root (rose/root rose)\n                     k (key-fn root)]\n            (if (transient-set-contains? s k)\n              (recur rose-trees s rng2 (inc size) (inc tries))\n              (recur (conj! rose-trees rose)\n                     (conj! s k)\n                     rng2\n                     size\n                     0))))))\n\n(defn ^:private distinct-by?\n  \"Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections.\"\n  [f coll]\n  (or (empty? coll)\n      (apply distinct? (core/map f coll))))\n\n(defn ^:private the-shuffle-fn\n  \"Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function.\"\n  [rng coll]\n  (core/let [empty-coll (empty coll)\n             v (vec coll)\n             card (count coll)\n             dec-card (dec card)]\n    (into empty-coll\n          (first\n           (reduce (fn [[v rng] idx]\n                     (core/let [[rng1 rng2] (random/split rng)\n                                swap-idx (rand-range rng1 idx dec-card)]\n                       [(swap v [idx swap-idx]) rng2]))\n                   [v rng]\n                   (range card))))))\n\n(defn ^:private coll-distinct-by\n  [empty-coll key-fn allows-dupes? ordered? gen\n   {:keys [num-elements min-elements max-elements max-tries ex-fn]\n    :or {max-tries 10\n         ex-fn #(ex-info \"Couldn't generate enough distinct elements!\" %)}}]\n  (core/let [shuffle-fn (if ordered?\n                          the-shuffle-fn\n                          (fn [_rng coll] coll))\n             hard-min-elements (or num-elements min-elements 1)]\n    (if num-elements\n      (core/let [size-pred #(= num-elements (count %))]\n        (assert (and (nil? min-elements) (nil? max-elements)))\n        (make-gen\n         (fn [rng gen-size]\n           (rose/filter\n            (if allows-dupes?\n              ;; is there a smarter way to do the shrinking than checking\n              ;; the distinctness of the entire collection at each\n              ;; step?\n              (every-pred size-pred #(distinct-by? key-fn %))\n              size-pred)\n            (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                               num-elements hard-min-elements max-tries ex-fn)))))\n      (core/let [min-elements (or min-elements 0)\n                 size-pred (if max-elements\n                             #(<= min-elements (count %) max-elements)\n                             #(<= min-elements (count %)))]\n        (gen-bind\n         (if max-elements\n           (choose min-elements max-elements)\n           (sized #(choose min-elements (+ min-elements %))))\n         (fn [num-elements-rose]\n           (core/let [num-elements (rose/root num-elements-rose)]\n             (make-gen\n              (fn [rng gen-size]\n                (rose/filter\n                 (if allows-dupes?\n                   ;; same comment as above\n                   (every-pred size-pred #(distinct-by? key-fn %))\n                   size-pred)\n                 (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                                    num-elements hard-min-elements max-tries ex-fn)))))))))))\n\n;; I tried to reduce the duplication in these docstrings with a macro,\n;; but couldn't make it work in cljs.\n\n(defn vector-distinct\n  \"Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (vector-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to vector-distinct must be a generator!\")\n   (coll-distinct-by [] identity true true gen opts)))\n\n(defn list-distinct\n  \"Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (list-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to list-distinct must be a generator!\")\n   (coll-distinct-by () identity true true gen opts)))\n\n(defn vector-distinct-by\n  \"Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([key-fn gen] (vector-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) \"Second arg to vector-distinct-by must be a generator!\")\n   (coll-distinct-by [] key-fn true true gen opts)))\n\n(defn list-distinct-by\n  \"Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([key-fn gen] (list-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) \"Second arg to list-distinct-by must be a generator!\")\n   (coll-distinct-by () key-fn true true gen opts)))\n\n(defn set\n  \"Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (set gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to set must be a generator!\")\n   (coll-distinct-by #{} identity false false gen opts)))\n\n(defn sorted-set\n  \"Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception\"\n  {:added \"0.9.0\"}\n  ([gen] (sorted-set gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to sorted-set must be a generator!\")\n   (coll-distinct-by (core/sorted-set) identity false false gen opts)))\n\n(defn map\n  \"Creates a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated maps\n    :min-elements  the min size of generated maps\n    :max-elements  the max size of generated maps\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct keys; it will be passed a map with\n                   `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n                   should return an exception\"\n  ([key-gen val-gen] (map key-gen val-gen {}))\n  ([key-gen val-gen opts]\n   (coll-distinct-by {} first false false (tuple key-gen val-gen) opts)))\n\n;; large integers\n;; ---------------------------------------------------------------------------\n\n;; This approach has a few distribution edge cases, but is pretty good\n;; for expected uses and is way better than nothing.\n\n(def ^:private gen-raw-long\n  \"Generates a single uniformly random long, does not shrink.\"\n  (make-gen (fn [rnd _size]\n              (rose/pure (random/rand-long rnd)))))\n\n(def ^:private MAX_INTEGER\n  #?(:clj Long/MAX_VALUE :cljs (dec (apply * (repeat 53 2)))))\n(def ^:private MIN_INTEGER\n  #?(:clj Long/MIN_VALUE :cljs (- MAX_INTEGER)))\n\n(defn ^:private abs\n  [x]\n  #?(:clj (Math/abs (long x)) :cljs (Math/abs x)))\n\n(defn ^:private long->large-integer\n  [bit-count x min max]\n  (loop [res (-> x\n                 (#?(:clj bit-shift-right :cljs .shiftRight)\n                  (- 64 bit-count))\n                 #?(:cljs .toNumber)\n                 ;; so we don't get into an infinite loop bit-shifting\n                 ;; -1\n                 (cond-> (zero? min) (abs)))]\n    (if (<= min res max)\n      res\n      (core/let [res' (- res)]\n        (if (<= min res' max)\n          res'\n          (recur #?(:clj (bit-shift-right res 1)\n                    ;; emulating bit-shift-right\n                    :cljs (-> res\n                              (cond-> (odd? res)\n                                ((if (neg? res) inc dec)))\n                              (/ 2)))))))))\n\n(defn ^:private large-integer**\n  \"Like large-integer*, but assumes range includes zero.\"\n  [min max]\n  (sized (fn [size]\n           (core/let [size (core/max size 1) ;; no need to worry about size=0\n                      max-bit-count (core/min size #?(:clj 64 :cljs 54))]\n             (gen-fmap (fn [rose]\n                         (core/let [[bit-count x] (rose/root rose)]\n                           (int-rose-tree (long->large-integer bit-count x min max))))\n                       (tuple (choose 1 max-bit-count)\n                              gen-raw-long))))))\n\n(defn large-integer*\n  \"Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\n\n      (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n      => (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)\"\n  {:added \"0.9.0\"}\n  [{:keys [min max]}]\n  (core/let [min (or min MIN_INTEGER)\n             max (or max MAX_INTEGER)]\n    (assert (<= min max))\n    (such-that #(<= min % max)\n               (if (<= min 0 max)\n                 (large-integer** min max)\n                 (if (< max 0)\n                   (fmap #(+ max %) (large-integer** (- min max) 0))\n                   (fmap #(+ min %) (large-integer** 0 (- max min))))))))\n\n(def ^{:added \"0.9.0\"} large-integer\n  \"Generates a platform-native integer from the full available range\n  (in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and\n  (2^53 - 1)).\n\n  Use large-integer* for more control.\"\n  (large-integer* {}))\n\n;; doubles\n;; ---------------------------------------------------------------------------\n\n\n;; This code is a lot more complex than any reasonable person would\n;; expect, for two reasons:\n;;\n;; 1) I wanted the generator to start with simple values and grow with\n;; the size parameter, as well as shrink back to simple values. I\n;; decided to define \"simple\" as numbers with simpler (closer to 0)\n;; exponents, with simpler fractional parts (fewer lower-level bits\n;; set), and with positive being simpler than negative. I also wanted\n;; to take optional min/max parameters, which complicates the hell out\n;; of things.\n;;\n;; 2) It works in CLJS as well, which has fewer utility functions for\n;; doubles, and I wanted it to work exactly the same way in CLJS just\n;; to validate the whole cross-platform situation. It should generate\n;; the exact same numbers on both platforms.\n;;\n;; Some of the lower level stuff could probably be less messy and\n;; faster, especially for CLJS.\n\n(def ^:private POS_INFINITY #?(:clj Double/POSITIVE_INFINITY, :cljs (.-POSITIVE_INFINITY js/Number)))\n(def ^:private NEG_INFINITY #?(:clj Double/NEGATIVE_INFINITY, :cljs (.-NEGATIVE_INFINITY js/Number)))\n(def ^:private MAX_POS_VALUE #?(:clj Double/MAX_VALUE, :cljs (.-MAX_VALUE js/Number)))\n(def ^:private MIN_NEG_VALUE (- MAX_POS_VALUE))\n(def ^:private NAN #?(:clj Double/NaN, :cljs (.-NaN js/Number)))\n\n(defn ^:private uniform-integer\n  \"Generates an integer uniformly in the range 0..(2^bit-count-1).\"\n  [bit-count]\n  {:assert [(<= 0 bit-count 52)]}\n  (if (<= bit-count 32)\n    ;; the case here is just for cljs\n    (choose 0 (case (long bit-count)\n                32 0xffffffff\n                31 0x7fffffff\n                (-> 1 (bit-shift-left bit-count) dec)))\n    (fmap (fn [[upper lower]]\n            #? (:clj\n                (-> upper (bit-shift-left 32) (+ lower))\n\n                :cljs\n                (-> upper (* 0x100000000) (+ lower))))\n          (tuple (uniform-integer (- bit-count 32))\n                 (uniform-integer 32)))))\n\n(defn ^:private scalb\n  [x exp]\n  #?(:clj (Math/scalb ^double x ^int exp)\n     :cljs (* x (.pow js/Math 2 exp))))\n\n(defn ^:private fifty-two-bit-reverse\n  \"Bit-reverses an integer in the range [0, 2^52).\"\n  [n]\n  #? (:clj\n      (-> n (Long/reverse) (unsigned-bit-shift-right 12))\n\n      :cljs\n      (loop [out 0\n             n n\n             out-shifter (Math/pow 2 52)]\n        (if (< n 1)\n          (* out out-shifter)\n          (recur (-> out (* 2) (+ (bit-and n 1)))\n                 (/ n 2)\n                 (/ out-shifter 2))))))\n\n(def ^:private backwards-shrinking-significand\n  \"Generates a 52-bit non-negative integer that shrinks toward having\n  fewer lower-order bits (and shrinks to 0 if possible).\"\n  (fmap fifty-two-bit-reverse\n        (sized (fn [size]\n                 (gen-bind (choose 0 (min size 52))\n                           (fn [rose]\n                             (uniform-integer (rose/root rose))))))))\n\n(defn ^:private get-exponent\n  [x]\n  #? (:clj\n      (Math/getExponent ^Double x)\n\n      :cljs\n      (if (zero? x)\n        -1023\n        (core/let [x (Math/abs x)\n\n                   res\n                   (Math/floor (* (Math/log x) (.-LOG2E js/Math)))\n\n                   t (scalb x (- res))]\n          (cond (< t 1) (dec res)\n                (<= 2 t) (inc res)\n                :else res)))))\n\n(defn ^:private double-exp-and-sign\n  \"Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds.\"\n  [lower-bound upper-bound]\n  (letfn [(gen-exp [lb ub]\n            (sized (fn [size]\n                     (core/let [qs8 (bit-shift-left 1 (quot (min 200 size) 8))]\n                       (cond (<= lb 0 ub)\n                             (choose (max lb (- qs8)) (min ub qs8))\n\n                             (< ub 0)\n                             (choose (max lb (- ub qs8)) ub)\n\n                             :else\n                             (choose lb (min ub (+ lb qs8))))))))]\n    (if (and (nil? lower-bound)\n             (nil? upper-bound))\n      (tuple (gen-exp -1023 1023)\n             (elements [1.0 -1.0]))\n      (core/let [lower-bound (or lower-bound MIN_NEG_VALUE)\n                 upper-bound (or upper-bound MAX_POS_VALUE)\n                 lbexp (max -1023 (get-exponent lower-bound))\n                 ubexp (max -1023 (get-exponent upper-bound))]\n        (cond (<= 0.0 lower-bound)\n              (tuple (gen-exp lbexp ubexp)\n                     (return 1.0))\n\n              (<= upper-bound 0.0)\n              (tuple (gen-exp ubexp lbexp)\n                     (return -1.0))\n\n              :else\n              (fmap (fn [[exp sign :as pair]]\n                      (if (or (and (neg? sign) (< lbexp exp))\n                              (and (pos? sign) (< ubexp exp)))\n                        [exp (- sign)]\n                        pair))\n                    (tuple\n                     (gen-exp -1023 (max ubexp lbexp))\n                     (elements [1.0 -1.0]))))))))\n\n(defn ^:private block-bounds\n  \"Returns [low high], the smallest and largest numbers in the given\n  range.\"\n  [exp sign]\n  (if (neg? sign)\n    (core/let [[low high] (block-bounds exp (- sign))]\n      [(- high) (- low)])\n    (if (= -1023 exp)\n      [0.0 (-> 1.0 (scalb 52) dec (scalb -1074))]\n      [(scalb 1.0 exp)\n       (-> 1.0 (scalb 52) dec (scalb (- exp 51)))])))\n\n(defn ^:private double-finite\n  [lower-bound upper-bound]\n  {:pre [(or (nil? lower-bound)\n             (nil? upper-bound)\n             (<= lower-bound upper-bound))]}\n  (core/let [pred (if lower-bound\n                    (if upper-bound\n                      #(<= lower-bound % upper-bound)\n                      #(<= lower-bound %))\n                    (if upper-bound\n                      #(<= % upper-bound)))\n\n             gen\n             (fmap (fn [[[exp sign] significand]]\n                     (core/let [;; 1.0 <= base < 2.0\n                                base (inc (/ significand (Math/pow 2 52)))\n                                x (-> base (scalb exp) (* sign))]\n                       (if (or (nil? pred) (pred x))\n                         x\n                         ;; Scale things a bit when we have a partial range\n                         ;; to deal with. It won't be great for generating\n                         ;; simple numbers, but oh well.\n                         (core/let [[low high] (block-bounds exp sign)\n\n                                    block-lb (cond-> low  lower-bound (max lower-bound))\n                                    block-ub (cond-> high upper-bound (min upper-bound))\n                                    x (+ block-lb (* (- block-ub block-lb) (- base 1)))]\n                           (-> x (min block-ub) (max block-lb))))))\n                   (tuple (double-exp-and-sign lower-bound upper-bound)\n                          backwards-shrinking-significand))]\n    ;; wrapping in the such-that is necessary for staying in bounds\n    ;; during shrinking\n    (cond->> gen pred (such-that pred))))\n\n(defn double*\n  \"Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity.\"\n  {:added \"0.9.0\"}\n  [{:keys [infinite? NaN? min max]\n    :or {infinite? true, NaN? true}}]\n  (core/let [frequency-arg (cond-> [[95 (double-finite min max)]]\n\n                             (if (nil? min)\n                               (or (nil? max) (<= 0.0 max))\n                               (if (nil? max)\n                                 (<= min 0.0)\n                                 (<= min 0.0 max)))\n                             (conj\n                              ;; Add zeros here as a special case, since\n                              ;; the `finite` code considers zeros rather\n                              ;; complex (as they have a -1023 exponent)\n                              ;;\n                              ;; I think most uses can't distinguish 0.0\n                              ;; from -0.0, but seems worth throwing both\n                              ;; in just in case.\n                              [1 (return 0.0)]\n                              [1 (return -0.0)])\n\n                             (and infinite? (nil? max))\n                             (conj [1 (return POS_INFINITY)])\n\n                             (and infinite? (nil? min))\n                             (conj [1 (return NEG_INFINITY)])\n\n                             NaN? (conj [1 (return NAN)]))]\n    (if (= 1 (count frequency-arg))\n      (-> frequency-arg first second)\n      (frequency frequency-arg))))\n\n(def ^{:added \"0.9.0\"} double\n  \"Generates 64-bit floating point numbers from the entire range,\n  including +/- infinity and NaN. Use double* for more control.\"\n  (double* {}))\n\n;; bigints\n;; ---------------------------------------------------------------------------\n\n#?(:clj\n   (defn ^:private two-pow\n     [exp]\n     (bigint (.shiftLeft (biginteger 1) exp))))\n#?(:clj (def ^:private dec-2-32 0xFFFFFFFF))\n#?(:clj (def ^:private just-2-32 0x100000000))\n\n;; could potentially make this public\n#?(:clj\n   (defn ^:private bounded-bigint\n     \"Generates bigints having the given max-bit-length, i.e. exclusively\n  between -(2^(max-bit-length)) and 2^(max-bit-length).\"\n     [max-bit-length]\n     (fmap\n      (fn [xs]\n        ;; is there a better way to avoid the auto-boxing warnings\n        ;; than these Long constructor calls? I'd rather not start out\n        ;; with bigints since that seems unnecessarily wasteful\n        (loop [multiple  (Long. 1)\n               bits-left max-bit-length\n               xs        xs\n               res       (Long. 0)]\n          (cond (<= 32 bits-left)\n                (recur (*' just-2-32 multiple)\n                       (- bits-left 32)\n                       (rest xs)\n                       (+' res (*' multiple (first xs))))\n\n                (pos? bits-left)\n                (core/let [x (-> xs\n                                 first\n                                 (bit-shift-right (- 32 bits-left)))]\n                  (+' res (*' multiple x)))\n\n                :else\n                res)))\n      (vector (choose 0 dec-2-32)\n              (Math/ceil (/ (core/double max-bit-length) 32))))))\n\n#?(:clj\n   (def ^:private size-bounded-bignat\n     (core/let [poor-shrinking-gen\n                (sized\n                 (fn [size]\n                   (bind (choose 0 (max 0 (* size 6)))\n                         (fn [bit-count]\n                           (if (zero? bit-count)\n                             (return 0)\n                             (fmap #(+' % (two-pow (dec bit-count)))\n                                   (bounded-bigint (dec bit-count))))))))]\n       (gen-fmap (fn [rose] (int-rose-tree (rose/root rose)))\n                 poor-shrinking-gen))))\n\n;; I avoided supporting min/max parameters because they could\n;; contradict the size-boundedness\n;;\n;; I suppose a size-bounded-bigint* could be added with min/max that\n;; throws if the resulting intersection is empty, but maybe that's\n;; weird.\n#?(:clj\n   (def ^{:added \"0.10.0\"} size-bounded-bigint\n     ;; 2^(6*size) was chosen so that with size=200 the generator could\n     ;; generate values larger than Double/MAX_VALUE\n     \"Generates an integer (long or bigint) bounded exclusively by ±2^(6*size).\"\n     (fmap (fn [[n negate? force-bigint?]]\n             (cond-> n\n               negate? -'\n               ;; adds some exciting variety\n               force-bigint? bigint))\n           (tuple size-bounded-bignat\n                  boolean\n                  boolean))))\n\n;; Characters & Strings\n;; ---------------------------------------------------------------------------\n\n(def char\n  \"Generates character from 0-255.\"\n  (fmap core/char (choose 0 255)))\n\n(def char-ascii\n  \"Generates only ascii characters.\"\n  (fmap core/char (choose 32 126)))\n\n(def char-alphanumeric\n  \"Generates alphanumeric characters.\"\n  (fmap core/char\n        (one-of [(choose 48 57)\n                 (choose 65 90)\n                 (choose 97 122)])))\n\n(def ^{:deprecated \"0.6.0\"}\n  char-alpha-numeric\n  \"Deprecated - use char-alphanumeric instead.\n\n  Generates alphanumeric characters.\"\n  char-alphanumeric)\n\n(def char-alpha\n  \"Generates alpha characters.\"\n  (fmap core/char\n        (one-of [(choose 65 90)\n                 (choose 97 122)])))\n\n(def ^:private char-symbol-special\n  \"Generates non-alphanumeric characters that can be in a symbol.\"\n  (elements [\\* \\+ \\! \\- \\_ \\? \\.]))\n\n(def ^:private char-symbol-noninitial\n  \"Generates characters that can be the char following first of a keyword or symbol.\"\n  (frequency [[14 char-alphanumeric]\n              [7 char-symbol-special]\n              [1 (return \\:)]]))\n\n(def ^:private char-symbol-initial\n  \"Generates characters that can be the first char of a keyword or symbol.\"\n  (frequency [[2 char-alpha]\n              [1 char-symbol-special]]))\n\n(def string\n  \"Generates strings. May generate unprintable characters.\"\n  (fmap clojure.string/join (vector char)))\n\n(def string-ascii\n  \"Generates ascii strings.\"\n  (fmap clojure.string/join (vector char-ascii)))\n\n(def string-alphanumeric\n  \"Generates alphanumeric strings.\"\n  (fmap clojure.string/join (vector char-alphanumeric)))\n\n(def ^{:deprecated \"0.6.0\"}\n  string-alpha-numeric\n  \"Deprecated - use string-alphanumeric instead.\n\n  Generates alphanumeric strings.\"\n  string-alphanumeric)\n\n(defn- digit?\n  [d]\n  #?(:clj  (Character/isDigit ^Character d)\n     :cljs (gstring/isNumeric d)))\n\n(defn- +-or---digit?\n  \"Returns true if c is \\\\+ or \\\\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers.\"\n  [c d]\n  (core/boolean (and d\n                     (or (#?(:clj = :cljs identical?) \\+ c)\n                         (#?(:clj = :cljs identical?) \\- c))\n                     (digit? d))))\n\n(def ^:private symbol-name-or-namespace\n  \"Generates a namespace string for a symbol/keyword.\"\n  (->> (tuple char-symbol-initial (vector char-symbol-noninitial))\n       (such-that (fn [[c [d]]] (not (+-or---digit? c d))))\n       (fmap (fn [[c cs]]\n               (core/let [s (clojure.string/join (cons c cs))]\n                 (-> s\n                     (string/replace #\":{2,}\" \":\")\n                     (string/replace #\":$\" \"\")))))))\n\n(defn ^:private resize-symbolish-generator\n  \"Scales the sizing down on a keyword or symbol generator so as to\n  make it reasonable.\"\n  [g]\n  ;; function chosen by ad-hoc experimentation\n  (scale #(long (Math/pow % 0.60)) g))\n\n(def keyword\n  \"Generates keywords without namespaces.\"\n  (->> symbol-name-or-namespace\n       (fmap core/keyword)\n       (resize-symbolish-generator)))\n\n(def\n  ^{:added \"0.5.9\"}\n  keyword-ns\n  \"Generates keywords with namespaces.\"\n  (->> (tuple symbol-name-or-namespace symbol-name-or-namespace)\n       (fmap (fn [[ns name]] (core/keyword ns name)))\n       (resize-symbolish-generator)))\n\n(def symbol\n  \"Generates symbols without namespaces.\"\n  (frequency [[100\n               (->> symbol-name-or-namespace\n                    (fmap core/symbol)\n                    (resize-symbolish-generator))]\n              [1 (return '/)]]))\n\n(def\n  ^{:added \"0.5.9\"}\n  symbol-ns\n  \"Generates symbols with namespaces.\"\n  (->> (tuple symbol-name-or-namespace symbol-name-or-namespace)\n       (fmap (fn [[ns name]] (core/symbol ns name)))\n       (resize-symbolish-generator)))\n\n(def ratio\n  \"Generates a small ratio (or integer) using gen/small-integer. Shrinks\n  toward simpler ratios, which may be larger or smaller.\"\n  (fmap\n   (fn [[a b]] (/ a b))\n   (tuple small-integer (fmap inc nat))))\n\n#?(:clj\n   (def ^{:added \"0.10.0\"} big-ratio\n     \"Generates a ratio (or integer) using gen/size-bounded-bigint. Shrinks\n  toward simpler ratios, which may be larger or smaller.\"\n     (fmap\n      (fn [[a b]] (/ a b))\n      (tuple size-bounded-bignat\n             (such-that (complement zero?) size-bounded-bignat)))))\n\n(def ^{:added \"0.9.0\"} uuid\n  \"Generates a random type-4 UUID. Does not shrink.\"\n  (no-shrink\n   #?(:clj\n      ;; this could be done with combinators, but doing it low-level\n      ;; seems to be 10x faster\n      (make-gen\n       (fn [rng _size]\n         (core/let [[r1 r2] (random/split rng)\n                    x1 (-> (random/rand-long r1)\n                           (bit-and -45057)\n                           (bit-or 0x4000))\n                    x2 (-> (random/rand-long r2)\n                           (bit-or -9223372036854775808)\n                           (bit-and -4611686018427387905))]\n           (rose/make-rose\n            (java.util.UUID. x1 x2)\n            []))))\n\n      :cljs\n      ;; this could definitely be optimized so that it doesn't require\n      ;; generating 31 numbers\n      (fmap (fn [nibbles]\n              (letfn [(hex [idx] (.toString (nibbles idx) 16))]\n                (core/let [rhex (-> (nibbles 15) (bit-and 3) (+ 8) (.toString 16))]\n                  (core/uuid (str (hex 0)  (hex 1)  (hex 2)  (hex 3)\n                                  (hex 4)  (hex 5)  (hex 6)  (hex 7)  \"-\"\n                                  (hex 8)  (hex 9)  (hex 10) (hex 11) \"-\"\n                                  \"4\"      (hex 12) (hex 13) (hex 14) \"-\"\n                                  rhex     (hex 16) (hex 17) (hex 18) \"-\"\n                                  (hex 19) (hex 20) (hex 21) (hex 22)\n                                  (hex 23) (hex 24) (hex 25) (hex 26)\n                                  (hex 27) (hex 28) (hex 29) (hex 30))))))\n            (vector (choose 0 15) 31)))))\n\n(defn ^:private base-simple-type\n  [double-gen char-gen string-gen]\n(one-of [int #?(:clj size-bounded-bigint :cljs large-integer) double-gen char-gen\n         string-gen ratio boolean keyword keyword-ns symbol symbol-ns uuid]))\n\n(def simple-type\n  \"Generates a variety of scalar types.\"\n  (base-simple-type double char string))\n\n(def simple-type-printable\n  \"Generates a variety of scalar types, with printable strings.\"\n  (base-simple-type double char-ascii string-ascii))\n\n(def ^{:added \"0.10.0\"} simple-type-equatable\n  \"Like gen/simple-type, but only generates objects that can be\n  equal to other objects (e.g., not a NaN).\"\n  (base-simple-type (double* {:NaN? false}) char string))\n\n(def ^{:added \"0.10.0\"} simple-type-printable-equatable\n  \"Like gen/simple-type-printable, but only generates objects that\n  can be equal to other objects (e.g., not a NaN).\"\n  (base-simple-type (double* {:NaN? false}) char-ascii string-ascii))\n\n#?(:cljs\n;; https://clojure.atlassian.net/browse/CLJS-1594\n   (defn ^:private hashable?\n     [x]\n     (if (number? x)\n       (not (or (js/isNaN x)\n                (= NEG_INFINITY x)\n                (= POS_INFINITY x)))\n       true)))\n\n(defn container-type\n  [inner-type]\n  (one-of [(vector inner-type)\n           (list inner-type)\n           (set #?(:clj inner-type\n                   :cljs (such-that hashable? inner-type)))\n           ;; scaling this by half since it naturally generates twice\n           ;; as many elements\n           (scale #(quot % 2)\n                  (map #?(:clj inner-type\n                          :cljs (such-that hashable? inner-type))\n                       inner-type))]))\n\n;; A few helpers for recursive-gen\n\n(defn ^:private size->max-leaf-count\n  [size]\n  ;; chosen so that recursive-gen (with the assumptions mentioned in\n  ;; the comment below) will generate structures with leaf-node-counts\n  ;; not greater than the `size` ~99% of the time.\n  (long (Math/pow size 1.1)))\n\n(core/let [log2 (Math/log 2)]\n  (defn ^:private random-pseudofactoring\n    \"Returns (not generates) a random collection of integers `xs`\n  greater than 1 such that (<= (apply * xs) n).\"\n    [n rng]\n    (if (<= n 2)\n      [n]\n      (core/let [log (Math/log n)\n                 [r1 r2] (random/split rng)\n                 n1 (-> (random/rand-double r1)\n                        (* (- log log2))\n                        (+ log2)\n                        (Math/exp)\n                        (long))\n                 n2 (quot n n1)]\n        (if (and (< 1 n1) (< 1 n2))\n          (cons n1 (random-pseudofactoring n2 r2))\n          [n])))))\n\n(defn ^:private randomized\n  \"Like sized, but passes an rng instead of a size.\"\n  [func]\n  (make-gen (fn [rng size]\n              (core/let [[r1 r2] (random/split rng)]\n                (call-gen\n                 (func r1)\n                 r2\n                 size)))))\n\n(defn\n  ^{:added \"0.5.9\"}\n  recursive-gen\n  \"This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that 'contains' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/small-integer]))\n\n  Note that raw scalar values will be generated as well. To prevent this, you\n  can wrap the returned generator with the function passed as the first arg,\n  e.g.:\n\n    (gen/vector (gen/recursive-gen gen/vector gen/boolean))\"\n  [container-gen-fn scalar-gen]\n  (assert (generator? scalar-gen)\n          \"Second arg to recursive-gen must be a generator\")\n  ;; The trickiest part about this is sizing. The strategy here is to\n  ;; assume that the container generators will (like the normal\n  ;; collection generators in this namespace) have a size bounded by\n  ;; the `size` parameter, and with that assumption we can give an\n  ;; upper bound to the total number of leaf nodes in the generated\n  ;; structure.\n  ;;\n  ;; So we first pick an upper bound, and pick it to be somewhat\n  ;; larger than the real `size` since on average they will be rather\n  ;; smaller. Then we factor that upper bound into integers to give us\n  ;; the size to use at each depth, assuming that the total size\n  ;; should sort of be the product of the factored sizes.\n  ;;\n  ;; This is all a bit weird and hard to explain precisely but I think\n  ;; it works reasonably and definitely better than the old code.\n  (sized (fn [size]\n           (bind (choose 0 (size->max-leaf-count size))\n                 (fn [max-leaf-count]\n                   (randomized\n                    (fn [rng]\n                      (core/let [sizes (random-pseudofactoring max-leaf-count rng)\n                                 sized-scalar-gen (resize size scalar-gen)]\n                        (reduce (fn [g size]\n                                  (bind (choose 0 10)\n                                        (fn [x]\n                                          (if (zero? x)\n                                            sized-scalar-gen\n                                            (resize size\n                                                    (container-gen-fn g))))))\n                                sized-scalar-gen\n                                sizes)))))))))\n\n(def any\n  \"A recursive generator that will generate many different, often nested, values\"\n  (recursive-gen container-type simple-type))\n\n(def any-printable\n  \"Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command)\"\n  (recursive-gen container-type simple-type-printable))\n\n(def ^{:added \"0.10.0\"} any-equatable\n  \"Like any, but only generates objects that can be equal to other objects (e.g., do\n  not contain a NaN)\"\n  (recursive-gen container-type simple-type-equatable))\n\n(def ^{:added \"0.10.0\"} any-printable-equatable\n  \"Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command), and only generates\n  objects that can be equal to other objects (e.g., do not contain a NaN)\"\n  (recursive-gen container-type simple-type-printable-equatable))\n\n\n\n;; Macros\n;; ---------------------------------------------------------------------------\n\n(defmacro let\n  \"Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \\\"users\\\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (->> users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))\"\n  {:added \"0.9.0\"}\n  [bindings & body]\n  (assert (vector? bindings)\n          \"First arg to gen/let must be a vector of bindings.\")\n  (assert (even? (count bindings))\n          \"gen/let requires an even number of forms in binding vector\")\n  (if (empty? bindings)\n    `(core/let [val# (do ~@body)]\n       (if (clojure.test.check.generators/generator? val#)\n         val#\n         (return val#)))\n    (core/let [[binding gen & more] bindings]\n      `(clojure.test.check.generators/bind ~gen (fn [~binding] (let [~@more] ~@body))))))\n","~:reader-features",["^L",["~:cljs-release","~:cljs-dev","~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["this__5343__auto__","k__5344__auto__","this__5345__auto__","k45886","else__5346__auto__","G__45890","cljs.core/Keyword","gen","cljs.core.get","__extmap","this__5363__auto__","f__5364__auto__","init__5365__auto__","cljs.core.reduce","ret__5366__auto__","p__45891","vec__45892","k__5367__auto__","cljs.core.nth","v__5368__auto__","this__5358__auto__","writer__5359__auto__","opts__5360__auto__","pr-pair__5361__auto__","keyval__5362__auto__","cljs.core/pr-sequential-writer","cljs.core.concat","cljs.core/PersistentVector","G__45885","cljs.core/RecordIter","cljs.core/-iterator","cljs.core/nil-iter","this__5341__auto__","__meta","this__5338__auto__","__hash","this__5347__auto__","cljs.core/count","this__5339__auto__","h__5154__auto__","coll__5340__auto__","cljs.core/hash-unordered-coll","this45887","other45888","cljs.core._EQ_","this__5353__auto__","k__5354__auto__","cljs.core/contains?","cljs.core.dissoc","cljs.core/-with-meta","cljs.core.into","cljs.core/not-empty","this__5350__auto__","G__45898","this__5351__auto__","k__5352__auto__","pred__45904","cljs.core/keyword-identical?","expr__45905","cljs.core.assoc","this__5356__auto__","cljs.core/seq","cljs.core/MapEntry","this__5342__auto__","this__5348__auto__","entry__5349__auto__","cljs.core/vector?","cljs.core/-nth","cljs.core/-conj","clojure.test.check.generators/Generator","this__5389__auto__","cljs.core/List","writer__5390__auto__","cljs.core/-write","G__45889","extmap__5385__auto__","G__45907","cljs.core/record?","clojure.test.check.generators/->Generator","clojure.test.check.generators/map->Generator","clojure.test.check.generators/generator?","x","clojure.test.check.generators/make-gen","generator-fn","p__45911","map__45912","cljs.core/--destructure-map","clojure.test.check.generators/call-gen","rnd","size","clojure.test.check.generators/gen-pure","value","p__45913","map__45914","clojure.test.check.generators/gen-fmap","k","h","G__45915","p__45916","map__45917","clojure.test.check.generators/gen-bind","vec__45918","map__45921","r1","r2","clojure.test.check.random/split","inner","result","clojure.test.check.generators/lazy-random-states","rr","cljs.core/LazySeq","vec__45922","cljs.core/cons","clojure.test.check.generators/gen-tuple","gens","p1__45925#","p2__45926#","cljs.core.mapv","clojure.test.check.random/split-n","clojure.test.check.generators/fmap","f","js/Error","p1__45927#","clojure.test.check.rose-tree/fmap","clojure.test.check.generators/return","clojure.test.check.rose-tree/pure","clojure.test.check.generators/bind-helper","rose","clojure.test.check.rose-tree/join","p1__45928#","clojure.test.check.generators/bind","generator","clojure.test.check.generators/make-size-range-seq","max-size","cljs.core/cycle","cljs.core.range","var_args","G__45938","clojure.test.check.generators/sample-seq","clojure.test.check.generators.sample_seq","r","clojure.test.check.random.make_random","size-seq","p1__45933#","p2__45934#","cljs.core.map","clojure.test.check.rose-tree/root","G__45944","clojure.test.check.generators/sample","clojure.test.check.generators.sample","num-samples","cljs.core.take","G__45946","clojure.test.check.generators/generate","clojure.test.check.generators.generate","rng","seed","clojure.test.check.generators/halfs","n","p1__45950#","cljs.core.take_while","cljs.core.not_EQ_","p1__45951#","cljs.core/iterate","cljs.core/quot","clojure.test.check.generators/shrink-int","integer","p1__45955#","clojure.test.check.generators/int-rose-tree","clojure.test.check.rose-tree/make-rose","clojure.test.check.generators/calc-long","factor","lower","upper","cljs.core/long","Math/floor","clojure.test.check.generators/rand-range","clojure.test.check.random/rand-double","clojure.test.check.generators/sized","sized-gen","clojure.test.check.generators/resize","map__45959","_size","clojure.test.check.generators/scale","clojure.test.check.generators/choose","p1__45960#","clojure.test.check.rose-tree/filter","clojure.test.check.generators/one-of","generators","cljs.core/every?","p1__45961#","clojure.test.check.generators/pick","likelihoods","cljs.core.reductions","cljs.core/+","cljs.core/rest","p1__45962#","clojure.test.check.generators/frequency","pairs","p__45971","vec__45972","g","cljs.core.filter","cljs.core.comp","cljs.core/pos?","cljs.core/first","total","cljs.core.apply","idx","iter__5523__auto__","s__45986","temp__5804__auto__","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","b__45988","cljs.core/chunk-buffer","i__45987","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__45985","cljs.core/chunk-rest","cljs.core/second","clojure.test.check.rose-tree/children","clojure.test.check.generators/elements","coll","v","cljs.core/vec","p1__46001#","p__46004","map__46005","clojure.test.check.generators/such-that-helper","pred","ex-fn","max-tries","tries-left","G__46011","vec__46012","G__46015","clojure.test.check.generators/default-such-that-opts","p__46018","map__46020","arg","cljs.core.ex_info","G__46023","clojure.test.check.generators/such-that","clojure.test.check.generators.such_that","max-tries-or-opts","opts","cljs.core/integer?","cljs.core/map?","cljs.core.merge","rand-seed","clojure.test.check.generators/not-empty","clojure.test.check.generators/no-shrink","clojure.test.check.generators/shrink-2","clojure.test.check.rose-tree/collapse","clojure.test.check.generators/boolean","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","clojure.test.check.generators/tuple","seq46032","self__5755__auto__","roses","clojure.test.check.rose-tree/zip","cljs.core/vector","clojure.test.check.generators/nat","clojure.test.check.generators/small-integer","clojure.test.check.generators/int","clojure.test.check.generators/pos-int","clojure.test.check.generators/neg-int","p1__46041#","clojure.test.check.generators/s-pos-int","cljs.core/inc","clojure.test.check.generators/s-neg-int","cljs.core/dec","G__46046","clojure.test.check.generators/vector","p1__46042#","num-elements-rose","clojure.test.check.rose-tree/shrink-vector","cljs.core.repeat","num-elements","min-elements","max-elements","clojure.test.check.generators/list","p1__46053#","cljs.core/list","p__46058","vec__46059","clojure.test.check.generators/swap","i1","i2","clojure.test.check.generators/shuffle","index-gen","p1__46062#","clojure.test.check.generators.vector","clojure.test.check.generators.tuple","clojure.test.check.generators/hash-map","seq46067","kvs","cljs.core/even?","ks","cljs.core.take_nth","vs","p1__46066#","cljs.core/zipmap","clojure.test.check.generators/transient-set-contains?","s","cljs.core/-lookup","clojure.test.check.generators/coll-distinct-by*","empty-coll","key-fn","shuffle-fn","rose-trees","cljs.core/transient","tries","G__46085","cljs.core/persistent!","G__46088","G__46089","rest__46072#","vec__46090","rng1","rng2","root","cljs.core.conj_BANG_","clojure.test.check.generators/distinct-by?","or__5045__auto__","cljs.core/empty?","cljs.core/distinct?","clojure.test.check.generators/the-shuffle-fn","cljs.core/empty","card","dec-card","p__46099","vec__46101","vec__46104","swap-idx","p__46117","map__46118","p1__46108#","clojure.test.check.generators/coll-distinct-by","allows-dupes?","ordered?","_rng","hard-min-elements","p1__46109#","size-pred","gen-size","p1__46110#","cljs.core.every_pred","p1__46111#","p1__46112#","p1__46113#","p1__46115#","G__46126","clojure.test.check.generators/vector-distinct","clojure.test.check.generators.vector_distinct","cljs.core/identity","G__46131","clojure.test.check.generators/list-distinct","clojure.test.check.generators.list_distinct","G__46134","clojure.test.check.generators/vector-distinct-by","clojure.test.check.generators.vector_distinct_by","G__46138","clojure.test.check.generators/list-distinct-by","clojure.test.check.generators.list_distinct_by","G__46142","clojure.test.check.generators/set","clojure.test.check.generators.set","G__46146","clojure.test.check.generators/sorted-set","clojure.test.check.generators.sorted_set","cljs.core/sorted-set","G__46151","clojure.test.check.generators/map","key-gen","val-gen","clojure.test.check.generators.map","clojure.test.check.generators/gen-raw-long","clojure.test.check.random/rand-long","clojure.test.check.generators/MAX_INTEGER","cljs.core/*","clojure.test.check.generators/MIN_INTEGER","clojure.test.check.generators/abs","Math/abs","clojure.test.check.generators/long->large-integer","bit-count","min","max","res","G__46159","res'","G__46161","cljs.core/odd?","fexpr__46162","clojure.test.check.generators/large-integer**","x__5130__auto__","y__5131__auto__","max-bit-count","x__5133__auto__","y__5134__auto__","vec__46167","p__46175","map__46176","clojure.test.check.generators/large-integer*","p1__46170#","p1__46171#","p1__46174#","clojure.test.check.generators/large-integer","clojure.test.check.generators/POS_INFINITY","js/Number","clojure.test.check.generators/NEG_INFINITY","clojure.test.check.generators/MAX_POS_VALUE","clojure.test.check.generators/MIN_NEG_VALUE","clojure.test.check.generators/NAN","clojure.test.check.generators/uniform-integer","G__46182","p__46184","vec__46185","G__46188","clojure.test.check.generators/scalb","exp","js/Math","clojure.test.check.generators/fifty-two-bit-reverse","out","out-shifter","Math/pow","clojure.test.check.generators/backwards-shrinking-significand","clojure.test.check.generators/get-exponent","Math/log","t","clojure.test.check.generators/double-exp-and-sign","lower-bound","upper-bound","lb","ub","qs8","gen-exp","lbexp","ubexp","p__46210","vec__46211","sign","pair","clojure.test.check.generators/block-bounds","vec__46234","low","high","G__46237","G__46238","clojure.test.check.generators/double-finite","p1__46251#","p1__46252#","p1__46253#","p__46270","vec__46275","vec__46278","significand","base","vec__46285","block-lb","G__46290","block-ub","G__46295","G__46298","p__46305","map__46310","clojure.test.check.generators/double*","infinite?","NaN?","frequency-arg","G__46311","cljs.core.conj","and__5043__auto__","clojure.test.check.generators/double","clojure.test.check.generators/char","cljs.core/char","clojure.test.check.generators/char-ascii","clojure.test.check.generators/char-alphanumeric","clojure.test.check.generators/char-alpha-numeric","clojure.test.check.generators/char-alpha","clojure.test.check.generators/char-symbol-special","clojure.test.check.generators/char-symbol-noninitial","clojure.test.check.generators/char-symbol-initial","clojure.test.check.generators/string","clojure.string/join","clojure.test.check.generators/string-ascii","clojure.test.check.generators/string-alphanumeric","clojure.test.check.generators/string-alpha-numeric","clojure.test.check.generators/digit?","d","goog.string/isNumeric","clojure.test.check.generators/+-or---digit?","c","cljs.core/boolean","clojure.test.check.generators/symbol-name-or-namespace","p__46333","vec__46334","vec__46337","p__46329","vec__46330","cs","clojure.string.join","clojure.string/replace","clojure.test.check.generators/resize-symbolish-generator","p1__46340#","clojure.test.check.generators/keyword","cljs.core/keyword","clojure.test.check.generators/keyword-ns","p__46341","vec__46342","ns","name","cljs.core.keyword","clojure.test.check.generators/symbol","cljs.core/symbol","clojure.test.check.generators/symbol-ns","p__46345","vec__46346","cljs.core.symbol","clojure.test.check.generators/ratio","p__46349","vec__46350","a","b","clojure.test.check.generators/uuid","nibbles","rhex","cljs.core/uuid","hex","clojure.test.check.generators/base-simple-type","double-gen","char-gen","string-gen","clojure.test.check.generators/simple-type","clojure.test.check.generators/simple-type-printable","clojure.test.check.generators/simple-type-equatable","clojure.test.check.generators/simple-type-printable-equatable","clojure.test.check.generators/hashable?","cljs.core/not","js/isNaN","clojure.test.check.generators/container-type","inner-type","p1__46355#","clojure.test.check.generators/size->max-leaf-count","log2","clojure.test.check.generators/random-pseudofactoring","vec__46357","log","n1","Math/exp","n2","clojure.test.check.generators/randomized","func","vec__46360","clojure.test.check.generators/recursive-gen","container-gen-fn","scalar-gen","max-leaf-count","sizes","sized-scalar-gen","clojure.test.check.generators/any","clojure.test.check.generators/any-printable","clojure.test.check.generators/any-equatable","clojure.test.check.generators/any-printable-equatable","cljs.core/chunk-first"]],"~:used-vars",["^L",["~$cljs.core/char","~$cljs.core/--destructure-map","~$clojure.test.check.generators/sample","~$clojure.string/join","~$cljs.core/comp","~$cljs.core/rest","~$cljs.core/even?","~$cljs.core/keyword","~$clojure.test.check.random/make-random","~$clojure.test.check.generators/bind-helper","~$clojure.test.check.generators/get-exponent","~$clojure.test.check.generators/call-gen","~$cljs.core/odd?","~$clojure.test.check.generators/gen-tuple","~$clojure.test.check.generators/s-pos-int","~$clojure.test.check.generators/abs","~$clojure.test.check.generators/hash-map","~$clojure.test.check.generators/keyword","~$clojure.test.check.generators/NEG_INFINITY","~$clojure.test.check.generators/transient-set-contains?","~$clojure.test.check.generators/MAX_POS_VALUE","~$clojure.test.check.generators/ratio","~$clojure.test.check.generators/rand-range","~$clojure.test.check.generators/block-bounds","~$cljs.core/pr-sequential-writer","~$cljs.core/pos?","~$js/Math","~$clojure.test.check.generators/char-symbol-special","~$cljs.core/vector?","~$clojure.test.check.generators/char-alpha","~$clojure.test.check.generators/generator?","~$clojure.test.check.generators/random-pseudofactoring","~$clojure.test.check.generators/fmap","~$cljs.core/filter","~$cljs.core/=","~$clojure.test.check.generators/vector-distinct-by","~$clojure.test.check.generators/swap","~$clojure.test.check.random/split","~$cljs.core/dec","~$clojure.test.check.generators/size->max-leaf-count","~$clojure.test.check.generators/sample-seq","~$clojure.test.check.generators/MAX_INTEGER","~$cljs.core/-assoc","~$clojure.test.check.generators/gen-pure","~$clojure.test.check.rose-tree/make-rose","~$cljs.core/take-while","~$cljs.core/-write","~$clojure.test.check.generators/gen-bind","~$clojure.test.check.generators/char-ascii","~$cljs.core/IndexedSeq","~$clojure.test.check.rose-tree/root","~$cljs.core/-iterator","~$cljs.core/count","~$clojure.test.check.generators/symbol-name-or-namespace","~$clojure.test.check.generators/char-alphanumeric","~$clojure.test.check.generators/such-that-helper","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/chunk-first","~$clojure.test.check.generators/pick","~$cljs.core/apply","~$clojure.test.check.generators/halfs","~$cljs.core/identity","~$cljs.core/Keyword","~$clojure.test.check.generators/sorted-set","~$cljs.core/take","~$clojure.test.check.generators/gen-fmap","~$clojure.test.check.generators/Generator","~$clojure.test.check.generators/choose","~$clojure.test.check.generators/coll-distinct-by*","~$cljs.core/chunk","~$cljs.core/mapv","~$cljs.core/not=","~$clojure.test.check.generators/frequency","~$cljs.core/iterate","~$clojure.test.check.generators/generate","~$cljs.core/MapEntry","~$clojure.test.check.generators/small-integer","~$cljs.core/dissoc","~$cljs.core/quot","~$cljs.core/keyword-identical?","~$clojure.test.check.rose-tree/join","~$cljs.core/LazySeq","~$cljs.core/chunk-rest","~$clojure.test.check.generators/set","~$clojure.test.check.generators/one-of","~$Math/exp","~$clojure.test.check.generators/distinct-by?","~$clojure.test.check.generators/MIN_NEG_VALUE","~$cljs.core/-with-meta","~$clojure.test.check.generators/calc-long","~$clojure.test.check.generators/s-neg-int","~$clojure.test.check.generators/nat","~$cljs.core/concat","~$clojure.test.check.generators/vector-distinct","~$cljs.core/take-nth","~$clojure.test.check.generators/the-shuffle-fn","~$clojure.test.check.generators/lazy-random-states","~$clojure.test.check.generators/resize-symbolish-generator","~$cljs.core/cycle","~$clojure.test.check.generators/shrink-2","~$Math/floor","~$clojure.test.check.generators/map","~$cljs.core/empty?","~$clojure.test.check.generators/scalb","~$cljs.core/contains?","~$cljs.core/into","~$cljs.core/map?","~$cljs.core/sorted-set","~$cljs.core/conj","~$clojure.test.check.generators/digit?","~$clojure.test.check.rose-tree/children","~$clojure.test.check.generators/bind","~$clojure.test.check.generators/symbol-ns","~$cljs.core/zipmap","~$cljs.core/-conj","~$clojure.test.check.generators/gen-raw-long","~$cljs.core/map","~$clojure.test.check.generators/POS_INFINITY","~$clojure.test.check.random/rand-long","~$clojure.test.check.generators/randomized","~$cljs.core/PersistentVector","~$goog.string/isNumeric","~$cljs.core/List","~$cljs.core/empty","~$cljs.core/long","~$clojure.test.check.generators/long->large-integer","~$cljs.core/get","~$clojure.test.check.generators/double","~$clojure.test.check.generators/char-symbol-noninitial","~$clojure.test.check.random/rand-double","~$cljs.core/integer?","~$Math/abs","~$cljs.core/chunk-append","~$clojure.test.check.generators/any-printable-equatable","~$cljs.core/-nth","~$clojure.test.check.generators/list","~$clojure.test.check.generators/large-integer*","~$cljs.core/not-empty","~$clojure.test.check.generators/list-distinct-by","~$js/isNaN","~$clojure.test.check.generators/simple-type-printable-equatable","~$clojure.test.check.generators/int-rose-tree","~$cljs.core/symbol","~$cljs.core/distinct?","~$cljs.core/conj!","~$clojure.test.check.generators/shrink-int","~$cljs.core/*","~$cljs.core/record?","~$clojure.test.check.generators/such-that","~$cljs.core/persistent!","~$cljs.core/-lookup","~$clojure.test.check.generators/int","~$clojure.test.check.generators/->Generator","~$clojure.test.check.generators/recursive-gen","~$cljs.core/nth","~$cljs.core/ex-info","~$clojure.test.check.generators/scale","~$clojure.test.check.generators/no-shrink","~$cljs.core/second","~$clojure.test.check.generators/char-alpha-numeric","~$clojure.test.check.generators/+-or---digit?","~$clojure.test.check.generators/backwards-shrinking-significand","~$cljs.core/nil-iter","~$clojure.test.check.generators/return","~$clojure.test.check.generators/simple-type-printable","~$clojure.string/replace","~$clojure.test.check.generators/base-simple-type","~$clojure.test.check.generators/double-finite","~$clojure.test.check.generators/char-symbol-initial","~$cljs.core/vec","~$clojure.test.check.generators/symbol","~$cljs.core/reductions","~$clojure.test.check.generators/make-gen","~$cljs.core/RecordIter","~$cljs.core/transient","~$clojure.test.check.generators/uuid","~$cljs.core/chunk-cons","~$Math/pow","~$clojure.test.check.rose-tree/fmap","~$cljs.core/not","~$clojure.test.check.generators/make-size-range-seq","~$clojure.test.check.generators/string-ascii","~$clojure.test.check.generators/any-printable","~$cljs.core/cons","~$clojure.test.check.generators/double*","~$cljs.core/assoc","~$clojure.test.check.generators/uniform-integer","~$cljs.core/chunk-buffer","~$clojure.test.check.generators/double-exp-and-sign","~$clojure.test.check.generators/simple-type-equatable","~$cljs.core/range","~$clojure.test.check.generators/sized","~$clojure.test.check.generators/large-integer**","~$clojure.test.check.generators/coll-distinct-by","~$Math/log","~$clojure.test.check.generators/boolean","~$clojure.test.check.generators/MIN_INTEGER","~$clojure.test.check.generators/string-alphanumeric","~$clojure.test.check.generators/list-distinct","~$cljs.core/repeat","~$cljs.core/hash-unordered-coll","~$clojure.test.check.rose-tree/collapse","~$clojure.test.check.generators/tuple","~$clojure.test.check.generators/map->Generator","~$cljs.core/first","~$clojure.test.check.generators/simple-type","~$clojure.test.check.generators/string-alpha-numeric","~$js/Number","~$clojure.test.check.generators/string","~$clojure.test.check.rose-tree/filter","~$clojure.test.check.generators/vector","~$clojure.test.check.generators/resize","~$clojure.test.check.rose-tree/pure","~$clojure.test.check.generators/char","~$cljs.core/list","~$clojure.test.check.generators/neg-int","~$cljs.core/uuid","~$cljs.core/merge","~$cljs.core/+","~$cljs.core/every?","~$cljs.core/every-pred","~$clojure.test.check.random/split-n","~$js/Error","~$clojure.test.check.generators/any","~$clojure.test.check.generators/elements","~$clojure.test.check.generators/not-empty","~$clojure.test.check.generators/default-such-that-opts","~$clojure.test.check.generators/fifty-two-bit-reverse","~$cljs.core/vector","~$cljs.core/boolean","~$clojure.test.check.generators/NAN","~$clojure.test.check.generators/pos-int","~$clojure.test.check.rose-tree/shrink-vector","~$clojure.test.check.generators/any-equatable","~$clojure.test.check.generators/large-integer","~$clojure.test.check.generators/keyword-ns","~$cljs.core/inc","~$clojure.test.check.generators/shuffle","~$clojure.test.check.generators/hashable?","~$clojure.test.check.generators/container-type","~$cljs.core/chunked-seq?","~$clojure.test.check.rose-tree/zip"]]],"~:cache-keys",["~#cmap",[["^21","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^L",[]],"~:deps-syms",["^1H","~$goog.dom.HtmlElement"]]],["^21","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.asserts","~$goog.string.internal","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^21","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^84"]]],["^21","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83"]]],["^21","clojure/test/check/generators.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^C","^1K","^1I","^1G","^1E"]]],["^21","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","clojure/test/check/random/doubles.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^C","~$clojure.test.check.random.longs"]]],["^21","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^81","^84"]]],["^21","clojure/test/check/rose_tree.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^C"]]],["^21","clojure/test/check/random.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^C","~$clojure.test.check.random.doubles","^8;"]]],["^21","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83"]]],"~:SHADOW-TIMESTAMP",[1689947046000,1689947046000,1689947050000],["^21","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83","~$goog.reflect"]]],["^21","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83","~$goog.fs.blob","^87","~$goog.html.SafeScript","~$goog.html.trustedtypes","^89","^8:"]]],["^21","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^89","~$goog.html.SafeUrl","^8:","^83","^84"]]],["^21","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^8@","~$goog.html.SafeStyle","^8B","^88","~$goog.html.uncheckedconversions","^89","^84"]]],["^21","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","~$goog.dom.TagName","^83","~$goog.dom.element"]]],["^21","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^89","^8@","^8G","~$goog.html.SafeStyleSheet","^8B","^8I","^88","^8:","^83","~$goog.labs.userAgent.browser","~$goog.array","~$goog.object","^84","~$goog.dom.tags","^8A"]]],["^21","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^8N"]]],["^21","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^21","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^8M","^83","~$goog.collections.maps","^1E","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^21","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^82"]]],["^21","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",[]]],["^21","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^8M","^8N"]]],["^21","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^C","^1E","~$goog.string.StringBuffer"]]],["^21","clojure/test/check/random/longs/bit_count_impl.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^C"]]],["^21","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","~$goog.dom.safe","^8H","^89","^84"]]],["^21","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^84","^86"]]],["^21","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","~$goog.flags"]]],["^21","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^8Q","^8I"]]],["^21","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83","^8F","^8@","^8G","^8K","^8B","^88","^89","^84"]]],["^21","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H"]]],["^21","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","~$goog.math.Long","~$goog.math.Integer","^1E","^8N","^8M","~$goog.Uri","^8W"]]],["^21","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^89","^8:","^8A","^83"]]],["^21","clojure/test/check/random/longs.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^C","~$clojure.test.check.random.longs.bit-count-impl","^8Z","^C"]]],["^21","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^89","^8G","^8:","^8N","^83","^84"]]],["^21","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^8>"]]],["^21","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83","^1E"]]],["^21","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^7X",["^ ","^7Y",null,"^7Z",["^L",[]],"^7[",["^1H","^83","^8:"]]]]],"~:clj-info",["^ ","jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/random.clj",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/generators.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1689947050000,"jar:file:/root/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1689947054000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/rose_tree.cljc",1689946177000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",10,"^8",5,"^9",10,"^:",34],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",["^ ","^I","^J"],"^K",["^L",["^M","^N","^O","^P","^Q","^R","^S","^I","^T","^U","^V","^W","^X","^Y","^Z","^[","^10","^11","^12","^13","^14"]],"^15",["^ ","^I",["^ ","^16","0.9.0","^17","^J","^18","^19","^6","clojure/test/check/generators.cljc","^8",1,"^7",1721,"^1:",true,"^1;",["^1<",[["^1=","~$&","^1>"]]],"^1?","Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \"users\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (->> users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))"]],"^18","^J","^1@",["^ "],"^1B",null,"^1C",["^ ","^1D","^1E","^1F","^1G","^1G","^1G","^1E","^1E","^C","^C","^1H","^1H","^1I","^1I","^1J","^1K","^1K","^1K","^1L","^1I","^1M","^C"],"^1N",["^L",["^1O","^1P"]],"~:shadow/js-access-global",["^L",["Number","Math","isNaN","Error"]],"^1Q",null,"~:defs",["^ ","~$coll-distinct-by*",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",702,"^8",17,"^9",702,"^:",34,"~:private",true,"^1;",["^1<",["~$quote",["^1<",[["~$empty-coll","~$key-fn","~$shuffle-fn","~$gen","~$rng","~$size","~$num-elements","~$min-elements","~$max-tries","~$ex-fn"]]]]],"^1?","Returns a rose tree."],"^9Y",true,"^18","^3X","^6","clojure/test/check/generators.cljc","^:",34,"~:method-params",["^1<",[["^9[","^:0","^:1","^:2","^:3","^:4","^:5","^:6","^:7","^:8"]]],"~:protocol-impl",null,"~:arglists-meta",["^1<",[null,null]],"^8",1,"~:variadic?",false,"^7",702,"~:ret-tag","~$clojure.test.check.rose-tree/RoseTree","^9",702,"~:max-fixed-arity",10,"~:fn-var",true,"^1;",["^1<",["^9Z",["^1<",[["^9[","^:0","^:1","^:2","^:3","^:4","^:5","^:6","^:7","^:8"]]]]],"^1?","Returns a rose tree."],"~$gen-fmap",["^ ","~:no-doc",true,"^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",53,"^8",7,"^9",53,"^:",15,"^1;",["^1<",["^9Z",["^1<",[["~$k",["^ ","~$h","~:gen"]]]]]],"^1?","Internal function.","^:B",true],"^18","^3U","^6","clojure/test/check/generators.cljc","^:",15,"^:9",["^1<",[["~$k","~$p__45913"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",53,"^:=","^3V","^9",53,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$k",["^ ","~$h","^:C"]]]]]],"^1?","Internal function."],"^M",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1520,"^8",24,"^9",1520,"^:",28,"^16","0.9.0"],"^16","0.9.0","^18","^6?","^6","clojure/test/check/generators.cljc","^:",28,"^8",1,"^7",1520,"^9",1520,"~:tag","^3V","^1?","Generates a random type-4 UUID. Does not shrink."],"^N",["^ ","^9X",null,"^5",["^ ","^16","0.9.0","^6","clojure/test/check/generators.cljc","^:",10,"~:top-fn",["^ ","^:<",false,"~:fixed-arity",2,"^:?",2,"^:9",[["^:2"],["^:2","~$opts"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^8",7,"^7",915,"^9",915,"^1;",["^1<",["^9Z",["^1<",[["^:2"],["^:2","^:H"]]]]],"^1?","Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^16","0.9.0","^18","^4;","^6","clojure/test/check/generators.cljc","^:",10,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^:2"],["^:2","^:H"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^:9",[["^:2"],["^:2","^:H"]],"^::",null,"^:G",2,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"~:methods",[["^ ","^:G",1,"^:<",false,"^:E","~$any"],["^ ","^:G",2,"^:<",false,"^:E","^3V"]],"^7",915,"^9",915,"^:?",2,"^:@",true,"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^1?","Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$one-of",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",345,"^8",7,"^9",345,"^:",13,"^1;",["^1<",["^9Z",["^1<",[["~$generators"]]]]],"^1?","Creates a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n      (gen/sample (gen/one-of [gen/small-integer gen/boolean (gen/vector gen/small-integer)]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"^18","^4<","^6","clojure/test/check/generators.cljc","^:",13,"^:9",["^1<",[["^:L"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",345,"^:=","^3V","^9",345,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:L"]]]]],"^1?","Creates a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n      (gen/sample (gen/one-of [gen/small-integer gen/boolean (gen/vector gen/small-integer)]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"~$uniform-integer",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1098,"^8",17,"^9",1098,"^:",32,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$bit-count"]]]]],"^1?","Generates an integer uniformly in the range 0..(2^bit-count-1)."],"^9Y",true,"^18","^6J","^6","clojure/test/check/generators.cljc","^:",32,"^:9",["^1<",[["^:N"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1098,"^:=","^3V","^9",1098,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:N"]]]]],"^1?","Generates an integer uniformly in the range 0..(2^bit-count-1)."],"~$any-printable",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1700,"^8",6,"^9",1700,"^:",19],"^18","^6F","^6","clojure/test/check/generators.cljc","^:",19,"^8",1,"^7",1700,"^9",1700,"^:E","^3V","^1?","Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command)"],"~$large-integer**",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1027,"^8",17,"^9",1027,"^:",32,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$min","~$max"]]]]],"^1?","Like large-integer*, but assumes range includes zero."],"^9Y",true,"^18","^6P","^6","clojure/test/check/generators.cljc","^:",32,"^:9",["^1<",[["^:Q","^:R"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1027,"^:=","^3V","^9",1027,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:Q","^:R"]]]]],"^1?","Like large-integer*, but assumes range includes zero."],"~$MIN_NEG_VALUE",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1095,"^8",16,"^9",1095,"^:",29,"^9Y",true],"^9Y",true,"^18","^4?","^6","clojure/test/check/generators.cljc","^:",29,"^8",1,"^7",1095,"^9",1095,"^:E","~$number"],"~$calc-long",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",225,"^8",8,"^9",225,"^:",17,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$factor","~$lower","~$upper"]]]]]],"^9Y",true,"^18","^4A","^6","clojure/test/check/generators.cljc","^:",17,"^:9",["^1<",[["^:V","^:W","^:X"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",225,"^:=","^:T","^9",225,"^:?",3,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:V","^:W","^:X"]]]]]],"~$vector-distinct",["^ ","^9X",null,"^5",["^ ","^16","0.9.0","^6","clojure/test/check/generators.cljc","^:",22,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^:2"],["^:2","^:H"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^8",7,"^7",815,"^9",815,"^1;",["^1<",["^9Z",["^1<",[["^:2"],["^:2","^:H"]]]]],"^1?","Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^16","0.9.0","^18","^4E","^6","clojure/test/check/generators.cljc","^:",22,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^:2"],["^:2","^:H"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^:9",[["^:2"],["^:2","^:H"]],"^::",null,"^:G",2,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",1,"^:<",false,"^:E","^:J"],["^ ","^:G",2,"^:<",false,"^:E","^3V"]],"^7",815,"^9",815,"^:?",2,"^:@",true,"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^1?","Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$double-exp-and-sign",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1165,"^8",17,"^9",1165,"^:",36,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$lower-bound","~$upper-bound"]]]]],"^1?","Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds."],"^9Y",true,"^18","^6L","^6","clojure/test/check/generators.cljc","^:",36,"^:9",["^1<",[["^:[","^;0"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1165,"^9",1165,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:[","^;0"]]]]],"^1?","Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds."],"~$MIN_INTEGER",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",999,"^8",16,"^9",999,"^:",27,"^9Y",true],"^9Y",true,"^18","^6T","^6","clojure/test/check/generators.cljc","^:",27,"^8",1,"^7",999,"^9",999,"^:E","^:T"],"^P",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",518,"^8",6,"^9",518,"^:",13],"^18","^6S","^6","clojure/test/check/generators.cljc","^:",13,"^8",1,"^7",518,"^9",518,"^:E","^3V","^1?","Generates one of `true` or `false`. Shrinks to `false`."],"~$list-distinct",["^ ","^9X",null,"^5",["^ ","^16","0.9.0","^6","clojure/test/check/generators.cljc","^:",20,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^:2"],["^:2","^:H"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^8",7,"^7",840,"^9",840,"^1;",["^1<",["^9Z",["^1<",[["^:2"],["^:2","^:H"]]]]],"^1?","Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^16","0.9.0","^18","^6V","^6","clojure/test/check/generators.cljc","^:",20,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^:2"],["^:2","^:H"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^:9",[["^:2"],["^:2","^:H"]],"^::",null,"^:G",2,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",1,"^:<",false,"^:E","^:J"],["^ ","^:G",2,"^:<",false,"^:E","^3V"]],"^7",840,"^9",840,"^:?",2,"^:@",true,"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^1?","Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$string-alphanumeric",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1430,"^8",6,"^9",1430,"^:",25],"^18","^6U","^6","clojure/test/check/generators.cljc","^:",25,"^8",1,"^7",1430,"^9",1430,"^:E","^3V","^1?","Generates alphanumeric strings."],"^Q",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",963,"^8",7,"^9",963,"^:",10,"^1;",["^1<",["^9Z",["^1<",[["~$key-gen","~$val-gen"],["^;4","^;5","^:H"]]]]],"^1?","Creates a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated maps\n    :min-elements  the min size of generated maps\n    :max-elements  the max size of generated maps\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct keys; it will be passed a map with\n                   `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n                   should return an exception","^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^;4","^;5"],["^;4","^;5","^:H"]],"^1;",["^1<",[["^;4","^;5"],["^;4","^;5","^:H"]]],"^:;",["^1<",[null,null]]]],"^18","^4M","^6","clojure/test/check/generators.cljc","^:",10,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^;4","^;5"],["^;4","^;5","^:H"]],"^1;",["^1<",[["^;4","^;5"],["^;4","^;5","^:H"]]],"^:;",["^1<",[null,null]]],"^:9",[["^;4","^;5"],["^;4","^;5","^:H"]],"^::",null,"^:G",3,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",2,"^:<",false,"^:E","^:J"],["^ ","^:G",3,"^:<",false,"^:E","^3V"]],"^7",963,"^9",963,"^:?",3,"^:@",true,"^1;",["^1<",[["^;4","^;5"],["^;4","^;5","^:H"]]],"^1?","Creates a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated maps\n    :min-elements  the min size of generated maps\n    :max-elements  the max size of generated maps\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct keys; it will be passed a map with\n                   `:gen` (the key-gen), `:num-elements`, and `:max-tries` and\n                   should return an exception"],"~$simple-type",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1560,"^8",6,"^9",1560,"^:",17],"^18","^71","^6","clojure/test/check/generators.cljc","^:",17,"^8",1,"^7",1560,"^9",1560,"^:E","^3V","^1?","Generates a variety of scalar types."],"^R",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1379,"^8",6,"^9",1379,"^:",10],"^18","^79","^6","clojure/test/check/generators.cljc","^:",10,"^8",1,"^7",1379,"^9",1379,"^:E","^3V","^1?","Generates character from 0-255."],"~$any-equatable",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1705,"^8",25,"^9",1705,"^:",38,"^16","0.10.0"],"^16","0.10.0","^18","^7M","^6","clojure/test/check/generators.cljc","^:",38,"^8",1,"^7",1705,"^9",1705,"^:E","^3V","^1?","Like any, but only generates objects that can be equal to other objects (e.g., do\n  not contain a NaN)"],"~$pos-int",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",561,"^8",30,"^9",561,"^:",37,"~:deprecated","0.10.0"],"^18","^7K","^6","clojure/test/check/generators.cljc","^:",37,"^8",1,"^7",561,"^;9","0.10.0","^9",561,"^:E","^3V","^1?","Deprecated - use gen/nat instead (see also gen/large-integer).\n\n  (this generator, despite its name, can generate 0)\n\n  Generates nonnegative integers bounded by the generator's `size` parameter."],"~$bind",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",125,"^8",7,"^9",125,"^:",11,"^1;",["^1<",["^9Z",["^1<",[["~$generator","~$f"]]]]],"^1?","Creates a new generator that passes the result of `gen` into function\n  `f`. `f` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator of permutations which first generates a\n  `num-elements` and then generates a shuffling of `(range num-elements)`:\n\n      (gen/bind gen/nat\n                ;; this function takes a value generated by\n                ;; the generator above and returns a new generator\n                ;; which shuffles the collection returned by `range`\n                (fn [num-elements]\n                  (gen/shuffle (range num-elements))))\n\n  Also see gen/let for a macro with similar functionality."],"^18","^4W","^6","clojure/test/check/generators.cljc","^:",11,"^:9",["^1<",[["^;;","~$f"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",125,"^:=","^3V","^9",125,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;;","~$f"]]]]],"^1?","Creates a new generator that passes the result of `gen` into function\n  `f`. `f` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator of permutations which first generates a\n  `num-elements` and then generates a shuffling of `(range num-elements)`:\n\n      (gen/bind gen/nat\n                ;; this function takes a value generated by\n                ;; the generator above and returns a new generator\n                ;; which shuffles the collection returned by `range`\n                (fn [num-elements]\n                  (gen/shuffle (range num-elements))))\n\n  Also see gen/let for a macro with similar functionality."],"~$symbol-ns",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1498,"^8",3,"^9",1498,"^:",12,"^16","0.5.9"],"^16","0.5.9","^18","^4X","^6","clojure/test/check/generators.cljc","^:",12,"^8",1,"^7",1496,"^9",1498,"^:E","^3V","^1?","Generates symbols with namespaces."],"^:J",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1696,"^8",6,"^9",1696,"^:",9],"^18","^7C","^6","clojure/test/check/generators.cljc","^:",9,"^8",1,"^7",1696,"^9",1696,"^:E","^3V","^1?","A recursive generator that will generate many different, often nested, values"],"~$hashable?",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1580,"^8",20,"^9",1580,"^:",29,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]]],"^9Y",true,"^18","^7R","^6","clojure/test/check/generators.cljc","^:",29,"^:9",["^1<",[["~$x"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",4,"^:<",false,"^7",1580,"^:=","^P","^9",1580,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]]],"^S",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",638,"^8",3,"^9",638,"^:",10,"^16","0.6.0","^1;",["^1<",["^9Z",["^1<",[["~$coll"]]]]],"^1?","Creates a generator that generates random permutations of\n  `coll`. Shrinks toward the original collection: `coll`. `coll` will\n  be coerced to a vector."],"^16","0.6.0","^18","^7Q","^6","clojure/test/check/generators.cljc","^:",10,"^:9",["^1<",[["^;>"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",636,"^:=","^3V","^9",638,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;>"]]]]],"^1?","Creates a generator that generates random permutations of\n  `coll`. Shrinks toward the original collection: `coll`. `coll` will\n  be coerced to a vector."],"~$container-type",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1588,"^8",7,"^9",1588,"^:",21,"^1;",["^1<",["^9Z",["^1<",[["~$inner-type"]]]]]],"^18","^7S","^6","clojure/test/check/generators.cljc","^:",21,"^:9",["^1<",[["^;@"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1588,"^:=","^3V","^9",1588,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;@"]]]]]],"~$long->large-integer",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1006,"^8",17,"^9",1006,"^:",36,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^:N","~$x","^:Q","^:R"]]]]]],"^9Y",true,"^18","^59","^6","clojure/test/check/generators.cljc","^:",36,"^:9",["^1<",[["^:N","~$x","^:Q","^:R"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1006,"^:=",["^L",["^:J","^:T"]],"^9",1006,"^:?",4,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:N","~$x","^:Q","^:R"]]]]]],"~$s-pos-int",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",577,"^8",30,"^9",577,"^:",39,"^;9","0.10.0"],"^18","^2M","^6","clojure/test/check/generators.cljc","^:",39,"^8",1,"^7",577,"^;9","0.10.0","^9",577,"^:E","^3V","^1?","Deprecated - use (gen/fmap inc gen/nat) instead (see also gen/large-integer).\n\n  Generates positive integers bounded by the generator's `size` + 1"],"~$get-exponent",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1147,"^8",17,"^9",1147,"^:",29,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]]],"^9Y",true,"^18","^2I","^6","clojure/test/check/generators.cljc","^:",29,"^:9",["^1<",[["~$x"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1147,"^:=",["^L",["^:J","^:T"]],"^9",1147,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]]],"~$char-symbol-noninitial",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1411,"^8",16,"^9",1411,"^:",38,"^9Y",true],"^9Y",true,"^18","^5<","^6","clojure/test/check/generators.cljc","^:",38,"^8",1,"^7",1411,"^9",1411,"^:E","^3V","^1?","Generates characters that can be the char following first of a keyword or symbol."],"~$any-printable-equatable",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1710,"^8",25,"^9",1710,"^:",48,"^16","0.10.0"],"^16","0.10.0","^18","^5A","^6","clojure/test/check/generators.cljc","^:",48,"^8",1,"^7",1710,"^9",1710,"^:E","^3V","^1?","Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command), and only generates\n  objects that can be equal to other objects (e.g., do not contain a NaN)"],"^T",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1295,"^8",24,"^9",1295,"^:",30,"^16","0.9.0"],"^16","0.9.0","^18","^5;","^6","clojure/test/check/generators.cljc","^:",30,"^8",1,"^7",1295,"^9",1295,"^:E",["^L",["^:J","^3V","~$clj-nil"]],"^1?","Generates 64-bit floating point numbers from the entire range,\n  including +/- infinity and NaN. Use double* for more control."],"~$MAX_POS_VALUE",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1094,"^8",16,"^9",1094,"^:",29,"^9Y",true],"^9Y",true,"^18","^2S","^6","clojure/test/check/generators.cljc","^:",29,"^8",1,"^7",1094,"^9",1094,"^:E","~$js"],"~$list-distinct-by",["^ ","^9X",null,"^5",["^ ","^16","0.9.0","^6","clojure/test/check/generators.cljc","^:",23,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^:0","^:2"],["^:0","^:2","^:H"]],"^1;",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^8",7,"^7",890,"^9",890,"^1;",["^1<",["^9Z",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]]]],"^1?","Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^16","0.9.0","^18","^5F","^6","clojure/test/check/generators.cljc","^:",23,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^:0","^:2"],["^:0","^:2","^:H"]],"^1;",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^:9",[["^:0","^:2"],["^:0","^:2","^:H"]],"^::",null,"^:G",3,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",2,"^:<",false,"^:E","^:J"],["^ ","^:G",3,"^:<",false,"^:E","^3V"]],"^7",890,"^9",890,"^:?",3,"^:@",true,"^1;",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]],"^1?","Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated list\n    :min-elements  the min size of generated list\n    :max-elements  the max size of generated list\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$simple-type-printable-equatable",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1573,"^8",25,"^9",1573,"^:",56,"^16","0.10.0"],"^16","0.10.0","^18","^5H","^6","clojure/test/check/generators.cljc","^:",56,"^8",1,"^7",1573,"^9",1573,"^:E","^3V","^1?","Like gen/simple-type-printable, but only generates objects that\n  can be equal to other objects (e.g., not a NaN)."],"~$block-bounds",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1207,"^8",17,"^9",1207,"^:",29,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$exp","~$sign"]]]]],"^1?","Returns [low high], the smallest and largest numbers in the given\n  range."],"^9Y",true,"^18","^2V","^6","clojure/test/check/generators.cljc","^:",29,"^:9",["^1<",[["^;L","^;M"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1207,"^:=","~$cljs.core/IVector","^9",1207,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;L","^;M"]]]]],"^1?","Returns [low high], the smallest and largest numbers in the given\n  range."],"~$char-alpha",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1401,"^8",6,"^9",1401,"^:",16],"^18","^30","^6","clojure/test/check/generators.cljc","^:",16,"^8",1,"^7",1401,"^9",1401,"^:E","^3V","^1?","Generates alpha characters."],"~$generator?",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",30,"^8",7,"^9",30,"^:",17,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]],"^1?","Test if `x` is a generator. Generators should be treated as opaque values."],"^18","^31","^6","clojure/test/check/generators.cljc","^:",17,"^:9",["^1<",[["~$x"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",30,"^:=","^P","^9",30,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]],"^1?","Test if `x` is a generator. Generators should be treated as opaque values."],"~$char-symbol-special",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1407,"^8",16,"^9",1407,"^:",35,"^9Y",true],"^9Y",true,"^18","^2Z","^6","clojure/test/check/generators.cljc","^:",35,"^8",1,"^7",1407,"^9",1407,"^:E","^3V","^1?","Generates non-alphanumeric characters that can be in a symbol."],"~$sample-seq",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",153,"^8",7,"^9",153,"^:",17,"^1;",["^1<",["^9Z",["^1<",[["^;;"],["^;;","~$max-size"]]]]],"^1?","Returns an infinite sequence of realized values from `generator`.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.","^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^;;"],["^;;","^;S"]],"^1;",["^1<",[["^;;"],["^;;","^;S"]]],"^:;",["^1<",[null,null]]]],"^18","^3;","^6","clojure/test/check/generators.cljc","^:",17,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^;;"],["^;;","^;S"]],"^1;",["^1<",[["^;;"],["^;;","^;S"]]],"^:;",["^1<",[null,null]]],"^:9",[["^;;"],["^;;","^;S"]],"^::",null,"^:G",2,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",1,"^:<",false,"^:E","^:J"],["^ ","^:G",2,"^:<",false,"^:E","^49"]],"^7",153,"^9",153,"^:?",2,"^:@",true,"^1;",["^1<",[["^;;"],["^;;","^;S"]]],"^1?","Returns an infinite sequence of realized values from `generator`.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators."],"^U",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",554,"^8",30,"^9",554,"^:",33,"^;9","0.10.0"],"^18","^5S","^6","clojure/test/check/generators.cljc","^:",33,"^8",1,"^7",554,"^;9","0.10.0","^9",554,"^:E","^3V","^1?","Deprecated - use gen/small-integer instead.\n\n  Generates a positive or negative integer bounded by the generator's\n  `size` parameter."],"~$gen-pure",["^ ","^:B",true,"^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",45,"^8",7,"^9",45,"^:",15,"^1;",["^1<",["^9Z",["^1<",[["~$value"]]]]],"^1?","Internal function.","^:B",true],"^18","^3>","^6","clojure/test/check/generators.cljc","^:",15,"^:9",["^1<",[["^;U"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",45,"^:=","^3V","^9",45,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;U"]]]]],"^1?","Internal function."],"~$recursive-gen",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1641,"^8",3,"^9",1641,"^:",16,"^16","0.5.9","^1;",["^1<",["^9Z",["^1<",[["~$container-gen-fn","~$scalar-gen"]]]]],"^1?","This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that 'contains' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/small-integer]))\n\n  Note that raw scalar values will be generated as well. To prevent this, you\n  can wrap the returned generator with the function passed as the first arg,\n  e.g.:\n\n    (gen/vector (gen/recursive-gen gen/vector gen/boolean))"],"^16","0.5.9","^18","^5U","^6","clojure/test/check/generators.cljc","^:",16,"^:9",["^1<",[["^;W","^;X"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1639,"^:=","^3V","^9",1641,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;W","^;X"]]]]],"^1?","This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that 'contains' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/small-integer]))\n\n  Note that raw scalar values will be generated as well. To prevent this, you\n  can wrap the returned generator with the function passed as the first arg,\n  e.g.:\n\n    (gen/vector (gen/recursive-gen gen/vector gen/boolean))"],"~$char-alpha-numeric",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1395,"^8",3,"^9",1395,"^:",21,"^;9","0.6.0"],"^18","^5[","^6","clojure/test/check/generators.cljc","^:",21,"^8",1,"^7",1394,"^;9","0.6.0","^9",1395,"^:E","^3V","^1?","Deprecated - use char-alphanumeric instead.\n\n  Generates alphanumeric characters."],"~$backwards-shrinking-significand",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1138,"^8",16,"^9",1138,"^:",47,"^9Y",true],"^9Y",true,"^18","^61","^6","clojure/test/check/generators.cljc","^:",47,"^8",1,"^7",1138,"^9",1138,"^:E","^3V","^1?","Generates a 52-bit non-negative integer that shrinks toward having\n  fewer lower-order bits (and shrinks to 0 if possible)."],"~$return",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",106,"^8",7,"^9",106,"^:",13,"^1;",["^1<",["^9Z",["^1<",[["^;U"]]]]],"^1?","Creates a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators. E.g.:\n\n      (gen/sample (gen/return 42))\n      => (42 42 42 42 42 42 42 42 42 42)"],"^18","^63","^6","clojure/test/check/generators.cljc","^:",13,"^:9",["^1<",[["^;U"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",106,"^:=","^3V","^9",106,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;U"]]]]],"^1?","Creates a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators. E.g.:\n\n      (gen/sample (gen/return 42))\n      => (42 42 42 42 42 42 42 42 42 42)"],"~$gen-bind",["^ ","^:B",true,"^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",61,"^8",7,"^9",61,"^:",15,"^1;",["^1<",["^9Z",["^1<",[[["^ ","~$h","^:C"],"~$k"]]]]],"^1?","Internal function.","^:B",true],"^18","^3B","^6","clojure/test/check/generators.cljc","^:",15,"^:9",["^1<",[["~$p__45916","~$k"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",61,"^:=","^3V","^9",61,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[[["^ ","~$h","^:C"],"~$k"]]]]],"^1?","Internal function."],"~$scale",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",302,"^8",7,"^9",302,"^:",12,"^1;",["^1<",["^9Z",["^1<",[["~$f","^;;"]]]]],"^1?","Creates a new generator that modifies the size parameter by the\n  given function. Intended to support generators with sizes that need\n  to grow at different rates compared to the normal linear scaling.\n\n      (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n                             gen/nat\n                             (gen/scale #(* % 10) gen/nat)))\n      => ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n          [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])","^16","0.8.0"],"^16","0.8.0","^18","^5X","^6","clojure/test/check/generators.cljc","^:",12,"^:9",["^1<",[["~$f","^;;"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",302,"^:=","^3V","^9",302,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$f","^;;"]]]]],"^1?","Creates a new generator that modifies the size parameter by the\n  given function. Intended to support generators with sizes that need\n  to grow at different rates compared to the normal linear scaling.\n\n      (gen/sample (gen/tuple (gen/scale #(/ % 10) gen/nat)\n                             gen/nat\n                             (gen/scale #(* % 10) gen/nat)))\n      => ([0 0 0]  [0 1 2]  [0 2 13] [0 1 6]  [0 1 23]\n          [0 2 42] [0 1 26] [0 1 12] [0 1 12] [0 0 3])"],"~$+-or---digit?",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1446,"^8",8,"^9",1446,"^:",21,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$c","~$d"]]]]],"^1?","Returns true if c is \\+ or \\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers."],"^9Y",true,"^18","^60","^6","clojure/test/check/generators.cljc","^:",21,"^:9",["^1<",[["~$c","~$d"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1446,"^:=","^P","^9",1446,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$c","~$d"]]]]],"^1?","Returns true if c is \\+ or \\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers."],"^V",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1488,"^8",6,"^9",1488,"^:",12],"^18","^6:","^6","clojure/test/check/generators.cljc","^:",12,"^8",1,"^7",1488,"^9",1488,"^:E","^3V","^1?","Generates symbols without namespaces."],"~$such-that-helper",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",419,"^8",8,"^9",419,"^:",24,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$pred","^:2",["^ ","~:keys",["^:8","^:7"]],"^:3","^:4"]]]]]],"^9Y",true,"^18","^3J","^6","clojure/test/check/generators.cljc","^:",24,"^:9",["^1<",[["^<5","^:2","~$p__46004","^:3","^:4"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",419,"^:=","^:>","^9",419,"^:?",5,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^<5","^:2",["^ ","^<6",["^:8","^:7"]],"^:3","^:4"]]]]]],"~$double-finite",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1219,"^8",17,"^9",1219,"^:",30,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^:[","^;0"]]]]]],"^9Y",true,"^18","^67","^6","clojure/test/check/generators.cljc","^:",30,"^:9",["^1<",[["^:[","^;0"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1219,"^:=",["^L",["^:J","^3V"]],"^9",1219,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:[","^;0"]]]]]],"~$pick",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",360,"^8",8,"^9",360,"^:",12,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$likelihoods","~$n"]]]]],"^1?","Returns an index into the `likelihoods` sequence."],"^9Y",true,"^18","^3N","^6","clojure/test/check/generators.cljc","^:",12,"^:9",["^1<",[["^<:","~$n"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",360,"^:=","^:T","^9",360,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^<:","~$n"]]]]],"^1?","Returns an index into the `likelihoods` sequence."],"~$char-symbol-initial",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1417,"^8",16,"^9",1417,"^:",35,"^9Y",true],"^9Y",true,"^18","^68","^6","clojure/test/check/generators.cljc","^:",35,"^8",1,"^7",1417,"^9",1417,"^:E","^3V","^1?","Generates characters that can be the first char of a keyword or symbol."],"~$char-alphanumeric",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1387,"^8",6,"^9",1387,"^:",23],"^18","^3I","^6","clojure/test/check/generators.cljc","^:",23,"^8",1,"^7",1387,"^9",1387,"^:E","^3V","^1?","Generates alphanumeric characters."],"~$make-size-range-seq",["^ ","^:B",true,"^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",147,"^8",7,"^9",147,"^:",26,"^1;",["^1<",["^9Z",["^1<",[["^;S"]]]]],"^1?","Internal function.","^:B",true],"^18","^6D","^6","clojure/test/check/generators.cljc","^:",26,"^:9",["^1<",[["^;S"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",147,"^:=",["^L",["^:J","~$cljs.core/Cycle"]],"^9",147,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;S"]]]]],"^1?","Internal function."],"~$choose",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",316,"^8",7,"^9",316,"^:",13,"^1;",["^1<",["^9Z",["^1<",[["^:W","^:X"]]]]],"^1?","Creates a generator that generates integer numbers uniformly in\n     the range `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)"],"^18","^3W","^6","clojure/test/check/generators.cljc","^:",13,"^:9",["^1<",[["^:W","^:X"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",316,"^:=","^3V","^9",316,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:W","^:X"]]]]],"^1?","Creates a generator that generates integer numbers uniformly in\n     the range `lower` to `upper`, inclusive.\n\n         (gen/sample (gen/choose 200 800))\n         => (331 241 593 339 643 718 688 473 247 694)"],"~$string-ascii",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1426,"^8",6,"^9",1426,"^:",18],"^18","^6E","^6","clojure/test/check/generators.cljc","^:",18,"^8",1,"^7",1426,"^9",1426,"^:E","^3V","^1?","Generates ascii strings."],"^W",["^ ","^9X",null,"^5",["^ ","^16","0.9.0","^6","clojure/test/check/generators.cljc","^:",17,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^:2"],["^:2","^:H"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^8",7,"^7",939,"^9",939,"^1;",["^1<",["^9Z",["^1<",[["^:2"],["^:2","^:H"]]]]],"^1?","Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^16","0.9.0","^18","^3S","^6","clojure/test/check/generators.cljc","^:",17,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^:2"],["^:2","^:H"]],"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^:9",[["^:2"],["^:2","^:H"]],"^::",null,"^:G",2,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",1,"^:<",false,"^:E","^:J"],["^ ","^:G",2,"^:<",false,"^:E","^3V"]],"^7",939,"^9",939,"^:?",2,"^:@",true,"^1;",["^1<",[["^:2"],["^:2","^:H"]]],"^1?","Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated set\n    :min-elements  the min size of generated set\n    :max-elements  the max size of generated set\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$make-gen",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",35,"^8",8,"^9",35,"^:",16,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$generator-fn"]]]]]],"^9Y",true,"^18","^6<","^6","clojure/test/check/generators.cljc","^:",16,"^:9",["^1<",[["^<B"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",35,"^:=","^3V","^9",35,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^<B"]]]]]],"~$Generator",["^ ","~:num-fields",1,"~:protocols",["^L",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^18","^3V","^6","clojure/test/check/generators.cljc","^:",21,"~:type",true,"^8",12,"~:internal-ctor",true,"^7",28,"~:record",true,"^9",28,"^:E","~$function","~:skip-protocol-flag",["^L",["^<F","^<G","^<H","^<I","^<J","^<K","^<L","^<M","^<N","^<O","^<P","^<Q","^<R","^<S","^<T"]]],"~$frequency",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",369,"^8",7,"^9",369,"^:",16,"^1;",["^1<",["^9Z",["^1<",[["~$pairs"]]]]],"^1?","Creates a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods. Shrinks toward\n  choosing an earlier generator, as well as shrinking the value generated\n  by the chosen generator.\n\n  Examples:\n\n      (gen/sample (gen/frequency [[5 gen/small-integer] [3 (gen/vector gen/small-integer)] [2 gen/boolean]]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"^18","^40","^6","clojure/test/check/generators.cljc","^:",16,"^:9",["^1<",[["^<["]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",369,"^:=","^3V","^9",369,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^<["]]]]],"^1?","Creates a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods. Shrinks toward\n  choosing an earlier generator, as well as shrinking the value generated\n  by the chosen generator.\n\n  Examples:\n\n      (gen/sample (gen/frequency [[5 gen/small-integer] [3 (gen/vector gen/small-integer)] [2 gen/boolean]]))\n      => (true [] -1 [0] [1 -4 -4 1] true 4 [] 6 true)"],"~$small-integer",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",547,"^8",25,"^9",547,"^:",38,"^16","0.10.0"],"^16","0.10.0","^18","^44","^6","clojure/test/check/generators.cljc","^:",38,"^8",1,"^7",547,"^9",547,"^:E","^3V","^1?","Generates a positive or negative integer bounded by the generator's\n  `size` parameter. Shrinks to zero."],"~$double*",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1253,"^8",7,"^9",1253,"^:",14,"^1;",["^1<",["^9Z",["^1<",[[["^ ","^<6",["~$infinite?","~$NaN?","^:Q","^:R"],"~:or",["^ ","^=2",true,"^=3",true]]]]]]],"^1?","Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity.","^16","0.9.0"],"^16","0.9.0","^18","^6H","^6","clojure/test/check/generators.cljc","^:",14,"^:9",["^1<",[["~$p__46305"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1253,"^:=",["^L",["^:J","^3V","^;F"]],"^9",1253,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[[["^ ","^<6",["^=2","^=3","^:Q","^:R"],"^=4",["^ ","^=2",true,"^=3",true]]]]]]],"^1?","Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity."],"~$generate",["^ ","^9X",null,"^5",["^ ","^16","0.8.0","^6","clojure/test/check/generators.cljc","^:",15,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^;;"],["^;;","^:4"],["^;;","^:4","~$seed"]],"^1;",["^1<",[["^;;"],["^;;","^:4"],["^;;","^:4","^=7"]]],"^:;",["^1<",[null,null,null]]],"^8",7,"^7",182,"^9",182,"^1;",["^1<",["^9Z",["^1<",[["^;;"],["^;;","^:4"],["^;;","^:4","^=7"]]]]],"^1?","Returns a single sample value from the generator.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\n\n  Optional args:\n\n  - size: the abstract size parameter, defaults to 30\n  - seed: the seed for the random number generator, an integer"],"^16","0.8.0","^18","^42","^6","clojure/test/check/generators.cljc","^:",15,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^;;"],["^;;","^:4"],["^;;","^:4","^=7"]],"^1;",["^1<",[["^;;"],["^;;","^:4"],["^;;","^:4","^=7"]]],"^:;",["^1<",[null,null,null]]],"^:9",[["^;;"],["^;;","^:4"],["^;;","^:4","^=7"]],"^::",null,"^:G",3,"^:;",["^1<",[null,null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",1,"^:<",false,"^:E","^:J"],["^ ","^:G",2,"^:<",false,"^:E","^:J"],["^ ","^:G",3,"^:<",false,"^:E","^:J"]],"^7",182,"^9",182,"^:?",3,"^:@",true,"^1;",["^1<",[["^;;"],["^;;","^:4"],["^;;","^:4","^=7"]]],"^1?","Returns a single sample value from the generator.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.\n\n  Optional args:\n\n  - size: the abstract size parameter, defaults to 30\n  - seed: the seed for the random number generator, an integer"],"~$distinct-by?",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",744,"^8",17,"^9",744,"^:",29,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$f","^;>"]]]]],"^1?","Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections."],"^9Y",true,"^18","^4>","^6","clojure/test/check/generators.cljc","^:",29,"^:9",["^1<",[["~$f","^;>"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",744,"^:=",["^L",["^P","^:J"]],"^9",744,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$f","^;>"]]]]],"^1?","Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections."],"~$sized",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",251,"^8",7,"^9",251,"^:",12,"^1;",["^1<",["^9Z",["^1<",[["~$sized-gen"]]]]],"^1?","Creates a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\n\n  Examples:\n\n      ;; generates vectors of booleans where the length always exactly\n      ;; matches the `size` parameter\n      (gen/sample (gen/sized (fn [size] (gen/vector gen/boolean size))))\n      => ([]\n          [false]\n          [true true]\n          [false true false]\n          [false true true true]\n          [false false true true false]\n          [false true false true true false]\n          [true false true true true false false]\n          [true true false false false true false false]\n          [false false false true true false true false true])"],"^18","^6O","^6","clojure/test/check/generators.cljc","^:",12,"^:9",["^1<",[["^=:"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",251,"^:=","^3V","^9",251,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^=:"]]]]],"^1?","Creates a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\n\n  Examples:\n\n      ;; generates vectors of booleans where the length always exactly\n      ;; matches the `size` parameter\n      (gen/sample (gen/sized (fn [size] (gen/vector gen/boolean size))))\n      => ([]\n          [false]\n          [true true]\n          [false true false]\n          [false true true true]\n          [false false true true false]\n          [false true false true true false]\n          [true false true true true false false]\n          [true true false false false true false false]\n          [false false false true true false true false true])"],"~$s-neg-int",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",583,"^8",30,"^9",583,"^:",39,"^;9","0.10.0"],"^18","^4B","^6","clojure/test/check/generators.cljc","^:",39,"^8",1,"^7",583,"^;9","0.10.0","^9",583,"^:E","^3V","^1?","Deprecated - use (gen/fmap (comp dec -) gen/nat) instead (see also gen/large-integer).\n\n  Generates negative integers bounded by the generator's `size` + 1"],"~$nat",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",540,"^8",6,"^9",540,"^:",9],"^18","^4C","^6","clojure/test/check/generators.cljc","^:",9,"^8",1,"^7",540,"^9",540,"^:E","^3V","^1?","Generates non-negative integers bounded by the generator's `size`\n  parameter. Shrinks to zero."],"~$simple-type-equatable",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1568,"^8",25,"^9",1568,"^:",46,"^16","0.10.0"],"^16","0.10.0","^18","^6M","^6","clojure/test/check/generators.cljc","^:",46,"^8",1,"^7",1568,"^9",1568,"^:E","^3V","^1?","Like gen/simple-type, but only generates objects that can be\n  equal to other objects (e.g., not a NaN)."],"~$coll-distinct-by",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",769,"^8",17,"^9",769,"^:",33,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^9[","^:0","~$allows-dupes?","~$ordered?","^:2",["^ ","^<6",["^:5","^:6","~$max-elements","^:7","^:8"],"^=4",["^ ","^:7",10,"^:8",["^1<",["~$fn*",["~$p1__46108#"],["^1<",["~$ex-info","Couldn't generate enough distinct elements!","^=C"]]]]]]]]]]]],"^9Y",true,"^18","^6Q","^6","clojure/test/check/generators.cljc","^:",33,"^:9",["^1<",[["^9[","^:0","^=?","^=@","^:2","~$p__46117"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",769,"^:=","^3V","^9",769,"^:?",6,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^9[","^:0","^=?","^=@","^:2",["^ ","^<6",["^:5","^:6","^=A","^:7","^:8"],"^=4",["^ ","^:7",10,"^:8",["^1<",["^=B",["^=C"],["^1<",["^=D","Couldn't generate enough distinct elements!","^=C"]]]]]]]]]]]],"~$resize-symbolish-generator",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1467,"^8",17,"^9",1467,"^:",43,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$g"]]]]],"^1?","Scales the sizing down on a keyword or symbol generator so as to\n  make it reasonable."],"^9Y",true,"^18","^4I","^6","clojure/test/check/generators.cljc","^:",43,"^:9",["^1<",[["~$g"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1467,"^:=","^3V","^9",1467,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$g"]]]]],"^1?","Scales the sizing down on a keyword or symbol generator so as to\n  make it reasonable."],"~$the-shuffle-fn",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",751,"^8",17,"^9",751,"^:",31,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^:3","^;>"]]]]],"^1?","Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function."],"^9Y",true,"^18","^4G","^6","clojure/test/check/generators.cljc","^:",31,"^:9",["^1<",[["^:3","^;>"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",751,"^:=",["^L",[null,"~$clj","^:J"]],"^9",751,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:3","^;>"]]]]],"^1?","Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function."],"~$tuple",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",522,"^8",7,"^9",522,"^:",12,"^1;",["^1<",["^9Z",["^1<",[["~$&","^:L"]]]]],"^1?","Creates a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the vector will never shrink in count.\n\n  Examples:\n\n      (def t (gen/tuple gen/small-integer gen/boolean))\n      (sample t)\n      ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; =>  [3 true] [-4 false] [9 true]))","^:F",["^ ","^:<",true,"^:G",0,"^:?",0,"^:9",[["^1<",["^:L"]]],"^1;",["^1<",[["~$&","^:L"]]],"^:;",["^1<",[null]]]],"^18","^6Z","^6","clojure/test/check/generators.cljc","^:",12,"^:F",["^ ","^:<",true,"^:G",0,"^:?",0,"^:9",[["^1<",["^:L"]]],"^1;",["^1<",[["~$&","^:L"]]],"^:;",["^1<",[null]]],"^:9",[["^1<",["^:L"]]],"^::",null,"^:G",0,"^:;",["^1<",[null]],"^8",1,"^:<",true,"^:I",[["^ ","^:G",0,"^:<",true,"^:E","^3V"]],"^7",522,"^:=","^:J","^9",522,"^:?",0,"^:@",true,"^1;",["^1<",[["~$&","^:L"]]],"^1?","Creates a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the vector will never shrink in count.\n\n  Examples:\n\n      (def t (gen/tuple gen/small-integer gen/boolean))\n      (sample t)\n      ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; =>  [3 true] [-4 false] [9 true]))"],"~$lazy-random-states",["^ ","^:B",true,"^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",72,"^8",7,"^9",72,"^:",25,"^1;",["^1<",["^9Z",["^1<",[["~$rr"]]]]],"^1?","Internal function.\n\n  Given a random number generator, returns an infinite lazy sequence\n  of random number generators.","^:B",true],"^18","^4H","^6","clojure/test/check/generators.cljc","^:",25,"^:9",["^1<",[["^=K"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",72,"^:=","^49","^9",72,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^=K"]]]]],"^1?","Internal function.\n\n  Given a random number generator, returns an infinite lazy sequence\n  of random number generators."],"~$map->Generator",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^:",21,"^8",12,"^<V",true,"~:factory","~:map","^7",28,"^9",28,"^1;",["^1<",["^9Z",["^1<",[["~$G__45889"]]]]],"^1?","Factory function for clojure.test.check.generators/Generator, taking a map of keywords to field values."],"^18","^6[","^6","clojure/test/check/generators.cljc","^:",21,"^:9",["^1<",[["^=O"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^<V",true,"^:<",false,"^=M","^=N","^7",28,"^:=","^3V","^9",28,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^=O"]]]]],"^1?","Factory function for clojure.test.check.generators/Generator, taking a map of keywords to field values."],"~$shrink-2",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",511,"^8",7,"^9",511,"^:",15,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Creates a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level)."],"^18","^4K","^6","clojure/test/check/generators.cljc","^:",15,"^:9",["^1<",[["^:2"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",511,"^:=","^3V","^9",511,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Creates a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level)."],"~$string-alpha-numeric",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1435,"^8",3,"^9",1435,"^:",23,"^;9","0.6.0"],"^18","^72","^6","clojure/test/check/generators.cljc","^:",23,"^8",1,"^7",1434,"^;9","0.6.0","^9",1435,"^:E","^3V","^1?","Deprecated - use string-alphanumeric instead.\n\n  Generates alphanumeric strings."],"~$resize",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",280,"^8",7,"^9",280,"^:",13,"^1;",["^1<",["^9Z",["^1<",[["~$n","^;;"]]]]],"^1?","Creates a new generator with `size` always bound to `n`.\n\n      (gen/sample (gen/set (gen/resize 200 gen/double)))\n      => (#{}\n          #{-4.994772362980037E147}\n          #{-4.234418056487335E-146}\n          #{}\n          #{}\n          #{}\n          #{NaN}\n          #{8.142414100982609E-63}\n          #{-3.58429955903876E-159 2.8563794617604296E-154\n            4.1021360195776005E-100 1.9084564045332549E-38}\n          #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})"],"^18","^77","^6","clojure/test/check/generators.cljc","^:",13,"^:9",["^1<",[["~$n","^;;"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",280,"^:=","^3V","^9",280,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$n","^;;"]]]]],"^1?","Creates a new generator with `size` always bound to `n`.\n\n      (gen/sample (gen/set (gen/resize 200 gen/double)))\n      => (#{}\n          #{-4.994772362980037E147}\n          #{-4.234418056487335E-146}\n          #{}\n          #{}\n          #{}\n          #{NaN}\n          #{8.142414100982609E-63}\n          #{-3.58429955903876E-159 2.8563794617604296E-154\n            4.1021360195776005E-100 1.9084564045332549E-38}\n          #{-2.1582818131881376E83 -5.8460065493236117E48 9.729260993803226E166})"],"~$digit?",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1441,"^8",8,"^9",1441,"^:",14,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$d"]]]]]],"^9Y",true,"^18","^4U","^6","clojure/test/check/generators.cljc","^:",14,"^:9",["^1<",[["~$d"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1441,"^:=","^;H","^9",1441,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$d"]]]]]],"~$scalb",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1117,"^8",17,"^9",1117,"^:",22,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$x","^;L"]]]]]],"^9Y",true,"^18","^4O","^6","clojure/test/check/generators.cljc","^:",22,"^:9",["^1<",[["~$x","^;L"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1117,"^:=","^:T","^9",1117,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$x","^;L"]]]]]],"~$neg-int",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",569,"^8",30,"^9",569,"^:",37,"^;9","0.10.0"],"^18","^7;","^6","clojure/test/check/generators.cljc","^:",37,"^8",1,"^7",569,"^;9","0.10.0","^9",569,"^:E","^3V","^1?","Deprecated - use (gen/fmap - gen/nat) instead (see also gen/large-integer).\n\n  (this generator, despite its name, can generate 0)\n\n  Generates nonpositive integers bounded by the generator's `size` parameter."],"^1J",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1422,"^8",6,"^9",1422,"^:",12],"^18","^74","^6","clojure/test/check/generators.cljc","^:",12,"^8",1,"^7",1422,"^9",1422,"^:E","^3V","^1?","Generates strings. May generate unprintable characters."],"^X",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",589,"^8",7,"^9",589,"^:",13,"^1;",["^1<",["^9Z",["^1<",[["^;;"],["^;;","^:5"],["^;;","^:6","^=A"]]]]],"^1?","Creates a generator of vectors whose elements are chosen from\n  `generator`. The count of the vector will be bounded by the `size`\n  generator parameter.","^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^;;"],["^;;","^:5"],["^;;","^:6","^=A"]],"^1;",["^1<",[["^;;"],["^;;","^:5"],["^;;","^:6","^=A"]]],"^:;",["^1<",[null,null,null]]]],"^18","^76","^6","clojure/test/check/generators.cljc","^:",13,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^;;"],["^;;","^:5"],["^;;","^:6","^=A"]],"^1;",["^1<",[["^;;"],["^;;","^:5"],["^;;","^:6","^=A"]]],"^:;",["^1<",[null,null,null]]],"^:9",[["^;;"],["^;;","^:5"],["^;;","^:6","^=A"]],"^::",null,"^:G",3,"^:;",["^1<",[null,null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",1,"^:<",false,"^:E","^3V"],["^ ","^:G",2,"^:<",false,"^:E","^:J"],["^ ","^:G",3,"^:<",false,"^:E","^3V"]],"^7",589,"^9",589,"^:?",3,"^:@",true,"^1;",["^1<",[["^;;"],["^;;","^:5"],["^;;","^:6","^=A"]]],"^1?","Creates a generator of vectors whose elements are chosen from\n  `generator`. The count of the vector will be bounded by the `size`\n  generator parameter."],"~$large-integer",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1061,"^8",24,"^9",1061,"^:",37,"^16","0.9.0"],"^16","0.9.0","^18","^7N","^6","clojure/test/check/generators.cljc","^:",37,"^8",1,"^7",1061,"^9",1061,"^:E","^:J","^1?","Generates a platform-native integer from the full available range\n  (in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and\n  (2^53 - 1)).\n\n  Use large-integer* for more control."],"~$keyword-ns",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1482,"^8",3,"^9",1482,"^:",13,"^16","0.5.9"],"^16","0.5.9","^18","^7O","^6","clojure/test/check/generators.cljc","^:",13,"^8",1,"^7",1480,"^9",1482,"^:E","^3V","^1?","Generates keywords with namespaces."],"^Y",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",480,"^8",7,"^9",480,"^:",16,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Modifies a generator so that it doesn't generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n      => ([false]\n          [false false]\n          [false false]\n          [false false false]\n          [false false false false]\n          [false true true]\n          [true false false false]\n          [true]\n          [true true true false false true false]\n          [false true true true false true true true false])"],"^18","^7E","^6","clojure/test/check/generators.cljc","^:",16,"^:9",["^1<",[["^:2"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",480,"^:=","^:J","^9",480,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Modifies a generator so that it doesn't generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/sample (gen/not-empty (gen/vector gen/boolean)))\n      => ([false]\n          [false false]\n          [false false]\n          [false false false]\n          [false false false false]\n          [false true true]\n          [true false false false]\n          [true]\n          [true true true false false true false]\n          [false true true true false true true true false])"],"~$gen-raw-long",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",992,"^8",16,"^9",992,"^:",28,"^9Y",true],"^9Y",true,"^18","^4[","^6","clojure/test/check/generators.cljc","^:",28,"^8",1,"^7",992,"^9",992,"^:E","^3V","^1?","Generates a single uniformly random long, does not shrink."],"~$NAN",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1096,"^8",16,"^9",1096,"^:",19,"^9Y",true],"^9Y",true,"^18","^7J","^6","clojure/test/check/generators.cljc","^:",19,"^8",1,"^7",1096,"^9",1096,"^:E","^;H"],"~$elements",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",408,"^8",7,"^9",408,"^:",15,"^1;",["^1<",["^9Z",["^1<",[["^;>"]]]]],"^1?","Creates a generator that randomly chooses an element from `coll`.\n\n      (gen/sample (gen/elements [:foo :bar :baz]))\n      => (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)"],"^18","^7D","^6","clojure/test/check/generators.cljc","^:",15,"^:9",["^1<",[["^;>"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",408,"^:=","^3V","^9",408,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;>"]]]]],"^1?","Creates a generator that randomly chooses an element from `coll`.\n\n      (gen/sample (gen/elements [:foo :bar :baz]))\n      => (:foo :baz :baz :bar :foo :foo :bar :bar :foo :bar)"],"~$default-such-that-opts",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",433,"^8",3,"^9",433,"^:",25,"^9Y",true],"^9Y",true,"^18","^7F","^6","clojure/test/check/generators.cljc","^:",25,"^8",1,"^7",432,"^9",433,"^:E","^<S"],"~$fifty-two-bit-reverse",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1122,"^8",17,"^9",1122,"^:",38,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$n"]]]]],"^1?","Bit-reverses an integer in the range [0, 2^52)."],"^9Y",true,"^18","^7G","^6","clojure/test/check/generators.cljc","^:",38,"^:9",["^1<",[["~$n"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1122,"^:=","^:T","^9",1122,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$n"]]]]],"^1?","Bit-reverses an integer in the range [0, 2^52)."],"~$POS_INFINITY",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1092,"^8",16,"^9",1092,"^:",28,"^9Y",true],"^9Y",true,"^18","^51","^6","clojure/test/check/generators.cljc","^:",28,"^8",1,"^7",1092,"^9",1092,"^:E","^;H"],"~$sample",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",166,"^8",7,"^9",166,"^:",13,"^1;",["^1<",["^9Z",["^1<",[["^;;"],["^;;","~$num-samples"]]]]],"^1?","Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\n\n  The sequence starts with small values from the generator, which\n  probably do not reflect the variety of values that will be generated\n  during a longer test run.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators.","^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^;;"],["^;;","^>3"]],"^1;",["^1<",[["^;;"],["^;;","^>3"]]],"^:;",["^1<",[null,null]]]],"^18","^2A","^6","clojure/test/check/generators.cljc","^:",13,"^:F",["^ ","^:<",false,"^:G",2,"^:?",2,"^:9",[["^;;"],["^;;","^>3"]],"^1;",["^1<",[["^;;"],["^;;","^>3"]]],"^:;",["^1<",[null,null]]],"^:9",[["^;;"],["^;;","^>3"]],"^::",null,"^:G",2,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",1,"^:<",false,"^:E","^:J"],["^ ","^:G",2,"^:<",false,"^:E","^49"]],"^7",166,"^9",166,"^:?",2,"^:@",true,"^1;",["^1<",[["^;;"],["^;;","^>3"]]],"^1?","Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\n\n  The sequence starts with small values from the generator, which\n  probably do not reflect the variety of values that will be generated\n  during a longer test run.\n\n  Note that this function is a dev helper and is not meant to be used\n  to build other generators."],"~$randomized",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1629,"^8",17,"^9",1629,"^:",27,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$func"]]]]],"^1?","Like sized, but passes an rng instead of a size."],"^9Y",true,"^18","^53","^6","clojure/test/check/generators.cljc","^:",27,"^:9",["^1<",[["^>5"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1629,"^:=","^3V","^9",1629,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^>5"]]]]],"^1?","Like sized, but passes an rng instead of a size."],"~$NEG_INFINITY",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1093,"^8",16,"^9",1093,"^:",28,"^9Y",true],"^9Y",true,"^18","^2Q","^6","clojure/test/check/generators.cljc","^:",28,"^8",1,"^7",1093,"^9",1093,"^:E","^;H"],"^Z",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",620,"^8",7,"^9",620,"^:",11,"^1;",["^1<",["^9Z",["^1<",[["^;;"]]]]],"^1?","Like `vector`, but generates lists."],"^18","^5C","^6","clojure/test/check/generators.cljc","^:",11,"^:9",["^1<",[["^;;"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",620,"^:=","^3V","^9",620,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;;"]]]]],"^1?","Like `vector`, but generates lists."],"~$large-integer*",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1039,"^8",7,"^9",1039,"^:",21,"^1;",["^1<",["^9Z",["^1<",[[["^ ","^<6",["^:Q","^:R"]]]]]]],"^1?","Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\n\n      (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n      => (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)","^16","0.9.0"],"^16","0.9.0","^18","^5D","^6","clojure/test/check/generators.cljc","^:",21,"^:9",["^1<",[["~$p__46175"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1039,"^:=","^:J","^9",1039,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[[["^ ","^<6",["^:Q","^:R"]]]]]]],"^1?","Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\n\n      (gen/sample (gen/large-integer* {:min 9000 :max 10000}))\n      => (9000 9001 9001 9002 9000 9003 9006 9030 9005 9044)"],"^[",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1002,"^8",17,"^9",1002,"^:",20,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]]],"^9Y",true,"^18","^2N","^6","clojure/test/check/generators.cljc","^:",20,"^:9",["^1<",[["~$x"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1002,"^:=","^:J","^9",1002,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$x"]]]]]],"^10",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1474,"^8",6,"^9",1474,"^:",13],"^18","^2P","^6","clojure/test/check/generators.cljc","^:",13,"^8",1,"^7",1474,"^9",1474,"^:E","^3V","^1?","Generates keywords without namespaces."],"~$gen-tuple",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",84,"^8",8,"^9",84,"^:",17,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$gens"]]]]],"^1?","Takes a collection of generators and returns a generator of vectors."],"^9Y",true,"^18","^2L","^6","clojure/test/check/generators.cljc","^:",17,"^:9",["^1<",[["^>:"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",84,"^:=","^3V","^9",84,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^>:"]]]]],"^1?","Takes a collection of generators and returns a generator of vectors."],"~$bind-helper",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",116,"^8",8,"^9",116,"^:",19,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$f"]]]]]],"^9Y",true,"^18","^2H","^6","clojure/test/check/generators.cljc","^:",19,"^:9",["^1<",[["~$f"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",116,"^:=","^<X","^9",116,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$f"]]]]]],"^11",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",665,"^8",7,"^9",665,"^:",15,"^1;",["^1<",["^9Z",["^1<",[["~$&","~$kvs"]]]]],"^1?","Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n       (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n       => ({:a false, :b 0}\n           {:a true,  :b 1}\n           {:a false, :b 2}\n           {:a true,  :b 2}\n           {:a false, :b 4}\n           {:a false, :b 2}\n           {:a true,  :b 3}\n           {:a true,  :b 4}\n           {:a false, :b 1}\n           {:a false, :b 0})","^:F",["^ ","^:<",true,"^:G",0,"^:?",0,"^:9",[["^1<",["^><"]]],"^1;",["^1<",[["~$&","^><"]]],"^:;",["^1<",[null]]]],"^18","^2O","^6","clojure/test/check/generators.cljc","^:",15,"^:F",["^ ","^:<",true,"^:G",0,"^:?",0,"^:9",[["^1<",["^><"]]],"^1;",["^1<",[["~$&","^><"]]],"^:;",["^1<",[null]]],"^:9",[["^1<",["^><"]]],"^::",null,"^:G",0,"^:;",["^1<",[null]],"^8",1,"^:<",true,"^:I",[["^ ","^:G",0,"^:<",true,"^:E","^3V"]],"^7",665,"^:=","^:J","^9",665,"^:?",0,"^:@",true,"^1;",["^1<",[["~$&","^><"]]],"^1?","Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n       (gen/sample (gen/hash-map :a gen/boolean :b gen/nat))\n       => ({:a false, :b 0}\n           {:a true,  :b 1}\n           {:a false, :b 2}\n           {:a true,  :b 2}\n           {:a false, :b 4}\n           {:a false, :b 2}\n           {:a true,  :b 3}\n           {:a true,  :b 4}\n           {:a false, :b 1}\n           {:a false, :b 0})"],"~$call-gen",["^ ","^:B",true,"^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",39,"^8",7,"^9",39,"^:",15,"^1;",["^1<",["^9Z",["^1<",[[["^ ","^<B","^:C"],"~$rnd","^:4"]]]]],"^1?","Internal function.","^:B",true],"^18","^2J","^6","clojure/test/check/generators.cljc","^:",15,"^:9",["^1<",[["~$p__45911","^>>","^:4"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",39,"^:=","^:J","^9",39,"^:?",3,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[[["^ ","^<B","^:C"],"^>>","^:4"]]]]],"^1?","Internal function."],"~$rand-range",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",246,"^8",8,"^9",246,"^:",18,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^>>","^:W","^:X"]]]]]],"^9Y",true,"^18","^2U","^6","clojure/test/check/generators.cljc","^:",18,"^:9",["^1<",[["^>>","^:W","^:X"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",246,"^:=","^:T","^9",246,"^:?",3,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^>>","^:W","^:X"]]]]]],"~$ratio",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1504,"^8",6,"^9",1504,"^:",11],"^18","^2T","^6","clojure/test/check/generators.cljc","^:",11,"^8",1,"^7",1504,"^9",1504,"^:E","^3V","^1?","Generates a small ratio (or integer) using gen/small-integer. Shrinks\n  toward simpler ratios, which may be larger or smaller."],"~$transient-set-contains?",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",695,"^8",17,"^9",695,"^:",40,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$s","~$k"]]]]]],"^9Y",true,"^18","^2R","^6","clojure/test/check/generators.cljc","^:",40,"^:9",["^1<",[["~$s","~$k"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",695,"^:=","^P","^9",695,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$s","~$k"]]]]]],"~$such-that",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",440,"^8",7,"^9",440,"^:",16,"^1;",["^1<",["^9Z",["^1<",[["^<5","^:2"],["^<5","^:2","~$max-tries-or-opts"]]]]],"^1?","Creates a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be thrown. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/small-integer))\n\n  You can customize `such-that` by passing an optional third argument, which can\n  either be an integer representing the maximum number of times test.check\n  will try to generate a value matching the predicate, or a map:\n\n      :max-tries  positive integer, the maximum number of tries (default 10)\n      :ex-fn      a function of one arg that will be called if test.check cannot\n                  generate a matching value; it will be passed a map with `:gen`,\n                  `:pred`, and `:max-tries` and should return an exception","^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^<5","^:2"],["^<5","^:2","^>D"]],"^1;",["^1<",[["^<5","^:2"],["^<5","^:2","^>D"]]],"^:;",["^1<",[null,null]]]],"^18","^5P","^6","clojure/test/check/generators.cljc","^:",16,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^<5","^:2"],["^<5","^:2","^>D"]],"^1;",["^1<",[["^<5","^:2"],["^<5","^:2","^>D"]]],"^:;",["^1<",[null,null]]],"^:9",[["^<5","^:2"],["^<5","^:2","^>D"]],"^::",null,"^:G",3,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",2,"^:<",false,"^:E","^:J"],["^ ","^:G",3,"^:<",false,"^:E","^3V"]],"^7",440,"^9",440,"^:?",3,"^:@",true,"^1;",["^1<",[["^<5","^:2"],["^<5","^:2","^>D"]]],"^1?","Creates a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be thrown. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/small-integer))\n\n  You can customize `such-that` by passing an optional third argument, which can\n  either be an integer representing the maximum number of times test.check\n  will try to generate a value matching the predicate, or a map:\n\n      :max-tries  positive integer, the maximum number of tries (default 10)\n      :ex-fn      a function of one arg that will be called if test.check cannot\n                  generate a matching value; it will be passed a map with `:gen`,\n                  `:pred`, and `:max-tries` and should return an exception"],"~$shrink-int",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",209,"^8",8,"^9",209,"^:",18,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$integer"]]]]]],"^9Y",true,"^18","^5M","^6","clojure/test/check/generators.cljc","^:",18,"^:9",["^1<",[["^>F"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",209,"^:=","^49","^9",209,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^>F"]]]]]],"~$random-pseudofactoring",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1611,"^8",19,"^9",1611,"^:",41,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$n","^:3"]]]]],"^1?","Returns (not generates) a random collection of integers `xs`\n  greater than 1 such that (<= (apply * xs) n)."],"^9Y",true,"^18","^32","^6","clojure/test/check/generators.cljc","^:",41,"^:9",["^1<",[["~$n","^:3"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",3,"^:<",false,"^7",1611,"^:=","^=H","^9",1611,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$n","^:3"]]]]],"^1?","Returns (not generates) a random collection of integers `xs`\n  greater than 1 such that (<= (apply * xs) n)."],"~$vector-distinct-by",["^ ","^9X",null,"^5",["^ ","^16","0.9.0","^6","clojure/test/check/generators.cljc","^:",25,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^:0","^:2"],["^:0","^:2","^:H"]],"^1;",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^8",7,"^7",865,"^9",865,"^1;",["^1<",["^9Z",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]]]],"^1?","Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"^16","0.9.0","^18","^36","^6","clojure/test/check/generators.cljc","^:",25,"^:F",["^ ","^:<",false,"^:G",3,"^:?",3,"^:9",[["^:0","^:2"],["^:0","^:2","^:H"]],"^1;",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]],"^:;",["^1<",[null,null]]],"^:9",[["^:0","^:2"],["^:0","^:2","^:H"]],"^::",null,"^:G",3,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^:I",[["^ ","^:G",2,"^:<",false,"^:E","^:J"],["^ ","^:G",3,"^:<",false,"^:E","^3V"]],"^7",865,"^9",865,"^:?",3,"^:@",true,"^1;",["^1<",[["^:0","^:2"],["^:0","^:2","^:H"]]],"^1?","Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as `such-that`.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\n    :ex-fn         a function of one arg that will be called if test.check cannot\n                   generate enough distinct values; it will be passed a map with\n                   `:gen`, `:num-elements`, and `:max-tries` and should return an\n                   exception"],"~$swap",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",632,"^8",8,"^9",632,"^:",12,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^;>",["~$i1","~$i2"]]]]]]],"^9Y",true,"^18","^37","^6","clojure/test/check/generators.cljc","^:",12,"^:9",["^1<",[["^;>","~$p__46058"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",632,"^:=",["^L",["^=H","^:J"]],"^9",632,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;>",["^>J","^>K"]]]]]]],"~$size->max-leaf-count",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1603,"^8",17,"^9",1603,"^:",37,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^:4"]]]]]],"^9Y",true,"^18","^3:","^6","clojure/test/check/generators.cljc","^:",37,"^:9",["^1<",[["^:4"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1603,"^:=","^:T","^9",1603,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:4"]]]]]],"~$int-rose-tree",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",213,"^8",8,"^9",213,"^:",21,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["^;U"]]]]]],"^9Y",true,"^18","^5I","^6","clojure/test/check/generators.cljc","^:",21,"^:9",["^1<",[["^;U"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",213,"^:=","^:>","^9",213,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^;U"]]]]]],"~$fmap",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",94,"^8",7,"^9",94,"^:",11,"^1;",["^1<",["^9Z",["^1<",[["~$f","^:2"]]]]],"^1?","Returns a generator like `gen` but with values transformed by `f`.\n  E.g.:\n\n      (gen/sample (gen/fmap str gen/nat))\n      => (\"0\" \"1\" \"0\" \"1\" \"4\" \"3\" \"6\" \"6\" \"4\" \"2\")\n\n  Also see gen/let for a macro with similar functionality."],"^18","^33","^6","clojure/test/check/generators.cljc","^:",11,"^:9",["^1<",[["~$f","^:2"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",94,"^:=","^3V","^9",94,"^:?",2,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$f","^:2"]]]]],"^1?","Returns a generator like `gen` but with values transformed by `f`.\n  E.g.:\n\n      (gen/sample (gen/fmap str gen/nat))\n      => (\"0\" \"1\" \"0\" \"1\" \"4\" \"3\" \"6\" \"6\" \"4\" \"2\")\n\n  Also see gen/let for a macro with similar functionality."],"~$MAX_INTEGER",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",997,"^8",16,"^9",997,"^:",27,"^9Y",true],"^9Y",true,"^18","^3<","^6","clojure/test/check/generators.cljc","^:",27,"^8",1,"^7",997,"^9",997,"^:E","^:T"],"~$->Generator",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^:",21,"^8",12,"^<V",true,"^=M","~:positional","^7",28,"^9",28,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Positional factory function for clojure.test.check.generators/Generator."],"^18","^5T","^6","clojure/test/check/generators.cljc","^:",21,"^:9",["^1<",[["^:2"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^<V",true,"^:<",false,"^=M","^>R","^7",28,"^:=","^3V","^9",28,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Positional factory function for clojure.test.check.generators/Generator."],"~$no-shrink",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",501,"^8",7,"^9",501,"^:",16,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Creates a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain."],"^18","^5Y","^6","clojure/test/check/generators.cljc","^:",16,"^:9",["^1<",[["^:2"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",501,"^:=","^3V","^9",501,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^:2"]]]]],"^1?","Creates a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain."],"~$char-ascii",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1383,"^8",6,"^9",1383,"^:",16],"^18","^3C","^6","clojure/test/check/generators.cljc","^:",16,"^8",1,"^7",1383,"^9",1383,"^:E","^3V","^1?","Generates only ascii characters."],"~$simple-type-printable",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1564,"^8",6,"^9",1564,"^:",27],"^18","^64","^6","clojure/test/check/generators.cljc","^:",27,"^8",1,"^7",1564,"^9",1564,"^:E","^3V","^1?","Generates a variety of scalar types, with printable strings."],"~$base-simple-type",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1555,"^8",17,"^9",1555,"^:",33,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$double-gen","~$char-gen","~$string-gen"]]]]]],"^9Y",true,"^18","^66","^6","clojure/test/check/generators.cljc","^:",33,"^:9",["^1<",[["^>W","^>X","^>Y"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",1555,"^:=","^3V","^9",1555,"^:?",3,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["^>W","^>X","^>Y"]]]]]],"~$halfs",["^ ","^9X",null,"^5",["^ ","^6","clojure/test/check/generators.cljc","^7",205,"^8",8,"^9",205,"^:",13,"^9Y",true,"^1;",["^1<",["^9Z",["^1<",[["~$n"]]]]]],"^9Y",true,"^18","^3P","^6","clojure/test/check/generators.cljc","^:",13,"^:9",["^1<",[["~$n"]]],"^::",null,"^:;",["^1<",[null,null]],"^8",1,"^:<",false,"^7",205,"^:=","^49","^9",205,"^:?",1,"^:@",true,"^1;",["^1<",["^9Z",["^1<",[["~$n"]]]]]],"~$symbol-name-or-namespace",["^ ","^5",["^ ","^6","clojure/test/check/generators.cljc","^7",1457,"^8",16,"^9",1457,"^:",40,"^9Y",true],"^9Y",true,"^18","^3H","^6","clojure/test/check/generators.cljc","^:",40,"^8",1,"^7",1457,"^9",1457,"^:E","^3V","^1?","Generates a namespace string for a symbol/keyword."]],"^1P",["^ ","^C","^C","^1M","^C","^J","^J"],"~:cljs.analyzer/constants",["^ ","^1N",["^L",["~:max-tries","~:min","~:max-tries-or-opts","~:pred","~:else","^:C","^:2","~:infinite?","~:max","~$/","~:max-elements","~:ex-fn","~:num-elements","~:min-elements","~:NaN?"]],"~:order",["^:C","^:2","^?9","^?1","^?4","^?5","^?3","^?:","^?;","^?8","^?2","^?7","^?6","^?<","~$/"]],"^1Y",["^ ","^1O",["^L",[]],"^1P",["^L",[]]],"^1Z",["^ "],"^1[",["^1H","^C","^1K","^1I","^1G","^1E"]],"^17","^J","~:ns-specs",["^ "],"~:ns-spec-vars",["^L",[]],"~:compiler-options",["^7W",[["^?@","~:static-fns"],true,["^?@","~:shadow-tweaks"],null,["^?@","~:source-map-inline"],null,["^?@","~:elide-asserts"],false,["^?@","~:optimize-constants"],null,["^?@","^24"],null,["^?@","~:external-config"],null,["^?@","~:tooling-config"],null,["^?@","~:emit-constants"],null,["^?@","~:load-tests"],null,["^?@","~:form-size-threshold"],null,["^?@","~:global-goog-object&array"],null,["^?@","~:data-readers"],null,["^?@","~:infer-externs"],"~:auto",["^?@","^26"],["^L",["^27","^28"]],["~:js-options","~:js-provider"],"^1O",["~:mode"],"~:dev",["^?@","~:fn-invoke-direct"],null,["^?@","~:source-map"],"/dev/null"]]]