["^ ","~:output",["^ ","~:js","goog.provide('clojure.test.check');\n\nclojure.test.check.make_rng = (function clojure$test$check$make_rng(seed){\nif(cljs.core.truth_(seed)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [seed,clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1(seed)], null);\n} else {\nvar non_nil_seed = clojure.test.check.impl.get_current_time_millis();\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [non_nil_seed,clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1(non_nil_seed)], null);\n}\n});\nclojure.test.check.complete = (function clojure$test$check$complete(property,num_trials,seed,start_time,reporter_fn){\nvar time_elapsed_ms = (clojure.test.check.impl.get_current_time_millis() - start_time);\nvar G__46383_46460 = new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"complete\",\"complete\",-500388775),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),property,new cljs.core.Keyword(null,\"result\",\"result\",1415092211),true,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),true,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),num_trials,new cljs.core.Keyword(null,\"time-elapsed-ms\",\"time-elapsed-ms\",-755913315),time_elapsed_ms,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),seed], null);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__46383_46460) : reporter_fn.call(null,G__46383_46460));\n\nreturn new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"result\",\"result\",1415092211),true,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),true,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),num_trials,new cljs.core.Keyword(null,\"time-elapsed-ms\",\"time-elapsed-ms\",-755913315),time_elapsed_ms,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),seed], null);\n});\n/**\n * Returns a value for the legacy :result key, which has the peculiar\n *   property of conflating returned exceptions with thrown exceptions.\n */\nclojure.test.check.legacy_result = (function clojure$test$check$legacy_result(result){\nif((((!((result == null))))?((((false) || ((cljs.core.PROTOCOL_SENTINEL === result.clojure$test$check$results$Result$))))?true:(((!result.cljs$lang$protocol_mask$partition$))?cljs.core.native_satisfies_QMARK_(clojure.test.check.results.Result,result):false)):cljs.core.native_satisfies_QMARK_(clojure.test.check.results.Result,result))){\nvar d = clojure.test.check.results.result_data(result);\nvar temp__5802__auto__ = cljs.core.find(d,new cljs.core.Keyword(\"clojure.test.check.properties\",\"error\",\"clojure.test.check.properties/error\",483933635));\nif(cljs.core.truth_(temp__5802__auto__)){\nvar vec__46391 = temp__5802__auto__;\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46391,(0),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46391,(1),null);\nif((e instanceof Error)){\nreturn e;\n} else {\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$3(\"Non-Error object thrown in test\",cljs.core.PersistentArrayMap.EMPTY,e);\n}\n} else {\nreturn clojure.test.check.results.pass_QMARK_(result);\n}\n} else {\nreturn result;\n}\n});\n/**\n * Tests `property` `num-tests` times.\n * \n *   Takes several optional keys:\n * \n *   `:seed`\n *  Can be used to re-run previous tests, as the seed used is returned\n *  after a test is run.\n * \n *   `:max-size`.\n *  can be used to control the 'size' of generated values. The size will\n *  start at 0, and grow up to max-size, as the number of tests increases.\n *  Generators will use the size parameter to bound their growth. This\n *  prevents, for example, generating a five-thousand element vector on\n *  the very first test.\n * \n *   `:reporter-fn`\n *  A callback function that will be called at various points in the test\n *  run, with a map like:\n * \n *    ;; called after a passing trial\n *    {:type            :trial\n *     :args            [...]\n *     :num-tests       <number of tests run so far>\n *     :num-tests-total <total number of tests to be run>\n *     :seed            42\n *     :pass?           true\n *     :property        #<...>\n *     :result          true\n *     :result-data     {...}}\n * \n *    ;; called after the first failing trial\n *    {:type         :failure\n *     :fail         [...failing args...]\n *     :failing-size 13\n *     :num-tests    <tests ran before failure found>\n *     :pass?        false\n *     :property     #<...>\n *     :result       false/exception\n *     :result-data  {...}\n *     :seed         42}\n * \n *  It will also be called on :complete, :shrink-step and :shrunk. Many\n *  of the keys also appear in the quick-check return value, and are\n *  documented below.\n * \n *   If the test passes, the return value will be something like:\n * \n *    {:num-tests       100,\n *     :pass?           true,\n *     :result          true,\n *     :seed            1561826505982,\n *     :time-elapsed-ms 24}\n * \n *   If the test fails, the return value will be something like:\n * \n *    {:fail            [0],\n *     :failed-after-ms 0,\n *     :failing-size    0,\n *     :num-tests       1,\n *     :pass?           false,\n *     :result          false,\n *     :result-data     nil,\n *     :seed            1561826506080,\n *     :shrunk\n *     {:depth               0,\n *      :pass?               false,\n *      :result              false,\n *      :result-data         nil,\n *      :smallest            [0],\n *      :time-shrinking-ms   0,\n *      :total-nodes-visited 0}}\n * \n *   The meaning of the individual entries is:\n * \n *    :num-tests\n *    The total number of trials that was were run, not including\n *    shrinking (if applicable)\n * \n *    :pass?\n *    A boolean indicating whether the test passed or failed\n * \n *    :result\n *    A legacy entry that is similar to :pass?\n * \n *    :seed\n *    The seed used for the entire test run; can be used to reproduce\n *    a test run by passing it as the :seed option to quick-check\n * \n *    :time-elapsed-ms\n *    The total time, in milliseconds, of a successful test run\n * \n *    :fail\n *    The generated values for the first failure; note that this is\n *    always a vector, since prop/for-all can have multiple clauses\n * \n *    :failed-after-ms\n *    The total time, in milliseconds, spent finding the first failing\n *    trial\n * \n *    :failing-size\n *    The value of the size parameter used to generate the first\n *    failure\n * \n *    :result-data\n *    The result data, if any, of the first failing trial (to take\n *    advantage of this a property must return an object satisfying\n *    the clojure.test.check.results/Result protocol)\n * \n *    :shrunk\n *    A map of data about the shrinking process; nested keys that\n *    appear at the top level have the same meaning; other keys are\n *    documented next\n * \n *    :shrunk / :depth\n *    The depth in the shrink tree that the smallest failing instance\n *    was found; this is essentially the idea of how many times the\n *    original failure was successfully shrunk\n * \n *    :smallest\n *    The smallest values found in the shrinking process that still\n *    fail the test; this is a vector of the same type as :fail\n * \n *    :time-shrinking-ms\n *    The total time, in milliseconds, spent shrinking\n * \n *    :total-nodes-visited\n *    The total number of steps in the shrinking process\n * \n *   Examples:\n * \n *    (def p (for-all [a gen/nat] (> (* a a) a)))\n * \n *    (quick-check 100 p)\n *    (quick-check 200 p\n *                 :seed 42\n *                 :max-size 50\n *                 :reporter-fn (fn [m]\n *                                (when (= :failure (:type m))\n *                                  (println \"Uh oh...\"))))\n */\nclojure.test.check.quick_check = (function clojure$test$check$quick_check(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___46463 = arguments.length;\nvar i__5770__auto___46464 = (0);\nwhile(true){\nif((i__5770__auto___46464 < len__5769__auto___46463)){\nargs__5775__auto__.push((arguments[i__5770__auto___46464]));\n\nvar G__46465 = (i__5770__auto___46464 + (1));\ni__5770__auto___46464 = G__46465;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((2) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((2)),(0),null)):null);\nreturn clojure.test.check.quick_check.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5776__auto__);\n});\n\n(clojure.test.check.quick_check.cljs$core$IFn$_invoke$arity$variadic = (function (num_tests,property,p__46403){\nvar map__46404 = p__46403;\nvar map__46404__$1 = cljs.core.__destructure_map(map__46404);\nvar seed = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46404__$1,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327));\nvar max_size = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__46404__$1,new cljs.core.Keyword(null,\"max-size\",\"max-size\",-874966132),(200));\nvar reporter_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__46404__$1,new cljs.core.Keyword(null,\"reporter-fn\",\"reporter-fn\",1280520247),cljs.core.constantly(null));\nvar vec__46405 = clojure.test.check.make_rng(seed);\nvar created_seed = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46405,(0),null);\nvar rng = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46405,(1),null);\nvar size_seq = clojure.test.check.generators.make_size_range_seq(max_size);\nvar start_time = clojure.test.check.impl.get_current_time_millis();\nvar so_far = (0);\nvar size_seq__$1 = size_seq;\nvar rstate = rng;\nwhile(true){\nif((so_far === num_tests)){\nreturn clojure.test.check.complete(property,num_tests,created_seed,start_time,reporter_fn);\n} else {\nvar vec__46416 = size_seq__$1;\nvar seq__46417 = cljs.core.seq(vec__46416);\nvar first__46418 = cljs.core.first(seq__46417);\nvar seq__46417__$1 = cljs.core.next(seq__46417);\nvar size = first__46418;\nvar rest_size_seq = seq__46417__$1;\nvar vec__46419 = clojure.test.check.random.split(rstate);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46419,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__46419,(1),null);\nvar result_map_rose = clojure.test.check.generators.call_gen(property,r1,size);\nvar result_map = clojure.test.check.rose_tree.root(result_map_rose);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(result_map);\nvar args = new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(result_map);\nvar so_far__$1 = (so_far + (1));\nif(cljs.core.truth_(clojure.test.check.results.pass_QMARK_(result))){\nvar G__46425_46466 = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"args\",\"args\",1315556576),new cljs.core.Keyword(null,\"num-tests-total\",\"num-tests-total\",-2113009946),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),new cljs.core.Keyword(null,\"result\",\"result\",1415092211),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753)],[args,num_tests,property,so_far__$1,new cljs.core.Keyword(null,\"trial\",\"trial\",-677458347),seed,result,clojure.test.check.results.result_data(result),true]);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__46425_46466) : reporter_fn.call(null,G__46425_46466));\n\nvar G__46468 = so_far__$1;\nvar G__46469 = rest_size_seq;\nvar G__46470 = r2;\nso_far = G__46468;\nsize_seq__$1 = G__46469;\nrstate = G__46470;\ncontinue;\n} else {\nreturn (clojure.test.check.failure.cljs$core$IFn$_invoke$arity$7 ? clojure.test.check.failure.cljs$core$IFn$_invoke$arity$7(property,result_map_rose,so_far__$1,size,created_seed,start_time,reporter_fn) : clojure.test.check.failure.call(null,property,result_map_rose,so_far__$1,size,created_seed,start_time,reporter_fn));\n}\n}\nbreak;\n}\n}));\n\n(clojure.test.check.quick_check.cljs$lang$maxFixedArity = (2));\n\n/** @this {Function} */\n(clojure.test.check.quick_check.cljs$lang$applyTo = (function (seq46399){\nvar G__46400 = cljs.core.first(seq46399);\nvar seq46399__$1 = cljs.core.next(seq46399);\nvar G__46401 = cljs.core.first(seq46399__$1);\nvar seq46399__$2 = cljs.core.next(seq46399__$1);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__46400,G__46401,seq46399__$2);\n}));\n\nclojure.test.check.smallest_shrink = (function clojure$test$check$smallest_shrink(total_nodes_visited,depth,smallest,start_time){\nvar map__46430 = smallest;\nvar map__46430__$1 = cljs.core.__destructure_map(map__46430);\nvar result = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__46430__$1,new cljs.core.Keyword(null,\"result\",\"result\",1415092211));\nreturn new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"total-nodes-visited\",\"total-nodes-visited\",-620132443),total_nodes_visited,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),depth,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),false,new cljs.core.Keyword(null,\"result\",\"result\",1415092211),clojure.test.check.legacy_result(result),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),clojure.test.check.results.result_data(result),new cljs.core.Keyword(null,\"time-shrinking-ms\",\"time-shrinking-ms\",-383238219),(clojure.test.check.impl.get_current_time_millis() - start_time),new cljs.core.Keyword(null,\"smallest\",\"smallest\",-152623883),new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(smallest)], null);\n});\n/**\n * Shrinking a value produces a sequence of smaller values of the same type.\n *   Each of these values can then be shrunk. Think of this as a tree. We do a\n *   modified depth-first search of the tree:\n * \n *   Do a non-exhaustive search for a deeper (than the root) failing example.\n *   Additional rules added to depth-first search:\n *   * If a node passes the property, you may continue searching at this depth,\n *   but not backtrack\n *   * If a node fails the property, search its children\n *   The value returned is the left-most failing example at the depth where a\n *   passing example was found.\n * \n *   Calls reporter-fn on every shrink step.\n */\nclojure.test.check.shrink_loop = (function clojure$test$check$shrink_loop(rose_tree,reporter_fn){\nvar start_time = clojure.test.check.impl.get_current_time_millis();\nvar shrinks_this_depth = clojure.test.check.rose_tree.children(rose_tree);\nvar nodes = shrinks_this_depth;\nvar current_smallest = clojure.test.check.rose_tree.root(rose_tree);\nvar total_nodes_visited = (0);\nvar depth = (0);\nwhile(true){\nif(cljs.core.empty_QMARK_(nodes)){\nreturn clojure.test.check.smallest_shrink(total_nodes_visited,depth,current_smallest,start_time);\n} else {\nvar head = cljs.core.first(nodes);\nvar tail = cljs.core.rest(nodes);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(clojure.test.check.rose_tree.root(head));\nvar args = new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(clojure.test.check.rose_tree.root(head));\nvar pass_QMARK_ = clojure.test.check.results.pass_QMARK_(result);\nvar reporter_fn_arg = new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"shrink-step\",\"shrink-step\",-541828120),new cljs.core.Keyword(null,\"shrinking\",\"shrinking\",2049648186),new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"args\",\"args\",1315556576),args,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),depth,new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),cljs.core.boolean$(pass_QMARK_),new cljs.core.Keyword(null,\"result\",\"result\",1415092211),result,new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),clojure.test.check.results.result_data(result),new cljs.core.Keyword(null,\"smallest\",\"smallest\",-152623883),new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(current_smallest),new cljs.core.Keyword(null,\"total-nodes-visited\",\"total-nodes-visited\",-620132443),total_nodes_visited], null)], null);\nif(cljs.core.truth_(pass_QMARK_)){\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(reporter_fn_arg) : reporter_fn.call(null,reporter_fn_arg));\n\nvar G__46474 = tail;\nvar G__46475 = current_smallest;\nvar G__46476 = (total_nodes_visited + (1));\nvar G__46477 = depth;\nnodes = G__46474;\ncurrent_smallest = G__46475;\ntotal_nodes_visited = G__46476;\ndepth = G__46477;\ncontinue;\n} else {\nvar new_smallest = clojure.test.check.rose_tree.root(head);\nvar G__46449_46478 = cljs.core.assoc_in(reporter_fn_arg,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"shrinking\",\"shrinking\",2049648186),new cljs.core.Keyword(null,\"smallest\",\"smallest\",-152623883)], null),new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(new_smallest));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__46449_46478) : reporter_fn.call(null,G__46449_46478));\n\nvar temp__5802__auto__ = cljs.core.seq(clojure.test.check.rose_tree.children(head));\nif(temp__5802__auto__){\nvar children = temp__5802__auto__;\nvar G__46479 = children;\nvar G__46480 = new_smallest;\nvar G__46481 = (total_nodes_visited + (1));\nvar G__46482 = (depth + (1));\nnodes = G__46479;\ncurrent_smallest = G__46480;\ntotal_nodes_visited = G__46481;\ndepth = G__46482;\ncontinue;\n} else {\nvar G__46483 = tail;\nvar G__46484 = new_smallest;\nvar G__46485 = (total_nodes_visited + (1));\nvar G__46486 = depth;\nnodes = G__46483;\ncurrent_smallest = G__46484;\ntotal_nodes_visited = G__46485;\ndepth = G__46486;\ncontinue;\n}\n}\n}\nbreak;\n}\n});\nclojure.test.check.failure = (function clojure$test$check$failure(property,failing_rose_tree,trial_number,size,seed,start_time,reporter_fn){\nvar failed_after_ms = (clojure.test.check.impl.get_current_time_millis() - start_time);\nvar root = clojure.test.check.rose_tree.root(failing_rose_tree);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(root);\nvar failure_data = cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,\"failed-after-ms\",\"failed-after-ms\",912141156),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930),new cljs.core.Keyword(null,\"result\",\"result\",1415092211),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),new cljs.core.Keyword(null,\"failing-size\",\"failing-size\",-429562538),new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753)],[failed_after_ms,property,trial_number,seed,new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(root),clojure.test.check.legacy_result(result),clojure.test.check.results.result_data(result),size,false]);\nvar G__46452_46487 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(failure_data,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"failure\",\"failure\",720415879));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__46452_46487) : reporter_fn.call(null,G__46452_46487));\n\nvar shrunk = clojure.test.check.shrink_loop(failing_rose_tree,(function (p1__46450_SHARP_){\nvar G__46454 = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([failure_data,p1__46450_SHARP_], 0));\nreturn (reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__46454) : reporter_fn.call(null,G__46454));\n}));\nvar G__46455_46488 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(failure_data,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),shrunk], 0));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__46455_46488) : reporter_fn.call(null,G__46455_46488));\n\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(failure_data,new cljs.core.Keyword(null,\"property\",\"property\",-1114278232)),new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),shrunk);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",23],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.core","~$cljs.core","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.core.match","~$cljs.core.match"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^R","~$rose","~$clojure.test.check.rose-tree","~$results","^R","~$clojure.test.check.impl","^V","^T","^T","^C","^C","~$clojure.test.check.generators","^W","~$goog","^X","~$gen","^W","~$clojure.test.check.random","^Z","~$random","^Z"],"~:seen",["^J",["~:require"]],"~:uses",["^ ","~$get-current-time-millis","^V"],"~:require-macros",["^ ","^C","^C","^W","^W","^Y","^W"],"~:form",["~#list",["~$ns","^L",["^16",["^11",["^W","~:as","^Y"],["^Z","^18","^["],["^R","^18","^U"],["^T","^18","^S"],["^V","~:refer",["^13"]]]]]],"~:flags",["^ ","^11",["^J",[]]],"~:js-deps",["^ "],"~:deps",["^X","^C","^W","^Z","^R","^T","^V"]],"^O","^L","~:resource-id",["~:shadow.build.classpath/resource","clojure/test/check.cljc"],"~:compiled-at",1692014592052,"^M",["^ ","^R","^R","^S","^T","^U","^R","^V","^V","^T","^T","^C","^C","^W","^W","^X","^X","^Y","^W","^Z","^Z","^[","^Z"],"~:resource-name","clojure/test/check.cljc","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.results :as results]\n            [clojure.test.check.rose-tree :as rose]\n            [clojure.test.check.impl :refer [get-current-time-millis]]))\n\n(declare shrink-loop failure)\n\n(defn- make-rng\n  [seed]\n  (if seed\n    [seed (random/make-random seed)]\n    (let [non-nil-seed (get-current-time-millis)]\n      [non-nil-seed (random/make-random non-nil-seed)])))\n\n(defn- complete\n  [property num-trials seed start-time reporter-fn]\n  (let [time-elapsed-ms (- (get-current-time-millis) start-time)]\n    (reporter-fn {:type :complete\n                  :property property\n                  :result true\n                  :pass? true\n                  :num-tests num-trials\n                  :time-elapsed-ms time-elapsed-ms\n                  :seed seed})\n    {:result true\n     :pass? true\n     :num-tests num-trials\n     :time-elapsed-ms time-elapsed-ms\n     :seed seed}))\n\n\n(defn ^:private legacy-result\n  \"Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions.\"\n  [result]\n  (if (satisfies? results/Result result)\n    (let [d (results/result-data result)]\n      (if-let [[_ e] (find d :clojure.test.check.properties/error)]\n        #?(:clj e\n           :cljs (if (instance? js/Error e)\n                   e\n                   (ex-info \"Non-Error object thrown in test\"\n                            {}\n                            e)))\n        (results/pass? result)))\n    result))\n\n(defn quick-check\n  \"Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \\\"Uh oh...\\\"))))\"\n  [num-tests property & {:keys [seed max-size reporter-fn]\n                         :or {max-size 200, reporter-fn (constantly nil)}}]\n  (let [[created-seed rng] (make-rng seed)\n        size-seq (gen/make-size-range-seq max-size)\n        start-time (get-current-time-millis)]\n    (loop [so-far 0\n           size-seq size-seq\n           rstate rng]\n      (if (== so-far num-tests)\n        (complete property num-tests created-seed start-time reporter-fn)\n        (let [[size & rest-size-seq] size-seq\n              [r1 r2] (random/split rstate)\n              result-map-rose (gen/call-gen property r1 size)\n              result-map (rose/root result-map-rose)\n              result (:result result-map)\n              args (:args result-map)\n              so-far (inc so-far)]\n          (if (results/pass? result)\n            (do\n              (reporter-fn {:type            :trial\n                            :args            args\n                            :num-tests       so-far\n                            :num-tests-total num-tests\n                            :pass?           true\n                            :property        property\n                            :result          result\n                            :result-data     (results/result-data result)\n                            :seed            seed})\n              (recur so-far rest-size-seq r2))\n            (failure property result-map-rose so-far size\n                     created-seed start-time reporter-fn)))))))\n\n(defn- smallest-shrink\n  [total-nodes-visited depth smallest start-time]\n  (let [{:keys [result]} smallest]\n    {:total-nodes-visited total-nodes-visited\n     :depth depth\n     :pass? false\n     :result (legacy-result result)\n     :result-data (results/result-data result)\n     :time-shrinking-ms (- (get-current-time-millis) start-time)\n     :smallest (:args smallest)}))\n\n(defn- shrink-loop\n  \"Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step.\"\n  [rose-tree reporter-fn]\n  (let [start-time (get-current-time-millis)\n        shrinks-this-depth (rose/children rose-tree)]\n    (loop [nodes shrinks-this-depth\n           current-smallest (rose/root rose-tree)\n           total-nodes-visited 0\n           depth 0]\n      (if (empty? nodes)\n        (smallest-shrink total-nodes-visited depth current-smallest start-time)\n        (let [;; can't destructure here because that could force\n              ;; evaluation of (second nodes)\n              head (first nodes)\n              tail (rest nodes)\n              result (:result (rose/root head))\n              args (:args (rose/root head))\n              pass? (results/pass? result)\n              reporter-fn-arg {:type :shrink-step\n                               :shrinking {:args                args\n                                           :depth               depth\n                                           :pass?               (boolean pass?)\n                                           :result              result\n                                           :result-data         (results/result-data result)\n                                           :smallest            (:args current-smallest)\n                                           :total-nodes-visited total-nodes-visited}}]\n          (if pass?\n            ;; this node passed the test, so now try testing its right-siblings\n            (do\n              (reporter-fn reporter-fn-arg)\n              (recur tail current-smallest (inc total-nodes-visited) depth))\n            ;; this node failed the test, so check if it has children,\n            ;; if so, traverse down them. If not, save this as the best example\n            ;; seen now and then look at the right-siblings\n            ;; children\n            (let [new-smallest (rose/root head)]\n              (reporter-fn (assoc-in reporter-fn-arg\n                                     [:shrinking :smallest]\n                                     (:args new-smallest)))\n              (if-let [children (seq (rose/children head))]\n                (recur children new-smallest (inc total-nodes-visited) (inc depth))\n                (recur tail new-smallest (inc total-nodes-visited) depth)))))))))\n\n(defn- failure\n  [property failing-rose-tree trial-number size seed start-time reporter-fn]\n  (let [failed-after-ms (- (get-current-time-millis) start-time)\n        root (rose/root failing-rose-tree)\n        result (:result root)\n        failure-data {:fail            (:args root)\n                      :failing-size    size\n                      :num-tests       trial-number\n                      :pass?           false\n                      :property        property\n                      :result          (legacy-result result)\n                      :result-data     (results/result-data result)\n                      :failed-after-ms failed-after-ms\n                      :seed            seed}]\n\n    (reporter-fn (assoc failure-data :type :failure))\n\n    (let [shrunk (shrink-loop failing-rose-tree\n                              #(reporter-fn (merge failure-data %)))]\n      (reporter-fn (assoc failure-data\n                          :type :shrunk\n                          :shrunk shrunk))\n      (-> failure-data\n          (dissoc :property)\n          (assoc :shrunk shrunk)))))\n","~:reader-features",["^J",["~:cljs-release","~:cljs-dev","~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["clojure.test.check/make-rng","seed","clojure.test.check.random.make_random","non-nil-seed","clojure.test.check.impl/get-current-time-millis","clojure.test.check/complete","property","num-trials","start-time","reporter-fn","time-elapsed-ms","G__46383","clojure.test.check/legacy-result","result","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","clojure.test.check.results/Result","d","clojure.test.check.results/result-data","temp__5802__auto__","vec__46391","cljs.core.nth","_","e","cljs.core/find","js/Error","cljs.core.ex_info","clojure.test.check.results/pass?","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","clojure.test.check/quick-check","p__46403","map__46404","cljs.core/--destructure-map","cljs.core.get","seq46399","G__46400","cljs.core/first","cljs.core/next","G__46401","self__5754__auto__","num-tests","max-size","cljs.core/constantly","vec__46405","created-seed","rng","size-seq","clojure.test.check.generators/make-size-range-seq","so-far","rstate","vec__46416","seq__46417","cljs.core/seq","first__46418","vec__46419","size","rest-size-seq","r1","r2","clojure.test.check.random/split","result-map-rose","clojure.test.check.generators/call-gen","result-map","clojure.test.check.rose-tree/root","args","G__46425","clojure.test.check/failure","clojure.test.check/smallest-shrink","total-nodes-visited","depth","smallest","map__46430","clojure.test.check/shrink-loop","rose-tree","shrinks-this-depth","clojure.test.check.rose-tree/children","nodes","current-smallest","cljs.core/empty?","head","tail","cljs.core/rest","pass?","reporter-fn-arg","cljs.core/boolean","new-smallest","G__46449","cljs.core/assoc-in","children","failing-rose-tree","trial-number","failed-after-ms","root","failure-data","G__46452","cljs.core.assoc","shrunk","p1__46450#","G__46454","cljs.core.merge","G__46455","cljs.core.dissoc"]],"~:used-vars",["^J",["~$cljs.core/--destructure-map","~$cljs.core/PROTOCOL_SENTINEL","~$cljs.core/rest","~$clojure.test.check.random/make-random","~$clojure.test.check.generators/call-gen","~$clojure.test.check/smallest-shrink","~$clojure.test.check.random/split","~$clojure.test.check/quick-check","~$cljs.core/IndexedSeq","~$clojure.test.check.rose-tree/root","~$cljs.core/seq","~$clojure.test.check/make-rng","~$cljs.core/dissoc","~$clojure.test.check/complete","~$clojure.test.check/shrink-loop","~$cljs.core/native-satisfies?","~$cljs.core/find","~$cljs.core/empty?","~$clojure.test.check.rose-tree/children","~$clojure.test.check/legacy-result","~$cljs.core/get","~$cljs.core/constantly","~$clojure.test.check.results/Result","~$clojure.test.check/failure","~$clojure.test.check.impl/get-current-time-millis","~$cljs.core/nth","~$cljs.core/ex-info","~$cljs.core/next","~$cljs.core/not","~$clojure.test.check.generators/make-size-range-seq","~$cljs.core/assoc","~$cljs.core/assoc-in","~$clojure.test.check.results/pass?","~$cljs.core/first","~$clojure.test.check.results/result-data","~$cljs.core/merge","~$js/Error","~$cljs.core/boolean"]]],"~:cache-keys",["~#cmap",[["^1>","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^J",[]],"~:deps-syms",["^X","~$goog.dom.HtmlElement"]]],["^1>","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.asserts","~$goog.string.internal","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^1>","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^2P"]]],["^1>","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O"]]],["^1>","clojure/test/check/generators.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C","~$clojure.string","^Z","^T","~$goog.string"]]],["^1>","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","clojure/test/check/random/doubles.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C","~$clojure.test.check.random.longs"]]],["^1>","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2M","^2P"]]],["^1>","clojure/test/check/rose_tree.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C"]]],["^1>","clojure/test/check/impl.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C"]]],["^1>","clojure/test/check/random.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C","~$clojure.test.check.random.doubles","^2Y"]]],["^1>","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O"]]],"~:SHADOW-TIMESTAMP",[1689947046000,1689947046000,1689947050000],["^1>","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O","~$goog.reflect"]]],["^1>","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O","~$goog.fs.blob","^2S","~$goog.html.SafeScript","~$goog.html.trustedtypes","^2U","^2V"]]],["^1>","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","clojure/test/check.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C","^W","^Z","^R","^T","^V"]]],["^1>","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2U","~$goog.html.SafeUrl","^2V","^2O","^2P"]]],["^1>","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^32","~$goog.html.SafeStyle","^34","^2T","~$goog.html.uncheckedconversions","^2U","^2P"]]],["^1>","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","~$goog.dom.TagName","^2O","~$goog.dom.element"]]],["^1>","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2U","^32","^39","~$goog.html.SafeStyleSheet","^34","^3;","^2T","^2V","^2O","~$goog.labs.userAgent.browser","~$goog.array","~$goog.object","^2P","~$goog.dom.tags","^33"]]],["^1>","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^3@"]]],["^1>","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1>","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^3?","^2O","~$goog.collections.maps","^2X","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1>","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2N"]]],["^1>","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",[]]],["^1>","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^3?","^3@"]]],["^1>","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C","^2X","~$goog.string.StringBuffer"]]],["^1>","clojure/test/check/random/longs/bit_count_impl.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C"]]],["^1>","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","~$goog.dom.safe","^3:","^2U","^2P"]]],["^1>","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2P","^2R"]]],["^1>","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","~$goog.flags"]]],["^1>","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^3C","^3;"]]],["^1>","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O","^38","^32","^39","^3=","^34","^2T","^2U","^2P"]]],["^1>","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X"]]],["^1>","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","~$goog.math.Long","~$goog.math.Integer","^2X","^3@","^3?","~$goog.Uri","^3I"]]],["^1>","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2U","^2V","^33","^2O"]]],["^1>","clojure/test/check/random/longs.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C","~$clojure.test.check.random.longs.bit-count-impl","^3L","^C"]]],["^1>","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2U","^39","^2V","^3@","^2O","^2P"]]],["^1>","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^30"]]],["^1>","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O","^2X"]]],["^1>","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^2O","^2V"]]],["^1>","clojure/test/check/results.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^2H",["^ ","^2I",null,"^2J",["^J",[]],"^2K",["^X","^C"]]]]],"~:clj-info",["^ ","jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/random.clj",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/generators.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1689947050000,"jar:file:/root/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1689947054000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/rose_tree.cljc",1689946177000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/test/check.cljc","^7",10,"^8",5,"^9",10,"^:",23],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G"],"^H",null,"^I",["^J",[]],"^K","^L","^M",["^ "],"^P",null,"^Q",["^ ","^R","^R","^S","^T","^U","^R","^V","^V","^T","^T","^C","^C","^W","^W","^X","^X","^Y","^W","^Z","^Z","^[","^Z"],"^10",["^J",["^11"]],"~:shadow/js-access-global",["^J",["Error"]],"^12",["^ ","^13","^V"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",242,"^8",8,"^9",242,"^:",19,"~:private",true,"~:arglists",["^16",["~$quote",["^16",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^4K",true,"^K","^1Z","^6","clojure/test/check.cljc","^:",19,"~:method-params",["^16",[["^4N","^4O"]]],"~:protocol-impl",null,"~:arglists-meta",["^16",[null,null]],"^8",1,"~:variadic?",false,"^7",242,"~:ret-tag","~$cljs.core/IMap","^9",242,"~:max-fixed-arity",2,"~:fn-var",true,"^4L",["^16",["^4M",["^16",[["^4N","^4O"]]]]],"^4P","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^4J",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",297,"^8",8,"^9",297,"^:",15,"^4K",true,"^4L",["^16",["^4M",["^16",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","~$start-time","^4O"]]]]]],"^4K",true,"^K","^27","^6","clojure/test/check.cljc","^:",15,"^4Q",["^16",[["^4Z","^4[","^50","^51","^52","^53","^4O"]]],"^4R",null,"^4S",["^16",[null,null]],"^8",1,"^4T",false,"^7",297,"^4U",["^J",["~$clj","~$any"]],"^9",297,"^4W",7,"^4X",true,"^4L",["^16",["^4M",["^16",[["^4Z","^4[","^50","^51","^52","^53","^4O"]]]]]],"~$make-rng",["^ ","^4J",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",19,"^8",8,"^9",19,"^:",16,"^4K",true,"^4L",["^16",["^4M",["^16",[["^52"]]]]]],"^4K",true,"^K","^1W","^6","clojure/test/check.cljc","^:",16,"^4Q",["^16",[["^52"]]],"^4R",null,"^4S",["^16",[null,null]],"^8",1,"^4T",false,"^7",19,"^4U","~$cljs.core/IVector","^9",19,"^4W",1,"^4X",true,"^4L",["^16",["^4M",["^16",[["^52"]]]]]],"~$complete",["^ ","^4J",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",26,"^8",8,"^9",26,"^:",16,"^4K",true,"^4L",["^16",["^4M",["^16",[["^4Z","~$num-trials","^52","^53","^4O"]]]]]],"^4K",true,"^K","^1Y","^6","clojure/test/check.cljc","^:",16,"^4Q",["^16",[["^4Z","^59","^52","^53","^4O"]]],"^4R",null,"^4S",["^16",[null,null]],"^8",1,"^4T",false,"^7",26,"^4U","^4V","^9",26,"^4W",5,"^4X",true,"^4L",["^16",["^4M",["^16",[["^4Z","^59","^52","^53","^4O"]]]]]],"~$legacy-result",["^ ","^4J",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",43,"^8",17,"^9",43,"^:",30,"^4K",true,"^4L",["^16",["^4M",["^16",[["~$result"]]]]],"^4P","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"^4K",true,"^K","^23","^6","clojure/test/check.cljc","^:",30,"^4Q",["^16",[["^5;"]]],"^4R",null,"^4S",["^16",[null,null]],"^8",1,"^4T",false,"^7",43,"^4U",["^J",[null,"^55","~$cljs.core/ExceptionInfo","~$clj-nil"]],"^9",43,"^4W",1,"^4X",true,"^4L",["^16",["^4M",["^16",[["^5;"]]]]],"^4P","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"~$quick-check",["^ ","^4J",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",59,"^8",7,"^9",59,"^:",18,"^4L",["^16",["^4M",["^16",[["~$num-tests","^4Z","~$&",["^ ","~:keys",["^52","~$max-size","^4O"],"~:or",["^ ","^5A",200,"^4O",["^16",["~$constantly",null]]]]]]]]],"^4P","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:top-fn",["^ ","^4T",true,"~:fixed-arity",2,"^4W",2,"^4Q",[["^16",["^5?","^4Z",["^ ","^5@",["^52","^5A","^4O"],"^5B",["^ ","^5A",200,"^4O",["^16",["^5C",null]]]]]]],"^4L",["^16",[["^5?","^4Z","~$&",["^ ","^5@",["^52","^5A","^4O"],"^5B",["^ ","^5A",200,"^4O",["^16",["^5C",null]]]]]]],"^4S",["^16",[null]]]],"^K","^1S","^6","clojure/test/check.cljc","^:",18,"^5D",["^ ","^4T",true,"^5E",2,"^4W",2,"^4Q",[["^16",["^5?","^4Z",["^ ","^5@",["^52","^5A","^4O"],"^5B",["^ ","^5A",200,"^4O",["^16",["^5C",null]]]]]]],"^4L",["^16",[["^5?","^4Z","~$&",["^ ","^5@",["^52","^5A","^4O"],"^5B",["^ ","^5A",200,"^4O",["^16",["^5C",null]]]]]]],"^4S",["^16",[null]]],"^4Q",[["^16",["^5?","^4Z",["^ ","^5@",["^52","^5A","^4O"],"^5B",["^ ","^5A",200,"^4O",["^16",["^5C",null]]]]]]],"^4R",null,"^5E",2,"^4S",["^16",[null]],"^8",1,"^4T",true,"~:methods",[["^ ","^5E",2,"^4T",true,"~:tag",["^J",["^55","^4V"]]]],"^7",59,"^4U","^55","^9",59,"^4W",2,"^4X",true,"^4L",["^16",[["^5?","^4Z","~$&",["^ ","^5@",["^52","^5A","^4O"],"^5B",["^ ","^5A",200,"^4O",["^16",["^5C",null]]]]]]],"^4P","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))"],"~$smallest-shrink",["^ ","^4J",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",231,"^8",8,"^9",231,"^:",23,"^4K",true,"^4L",["^16",["^4M",["^16",[["~$total-nodes-visited","~$depth","~$smallest","^53"]]]]]],"^4K",true,"^K","^1Q","^6","clojure/test/check.cljc","^:",23,"^4Q",["^16",[["^5I","^5J","^5K","^53"]]],"^4R",null,"^4S",["^16",[null,null]],"^8",1,"^4T",false,"^7",231,"^4U","^4V","^9",231,"^4W",4,"^4X",true,"^4L",["^16",["^4M",["^16",[["^5I","^5J","^5K","^53"]]]]]]],"^14",["^ ","^C","^C","^W","^W","^Y","^W"],"~:cljs.analyzer/constants",["^ ","^10",["^J",["~:args","~:clojure.test.check.properties/error","~:shrunk","~:failed-after-ms","~:total-nodes-visited","~:num-tests-total","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:fail","~:result","~:result-data","~:smallest","~:trial","~:time-shrinking-ms","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:shrinking","~:time-elapsed-ms"]],"~:order",["^5W","^5T","^5[","^66","^5V","^6:","^5Y","^68","^5N","^5X","^65","^5M","^5R","^60","^62","^5Q","^67","^63","^61","^69","^5U","^5P","^5Z","^64","^5S","^5O"]],"^1:",["^ ","^11",["^J",[]]],"^1;",["^ "],"^1<",["^X","^C","^W","^Z","^R","^T","^V"]],"^O","^L","~:ns-specs",["^ "],"~:ns-spec-vars",["^J",[]],"~:compiler-options",["^2G",[["^6>","~:static-fns"],true,["^6>","~:shadow-tweaks"],null,["^6>","~:source-map-inline"],null,["^6>","~:elide-asserts"],false,["^6>","~:optimize-constants"],null,["^6>","^1A"],null,["^6>","~:external-config"],null,["^6>","~:tooling-config"],null,["^6>","~:emit-constants"],null,["^6>","~:load-tests"],null,["^6>","~:form-size-threshold"],null,["^6>","~:global-goog-object&array"],null,["^6>","~:data-readers"],null,["^6>","~:infer-externs"],"~:auto",["^6>","^1C"],["^J",["^1D","^1E"]],["~:js-options","~:js-provider"],"^11",["~:mode"],"~:dev",["^6>","~:fn-invoke-direct"],null,["^6>","~:source-map"],"/dev/null"]]]