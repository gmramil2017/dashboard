["^ ","~:output",["^ ","~:js","goog.provide('metabase.lib.util');\n/**\n * Exactly like [[clojure.core/format]] but ClojureScript-friendly.\n */\nmetabase.lib.util.format = goog.string.format;\n/**\n * Returns true if this is a clause.\n */\nmetabase.lib.util.clause_QMARK_ = (function metabase$lib$util$clause_QMARK_(clause){\nreturn ((cljs.core.vector_QMARK_(clause)) && ((((cljs.core.count(clause) > (1))) && ((((cljs.core.first(clause) instanceof cljs.core.Keyword)) && (((cljs.core.map_QMARK_(cljs.core.second(clause))) && (cljs.core.contains_QMARK_(cljs.core.second(clause),new cljs.core.Keyword(\"lib\",\"uuid\",\"lib/uuid\",-2145250720))))))))));\n});\n/**\n * Returns true if this is a clause.\n */\nmetabase.lib.util.clause_of_type_QMARK_ = (function metabase$lib$util$clause_of_type_QMARK_(clause,clause_type){\nreturn ((metabase.lib.util.clause_QMARK_(clause)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(clause),clause_type)));\n});\n/**\n * Returns true if this is a field clause.\n */\nmetabase.lib.util.field_clause_QMARK_ = (function metabase$lib$util$field_clause_QMARK_(clause){\nreturn metabase.lib.util.clause_of_type_QMARK_(clause,new cljs.core.Keyword(null,\"field\",\"field\",-1302436500));\n});\n/**\n * Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause.\n */\nmetabase.lib.util.expression_name = (function metabase$lib$util$expression_name(clause){\nif(metabase.lib.util.clause_QMARK_(clause)){\nreturn cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(clause,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),new cljs.core.Keyword(\"lib\",\"expression-name\",\"lib/expression-name\",-1799326590)], null));\n} else {\nreturn null;\n}\n});\n/**\n * Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value.\n */\nmetabase.lib.util.named_expression_clause = (function metabase$lib$util$named_expression_clause(clause,a_name){\nreturn cljs.core.assoc_in(((metabase.lib.util.clause_QMARK_(clause))?clause:new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"value\",\"value\",305978217),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"uuid\",\"lib/uuid\",-2145250720),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.random_uuid()),new cljs.core.Keyword(null,\"effective-type\",\"effective-type\",-355725458),metabase.lib.schema.expression.type_of(clause)], null),clause], null)),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(1),new cljs.core.Keyword(\"lib\",\"expression-name\",\"lib/expression-name\",-1799326590)], null),a_name);\n});\n/**\n * Replace the `target-clause` in `stage` `location` with `new-clause`.\n * If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n * If `location` contains no clause with `target-clause` no replacement happens.\n */\nmetabase.lib.util.replace_clause = (function metabase$lib$util$replace_clause(stage,location,target_clause,new_clause){\n\nvar new_clause__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"expressions\",\"expressions\",255689909),cljs.core.first(location)))?metabase.lib.util.named_expression_clause(new_clause,metabase.lib.util.expression_name(target_clause)):new_clause);\nreturn medley.core.update_existing_in(stage,location,(function (clause_or_clauses){\nreturn cljs.core.vec((function (){var iter__5523__auto__ = (function metabase$lib$util$replace_clause_$_iter__48390(s__48391){\nreturn (new cljs.core.LazySeq(null,(function (){\nvar s__48391__$1 = s__48391;\nwhile(true){\nvar temp__5804__auto__ = cljs.core.seq(s__48391__$1);\nif(temp__5804__auto__){\nvar s__48391__$2 = temp__5804__auto__;\nif(cljs.core.chunked_seq_QMARK_(s__48391__$2)){\nvar c__5521__auto__ = cljs.core.chunk_first(s__48391__$2);\nvar size__5522__auto__ = cljs.core.count(c__5521__auto__);\nvar b__48393 = cljs.core.chunk_buffer(size__5522__auto__);\nif((function (){var i__48392 = (0);\nwhile(true){\nif((i__48392 < size__5522__auto__)){\nvar clause = cljs.core._nth(c__5521__auto__,i__48392);\ncljs.core.chunk_append(b__48393,((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(metabase.lib.options.uuid(clause),metabase.lib.options.uuid(target_clause)))?new_clause__$1:clause));\n\nvar G__48526 = (i__48392 + (1));\ni__48392 = G__48526;\ncontinue;\n} else {\nreturn true;\n}\nbreak;\n}\n})()){\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__48393),metabase$lib$util$replace_clause_$_iter__48390(cljs.core.chunk_rest(s__48391__$2)));\n} else {\nreturn cljs.core.chunk_cons(cljs.core.chunk(b__48393),null);\n}\n} else {\nvar clause = cljs.core.first(s__48391__$2);\nreturn cljs.core.cons(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(metabase.lib.options.uuid(clause),metabase.lib.options.uuid(target_clause)))?new_clause__$1:clause),metabase$lib$util$replace_clause_$_iter__48390(cljs.core.rest(s__48391__$2)));\n}\n} else {\nreturn null;\n}\nbreak;\n}\n}),null,null));\n});\nreturn iter__5523__auto__(clause_or_clauses);\n})());\n}));\n});\n/**\n * Remove the `target-clause` in `stage` `location`.\n * If a clause has :lib/uuid equal to the `target-clause` it is removed.\n * If `location` contains no clause with `target-clause` no removal happens.\n * If the the location is empty, dissoc it from stage.\n * For the [:fields] location if only expressions remain, dissoc from stage.\n */\nmetabase.lib.util.remove_clause = (function metabase$lib$util$remove_clause(stage,location,target_clause){\n\nvar temp__5802__auto__ = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(stage,location);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar target = temp__5802__auto__;\nvar target_uuid = metabase.lib.options.uuid(target_clause);\nvar vec__48398 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(location),cljs.core.last(location)], null);\nvar first_loc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__48398,(0),null);\nvar last_loc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__48398,(1),null);\nvar result = cljs.core.into.cljs$core$IFn$_invoke$arity$3(cljs.core.PersistentVector.EMPTY,cljs.core.remove.cljs$core$IFn$_invoke$arity$1(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentHashSet.createAsIfByAssoc([target_uuid]),metabase.lib.options.uuid)),target);\nvar result__$1 = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(location,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230)], null))) && (cljs.core.every_QMARK_((function (p1__48397_SHARP_){\nreturn metabase.lib.util.clause_of_type_QMARK_(p1__48397_SHARP_,new cljs.core.Keyword(null,\"expression\",\"expression\",202311876));\n}),result))))?null:result);\nif(cljs.core.seq(result__$1)){\nreturn cljs.core.assoc_in(stage,location,result__$1);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [first_loc,last_loc], null))){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(metabase.shared.util.i18n.js_i18n(\"Cannot remove the final join condition\"),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270),cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(stage,location)], null));\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230)], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [first_loc,last_loc], null))){\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$4(stage,cljs.core.pop(location),cljs.core.dissoc,last_loc);\n} else {\nreturn medley.core.dissoc_in.cljs$core$IFn$_invoke$arity$2(stage,location);\n\n}\n}\n}\n} else {\nreturn stage;\n}\n});\n/**\n * Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n *   explanation of what this means.\n */\nmetabase.lib.util.native_query__GT_pipeline = (function metabase$lib$util$native_query__GT_pipeline(query){\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql.stage\",\"native\",\"mbql.stage/native\",359422194)], null),clojure.set.rename_keys(new cljs.core.Keyword(null,\"native\",\"native\",-613060878).cljs$core$IFn$_invoke$arity$1(query),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"query\",\"query\",-1288509510),new cljs.core.Keyword(null,\"native\",\"native\",-613060878)], null))], 0))], null)], null),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(query,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"native\",\"native\",-613060878)], 0))], 0));\n});\n/**\n * Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`\n */\nmetabase.lib.util.update_legacy_boolean_expression__GT_list = (function metabase$lib$util$update_legacy_boolean_expression__GT_list(m,legacy_key,pMBQL_key){\nvar G__48402 = m;\nvar G__48402__$1 = ((cljs.core.contains_QMARK_(m,legacy_key))?cljs.core.update.cljs$core$IFn$_invoke$arity$3(G__48402,legacy_key,(function (p1__48401_SHARP_){\nif(((cljs.core.vector_QMARK_(p1__48401_SHARP_)) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.first(p1__48401_SHARP_),new cljs.core.Keyword(null,\"and\",\"and\",-971899817))))){\nreturn cljs.core.vec(cljs.core.drop.cljs$core$IFn$_invoke$arity$2((1),p1__48401_SHARP_));\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [p1__48401_SHARP_], null);\n}\n})):G__48402);\nif(cljs.core.contains_QMARK_(m,legacy_key)){\nreturn clojure.set.rename_keys(G__48402__$1,cljs.core.PersistentArrayMap.createAsIfByAssoc([legacy_key,pMBQL_key]));\n} else {\nreturn G__48402__$1;\n}\n});\nmetabase.lib.util.join__GT_pipeline = (function metabase$lib$util$join__GT_pipeline(join){\nvar source = cljs.core.select_keys(join,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692),new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422)], null));\nvar stages = (metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1 ? metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1(source) : metabase.lib.util.inner_query__GT_stages.call(null,source));\nreturn metabase.lib.options.ensure_uuid(cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic(metabase.lib.util.update_legacy_boolean_expression__GT_list(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(join,new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422)], 0)),new cljs.core.Keyword(null,\"condition\",\"condition\",1668437652),new cljs.core.Keyword(null,\"conditions\",\"conditions\",-1647236270)),new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"join\",\"mbql/join\",-709512370),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),stages], 0)));\n});\nmetabase.lib.util.joins__GT_pipeline = (function metabase$lib$util$joins__GT_pipeline(joins){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(metabase.lib.util.join__GT_pipeline,joins);\n});\n/**\n * Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]].\n */\nmetabase.lib.util.__GT_stage_metadata = (function metabase$lib$util$__GT_stage_metadata(source_metadata){\nif(cljs.core.truth_(source_metadata)){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.update.cljs$core$IFn$_invoke$arity$3(((cljs.core.seqable_QMARK_(source_metadata))?new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"columns\",\"columns\",1998437288),source_metadata], null):source_metadata),new cljs.core.Keyword(null,\"columns\",\"columns\",1998437288),(function (columns){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (column){\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.update_keys(column,metabase.util.__GT_kebab_case_en),new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"metadata\",\"column\",\"metadata/column\",-1799249054));\n}),columns);\n})),new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"metadata\",\"results\",\"metadata/results\",330329298));\n} else {\nreturn null;\n}\n});\nmetabase.lib.util.inner_query__GT_stages = (function metabase$lib$util$inner_query__GT_stages(p__48403){\nvar map__48404 = p__48403;\nvar map__48404__$1 = cljs.core.__destructure_map(map__48404);\nvar inner_query = map__48404__$1;\nvar source_query = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__48404__$1,new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422));\nvar source_metadata = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__48404__$1,new cljs.core.Keyword(null,\"source-metadata\",\"source-metadata\",-477816085));\nvar previous_stages = (cljs.core.truth_(source_query)?(metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1 ? metabase.lib.util.inner_query__GT_stages.cljs$core$IFn$_invoke$arity$1(source_query) : metabase.lib.util.inner_query__GT_stages.call(null,source_query)):cljs.core.PersistentVector.EMPTY);\nvar source_metadata__$1 = metabase.lib.util.__GT_stage_metadata(source_metadata);\nvar previous_stage = (cljs.core.count(previous_stages) - (1));\nvar previous_stages__$1 = (function (){var G__48405 = previous_stages;\nif(cljs.core.truth_((function (){var and__5043__auto__ = source_metadata__$1;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn (!((previous_stage < (0))));\n} else {\nreturn and__5043__auto__;\n}\n})())){\nreturn cljs.core.assoc_in(G__48405,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [previous_stage,new cljs.core.Keyword(\"lib\",\"stage-metadata\",\"lib/stage-metadata\",1079153610)], null),source_metadata__$1);\n} else {\nreturn G__48405;\n}\n})();\nvar stage_type = (cljs.core.truth_(new cljs.core.Keyword(null,\"native\",\"native\",-613060878).cljs$core$IFn$_invoke$arity$1(inner_query))?new cljs.core.Keyword(\"mbql.stage\",\"native\",\"mbql.stage/native\",359422194):new cljs.core.Keyword(\"mbql.stage\",\"mbql\",\"mbql.stage/mbql\",1578747798));\nvar this_stage = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),stage_type], null),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(inner_query,new cljs.core.Keyword(null,\"source-query\",\"source-query\",198004422),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"source-metadata\",\"source-metadata\",-477816085)], 0))], 0));\nvar this_stage__$1 = (function (){var G__48406 = this_stage;\nvar G__48406__$1 = ((cljs.core.seq(new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699).cljs$core$IFn$_invoke$arity$1(this_stage)))?cljs.core.update.cljs$core$IFn$_invoke$arity$3(G__48406,new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),metabase.lib.util.joins__GT_pipeline):G__48406);\nreturn metabase.lib.util.update_legacy_boolean_expression__GT_list(G__48406__$1,new cljs.core.Keyword(null,\"filter\",\"filter\",-948537934),new cljs.core.Keyword(null,\"filters\",\"filters\",974726919));\n\n})();\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(previous_stages__$1,this_stage__$1);\n});\n/**\n * Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n *   pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n *   and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n *   Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n *   all of MLv2 deals with pMBQL. See this Slack thread\n *   https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n *   more information.\n */\nmetabase.lib.util.mbql_query__GT_pipeline = (function metabase$lib$util$mbql_query__GT_pipeline(query){\nreturn cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),metabase.lib.util.inner_query__GT_stages(new cljs.core.Keyword(null,\"query\",\"query\",-1288509510).cljs$core$IFn$_invoke$arity$1(query))], null),cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(query,new cljs.core.Keyword(null,\"type\",\"type\",1174270348),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"query\",\"query\",-1288509510)], 0))], 0));\n});\n/**\n * Schema for a map that is either a legacy query OR a pMBQL query.\n */\nmetabase.lib.util.LegacyOrPMBQLQuery = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"or\",\"or\",235744169),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"map\",\"map\",1371690461),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"error\",\"message\",\"error/message\",-502809098),\"legacy query\"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"enum\",\"enum\",1679018432),new cljs.core.Keyword(null,\"native\",\"native\",-613060878),new cljs.core.Keyword(null,\"query\",\"query\",-1288509510)], null)], null)], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"map\",\"map\",1371690461),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"error\",\"message\",\"error/message\",-502809098),\"pMBQL query\"], null),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"=\",\"=\",1152933628),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662)], null)], null)], null)], null);\n/**\n * Inputs: [query :- LegacyOrPMBQLQuery]\n *   Return: :any\n *        \n * \n *   Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n *   goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n *   functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n *   process.)\n */\nmetabase.lib.util.pipeline = (function metabase$lib$util$pipeline(query){\n\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801).cljs$core$IFn$_invoke$arity$1(query),new cljs.core.Keyword(\"mbql\",\"query\",\"mbql/query\",-1285688662))){\nreturn query;\n} else {\nvar G__48420 = new cljs.core.Keyword(null,\"type\",\"type\",1174270348).cljs$core$IFn$_invoke$arity$1(query);\nvar G__48420__$1 = (((G__48420 instanceof cljs.core.Keyword))?G__48420.fqn:null);\nswitch (G__48420__$1) {\ncase \"native\":\nreturn metabase.lib.util.native_query__GT_pipeline(query);\n\nbreak;\ncase \"query\":\nreturn metabase.lib.util.mbql_query__GT_pipeline(query);\n\nbreak;\ndefault:\nthrow (new Error([\"No matching clause: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(G__48420__$1)].join('')));\n\n}\n}\n});\n/**\n * Inputs: [{:keys [stages], :as _query} :- :map stage-number :- :int]\n *   Return: [:int {:min 0}]\n *        \n * \n *   If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n *   `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc.\n */\nmetabase.lib.util.canonical_stage_index = (function metabase$lib$util$canonical_stage_index(p__48422,stage_number){\nvar map__48423 = p__48422;\nvar map__48423__$1 = cljs.core.__destructure_map(map__48423);\nvar _query = map__48423__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__48423__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\n\nvar stage_number_SINGLEQUOTE_ = (((stage_number < (0)))?(cljs.core.count(stages) + stage_number):stage_number);\nif((((stage_number_SINGLEQUOTE_ >= cljs.core.count(stages))) || ((stage_number_SINGLEQUOTE_ < (0))))){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(metabase.shared.util.i18n.js_i18n.cljs$core$IFn$_invoke$arity$variadic(\"Stage {0} does not exist\",cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([stage_number], 0)),new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"num-stages\",\"num-stages\",1426797535),cljs.core.count(stages)], null));\n} else {\n}\n\nreturn stage_number_SINGLEQUOTE_;\n});\n/**\n * Inputs: [query :- :map stage-number :- :int]\n *   Return: [:maybe [:int {:min 0}]]\n *        \n * \n *   The index of the previous stage, if there is one. `nil` if there is no previous stage.\n */\nmetabase.lib.util.previous_stage_number = (function metabase$lib$util$previous_stage_number(query,stage_number){\n\nvar stage_number__$1 = metabase.lib.util.canonical_stage_index(query,stage_number);\nif((stage_number__$1 > (0))){\nreturn (stage_number__$1 - (1));\n} else {\nreturn null;\n}\n});\n/**\n * Whether a `stage-number` is referring to the first stage of a query or not.\n */\nmetabase.lib.util.first_stage_QMARK_ = (function metabase$lib$util$first_stage_QMARK_(query,stage_number){\nreturn cljs.core.not(metabase.lib.util.previous_stage_number(query,stage_number));\n});\n/**\n * The index of the next stage, if there is one. `nil` if there is no next stage.\n */\nmetabase.lib.util.next_stage_number = (function metabase$lib$util$next_stage_number(p__48425,stage_number){\nvar map__48426 = p__48425;\nvar map__48426__$1 = cljs.core.__destructure_map(map__48426);\nvar _query = map__48426__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__48426__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nvar stage_number__$1 = (((stage_number < (0)))?(cljs.core.count(stages) + stage_number):stage_number);\nif(((stage_number__$1 + (1)) < cljs.core.count(stages))){\nreturn (stage_number__$1 + (1));\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int]\n *   Return: :metabase.lib.schema/stage\n *        \n * \n *   Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n *   the query.\n */\nmetabase.lib.util.query_stage = (function metabase$lib$util$query_stage(query,stage_number){\n\nvar map__48428 = metabase.lib.util.pipeline(query);\nvar map__48428__$1 = cljs.core.__destructure_map(map__48428);\nvar query__$1 = map__48428__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__48428__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(stages),metabase.lib.util.canonical_stage_index(query__$1,stage_number));\n});\n/**\n * Inputs: [query stage-number :- :int]\n *   Return: [:maybe :metabase.lib.schema/stage]\n *        \n * \n *   Return the previous stage of the query, if there is one; otherwise return `nil`.\n */\nmetabase.lib.util.previous_stage = (function metabase$lib$util$previous_stage(query,stage_number){\n\nvar temp__5804__auto__ = metabase.lib.util.previous_stage_number(query,stage_number);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar stage_num = temp__5804__auto__;\nreturn metabase.lib.util.query_stage(query,stage_num);\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int f & args]\n *   Return: :metabase.lib.schema/query\n *        \n * \n *   Update a specific `stage-number` of a `query` by doing\n * \n *  (apply f stage args)\n * \n *   `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query.\n */\nmetabase.lib.util.update_query_stage = (function metabase$lib$util$update_query_stage(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___48539 = arguments.length;\nvar i__5770__auto___48540 = (0);\nwhile(true){\nif((i__5770__auto___48540 < len__5769__auto___48539)){\nargs__5775__auto__.push((arguments[i__5770__auto___48540]));\n\nvar G__48541 = (i__5770__auto___48540 + (1));\ni__5770__auto___48540 = G__48541;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((3) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((3)),(0),null)):null);\nreturn metabase.lib.util.update_query_stage.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),argseq__5776__auto__);\n});\n\n(metabase.lib.util.update_query_stage.cljs$core$IFn$_invoke$arity$variadic = (function (query,stage_number,f,args){\n\nvar map__48437 = metabase.lib.util.pipeline(query);\nvar map__48437__$1 = cljs.core.__destructure_map(map__48437);\nvar query__$1 = map__48437__$1;\nvar stages = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__48437__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532));\nvar stage_number_SINGLEQUOTE_ = metabase.lib.util.canonical_stage_index(query__$1,stage_number);\nvar stages_SINGLEQUOTE_ = cljs.core.apply.cljs$core$IFn$_invoke$arity$5(cljs.core.update,cljs.core.vec(stages),stage_number_SINGLEQUOTE_,f,args);\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(query__$1,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),stages_SINGLEQUOTE_);\n}));\n\n(metabase.lib.util.update_query_stage.cljs$lang$maxFixedArity = (3));\n\n/** @this {Function} */\n(metabase.lib.util.update_query_stage.cljs$lang$applyTo = (function (seq48433){\nvar G__48434 = cljs.core.first(seq48433);\nvar seq48433__$1 = cljs.core.next(seq48433);\nvar G__48435 = cljs.core.first(seq48433__$1);\nvar seq48433__$2 = cljs.core.next(seq48433__$1);\nvar G__48436 = cljs.core.first(seq48433__$2);\nvar seq48433__$3 = cljs.core.next(seq48433__$2);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__48434,G__48435,G__48436,seq48433__$3);\n}));\n\n/**\n * Inputs: [query]\n *   Return: :metabase.lib.schema/query\n *        \n * \n *   Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one.\n */\nmetabase.lib.util.ensure_mbql_final_stage = (function metabase$lib$util$ensure_mbql_final_stage(query){\n\nvar query__$1 = metabase.lib.util.pipeline(query);\nvar G__48439 = query__$1;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801).cljs$core$IFn$_invoke$arity$1(metabase.lib.util.query_stage(query__$1,(-1))),new cljs.core.Keyword(\"mbql.stage\",\"native\",\"mbql.stage/native\",359422194))){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$4(G__48439,new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),cljs.core.conj,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"lib\",\"type\",\"lib/type\",1175424801),new cljs.core.Keyword(\"mbql.stage\",\"mbql\",\"mbql.stage/mbql\",1578747798)], null));\n} else {\nreturn G__48439;\n}\n});\n/**\n * This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n *   by a string `conjunction`. Uses Oxford commas for > 2 args.\n * \n *   (join-strings-with-conjunction \"and\" [\"X\" \"Y\" \"Z\"])\n *   ;; => \"X, Y, and Z\"\n */\nmetabase.lib.util.join_strings_with_conjunction = (function metabase$lib$util$join_strings_with_conjunction(conjunction,coll){\nif(cljs.core.seq(coll)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(coll),(1))){\nreturn cljs.core.first(coll);\n} else {\nvar conjunction__$1 = [\" \",clojure.string.trim(conjunction),\" \"].join('');\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(coll),(2))){\nreturn [cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(coll)),conjunction__$1,cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.second(coll))].join('');\n} else {\nreturn [clojure.string.join.cljs$core$IFn$_invoke$arity$2(\", \",cljs.core.butlast(coll)),\",\",conjunction__$1,cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.last(coll))].join('');\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [s :- :string]\n *   Return: [:int {:min 0}]\n *        \n * \n *   Number of bytes in a string using UTF-8 encoding.\n */\nmetabase.lib.util.string_byte_count = (function metabase$lib$util$string_byte_count(s){\n\nreturn (new TextEncoder()).encode(s).length;\n});\n/**\n * Inputs: [s :- :string max-length-bytes :- [:int {:min 1}]]\n *   Return: :string\n *        \n * \n *   Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n *   *characters*).\n */\nmetabase.lib.util.truncate_string_to_byte_count = (function metabase$lib$util$truncate_string_to_byte_count(s,max_length_bytes){\n\nvar buf = (new Uint8Array(max_length_bytes));\nvar result = (new TextEncoder()).encodeInto(s,buf);\nreturn cljs.core.subs.cljs$core$IFn$_invoke$arity$3(s,(0),result.read);\n});\n/**\n * Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n *   reasoning.\n */\nmetabase.lib.util.truncate_alias_max_length_bytes = (60);\n/**\n * Length of the hash suffixed to truncated strings by [[truncate-alias]].\n */\nmetabase.lib.util.truncated_alias_hash_suffix_length = (9);\n/**\n * Inputs: [s :- :string]\n *   Return: [:string {:min 8, :max 8}]\n *        \n * \n *   Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string.\n */\nmetabase.lib.util.crc32_checksum = (function metabase$lib$util$crc32_checksum(s){\n\nvar s__$1 = (shadow.js.shim.module$crc_32.str(s,(0)) >>> (0)).toString((16));\nvar s__$2 = s__$1;\nwhile(true){\nif((cljs.core.count(s__$2) < (8))){\nvar G__48543 = [\"0\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(s__$2)].join('');\ns__$2 = G__48543;\ncontinue;\n} else {\nreturn s__$2;\n}\nbreak;\n}\n});\n/**\n * Inputs: ([s]\n *         [s :- :metabase.lib.schema.common/non-blank-string max-bytes :- [:int {:min 0}]])\n *   Return: [:string {:min 1, :max 60}]\n *        \n * \n *   Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n *   checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n *   minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n *   exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n *   end will still have different resulting values.\n * \n *  (truncate-alias \"some_really_long_string\" 15) ;   -> \"some_r_8e0f9bc2\"\n *  (truncate-alias \"some_really_long_string_2\" 15) ; -> \"some_r_2a3c73eb\"\n */\nmetabase.lib.util.truncate_alias = (function metabase$lib$util$truncate_alias(var_args){\nvar G__48482 = arguments.length;\nswitch (G__48482) {\ncase 1:\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$1 = (function (s){\n\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$2(s,metabase.lib.util.truncate_alias_max_length_bytes);\n}));\n\n(metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$2 = (function (s,max_bytes){\n\nif((metabase.lib.util.string_byte_count(s) <= max_bytes)){\nreturn s;\n} else {\nvar checksum = metabase.lib.util.crc32_checksum(s);\nvar truncated = metabase.lib.util.truncate_string_to_byte_count(s,(max_bytes - metabase.lib.util.truncated_alias_hash_suffix_length));\nreturn [truncated,\"_\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(checksum)].join('');\n}\n}));\n\n(metabase.lib.util.truncate_alias.cljs$lang$maxFixedArity = 2);\n\n/**\n * Inputs: [table-id]\n *   Return: [:maybe :metabase.lib.schema.id/card]\n *        \n * \n *   If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n *   queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n *   `:source-card`.\n */\nmetabase.lib.util.legacy_string_table_id__GT_card_id = (function metabase$lib$util$legacy_string_table_id__GT_card_id(table_id){\n\nif(typeof table_id === 'string'){\nvar temp__5804__auto__ = cljs.core.re_find(/^card__(\\d+)$/,table_id);\nif(cljs.core.truth_(temp__5804__auto__)){\nvar vec__48497 = temp__5804__auto__;\nvar _match = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__48497,(0),null);\nvar card_id_str = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__48497,(1),null);\nreturn cljs.core.parse_long(card_id_str);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Inputs: [query]\n *   Return: [:maybe :metabase.lib.schema.id/table]\n *        \n * \n *   If this query has a `:source-table` ID, return it.\n */\nmetabase.lib.util.source_table_id = (function metabase$lib$util$source_table_id(query){\n\nreturn new cljs.core.Keyword(null,\"source-table\",\"source-table\",-225307692).cljs$core$IFn$_invoke$arity$1(cljs.core.first(new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532).cljs$core$IFn$_invoke$arity$1(query)));\n});\n/**\n * Inputs: [query]\n *   Return: [:maybe :metabase.lib.schema.id/card]\n *        \n * \n *   If this query has a `:source-card` ID, return it.\n */\nmetabase.lib.util.source_card_id = (function metabase$lib$util$source_card_id(query){\n\nreturn new cljs.core.Keyword(null,\"source-card\",\"source-card\",-1580820390).cljs$core$IFn$_invoke$arity$1(cljs.core.first(new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532).cljs$core$IFn$_invoke$arity$1(query)));\n});\n/**\n * Inputs: []\n *   Return: [:=> [:cat :metabase.lib.schema.common/non-blank-string] :metabase.lib.schema.common/non-blank-string]\n *        \n * \n *   Create a new function with the signature\n * \n *  (f str) => str\n * \n *   That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n *   name truncated to 60 characters (actually 51 characters plus a hash).\n */\nmetabase.lib.util.unique_name_generator = (function metabase$lib$util$unique_name_generator(){\n\nreturn cljs.core.comp.cljs$core$IFn$_invoke$arity$2(metabase.lib.util.truncate_alias,metabase.mbql.util.unique_name_generator.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"name-key-fn\",\"name-key-fn\",-1634839199),metabase.util.lower_case_en,new cljs.core.Keyword(null,\"unique-alias-fn\",\"unique-alias-fn\",32555420),(function (original,suffix){\nreturn metabase.lib.util.truncate_alias.cljs$core$IFn$_invoke$arity$1([cljs.core.str.cljs$core$IFn$_invoke$arity$1(original),\"_\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(suffix)].join(''));\n})], 0)));\n});\nmetabase.lib.util.strip_id_regex = (new RegExp(\" id$\",\"i\"));\n/**\n * Inputs: [display-name :- :string]\n *   Return: :string\n *        \n * \n *   Given a display name string like \"Product ID\", this will drop the trailing \"ID\" and trim whitespace.\n *   Used to turn a FK field's name into a pseudo table name when implicitly joining.\n */\nmetabase.lib.util.strip_id = (function metabase$lib$util$strip_id(display_name){\n\nreturn clojure.string.trim(clojure.string.replace(display_name,metabase.lib.util.strip_id_regex,\"\"));\n});\n/**\n * Inputs: [query :- :metabase.lib.schema/query stage-number :- :int location :- [:enum :breakout :aggregation] a-summary-clause]\n *   Return: :metabase.lib.schema/query\n *        \n * \n *   If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n * as well as any subsequent stages.\n */\nmetabase.lib.util.add_summary_clause = (function metabase$lib$util$add_summary_clause(query,stage_number,location,a_summary_clause){\n\nvar query__$1 = metabase.lib.util.pipeline(query);\nvar stage_number__$1 = (function (){var or__5045__auto__ = stage_number;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn (-1);\n}\n})();\nvar stage = metabase.lib.util.query_stage(query__$1,stage_number__$1);\nvar new_summary_QMARK_ = (!(((cljs.core.seq(new cljs.core.Keyword(null,\"aggregation\",\"aggregation\",1597476696).cljs$core$IFn$_invoke$arity$1(stage))) || (cljs.core.seq(new cljs.core.Keyword(null,\"breakout\",\"breakout\",-732419050).cljs$core$IFn$_invoke$arity$1(stage))))));\nvar new_query = metabase.lib.util.update_query_stage.cljs$core$IFn$_invoke$arity$variadic(query__$1,stage_number__$1,cljs.core.update,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([location,(function (summary_clauses){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(summary_clauses),metabase.lib.common.__GT_op_arg.cljs$core$IFn$_invoke$arity$1(a_summary_clause));\n})], 0));\nif(new_summary_QMARK_){\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$5(metabase.lib.util.update_query_stage(new_query,stage_number__$1,(function (stage__$1){\nreturn medley.core.update_existing.cljs$core$IFn$_invoke$arity$3(cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic(stage__$1,new cljs.core.Keyword(null,\"order-by\",\"order-by\",1527318070),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230)], 0)),new cljs.core.Keyword(null,\"joins\",\"joins\",1033962699),(function (joins){\nreturn cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__48522_SHARP_){\nreturn cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(p1__48522_SHARP_,new cljs.core.Keyword(null,\"fields\",\"fields\",-1932066230));\n}),joins);\n}));\n})),new cljs.core.Keyword(null,\"stages\",\"stages\",-442109532),cljs.core.comp.cljs$core$IFn$_invoke$arity$2((function (p1__48523_SHARP_){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,p1__48523_SHARP_);\n}),cljs.core.subvec),(0),(metabase.lib.util.canonical_stage_index(query__$1,stage_number__$1) + (1)));\n} else {\nreturn new_query;\n}\n});\n/**\n * Adds a default :effective-type property if it does not exist and\n *   :base-type is known.\n * \n *   This is needed only because we have to convert queries to the Legacy\n *   form.\n *   The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n *   :effective-type property, but it should be present for the frontend\n *   to work. It defaults to the :base-type property.\n */\nmetabase.lib.util.with_default_effective_type = (function metabase$lib$util$with_default_effective_type(clause){\nvar options = metabase.lib.options.options(clause);\nvar default_effective_type = (cljs.core.truth_(new cljs.core.Keyword(null,\"effective-type\",\"effective-type\",-355725458).cljs$core$IFn$_invoke$arity$1(options))?null:new cljs.core.Keyword(null,\"base-type\",\"base-type\",1167971299).cljs$core$IFn$_invoke$arity$1(options));\nvar G__48525 = clause;\nif(cljs.core.truth_(default_effective_type)){\nreturn metabase.lib.options.update_options.cljs$core$IFn$_invoke$arity$variadic(G__48525,cljs.core.assoc,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"effective-type\",\"effective-type\",-355725458),default_effective_type], 0));\n} else {\nreturn G__48525;\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","metabase/lib/util.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",22],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.pprint","~$cljs.pprint","~$clojure.core.match","~$cljs.core.match"],"~:use-macros",null,"~:excludes",["~#set",["~$format"]],"~:name","~$metabase.lib.util","~:reader-aliases",["^ "],"~:js-aliases",["^ ","crc-32","~$shadow.js.shim.module$crc_32"],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$metabase.lib.schema","^T","~$mu","~$metabase.util.malli","~$set","~$clojure.set","~$gstring","~$goog.string","~$i18n","~$metabase.shared.util.i18n","~$lib.schema.common","~$metabase.lib.schema.common","~$u","~$metabase.util","~$lib.schema.expression","~$metabase.lib.schema.expression","~$metabase.mbql.util","^16","^Z","^Z","~$mbql.u","^16","~$lib.common","~$metabase.lib.common","^?","^?","~$goog","^1:","~$lib.schema","^T","^12","^12","~$lib.options","~$metabase.lib.options","^15","^15","~$metabase.lib.schema.id","^1>","^X","^X","~$m","~$medley.core","^13","^13","^19","^19","^10","^10","^O","^O","~$goog.string.format","^1@","^V","^V","~$gstring.format","^1@","~$str","~$clojure.string","~$lib.schema.id","^1>","^1=","^1=","^1C","^1C","^1?","^1?","~$CRC32","^O"],"~:seen",["^H",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^U","^V","^[","^10","~$u","^13","^14","^15","^18","^19","^?","^?","^15","^15","^13","^13","^19","^19","^10","^10","^V","^V"],"~:form",["~#list",["~$ns","^K",["^1K",["~:refer-clojure","~:exclude",["^I"]]],["^1K",["^1G",["crc-32","~:as","^1E"],["^Z","^1O","^Y"],["^1@","^1O","^1A"],["^X","^1O","^W"],["^1C","^1O","^1B"],["^1?","^1O","~$m"],["^19","^1O","^18"],["^1=","^1O","^1<"],["^T","^1O","^1;"],["^12","^1O","^11"],["^15","^1O","^14"],["^1>","^1O","^1D"],["^16","^1O","^17"],["^10","^1O","^["],["^13","^1O","~$u"],["^V","^1O","^U"]]]]],"~:flags",["^ ","^1G",["^H",[]]],"~:js-deps",["^ ","^N",["^ ","^1O","^1E"]],"~:deps",["^1:","^?","^O","^Z","^1@","^X","^1C","^1?","^19","^1=","^T","^12","^15","^1>","^16","^10","^13","^V"]],"^Q","^K","~:resource-id",["~:shadow.build.classpath/resource","metabase/lib/util.cljc"],"~:compiled-at",1692612527689,"^L",["^ ","^T","^T","^U","^V","^W","^X","^Y","^Z","^[","^10","^11","^12","~$u","^13","^14","^15","^16","^16","^Z","^Z","^17","^16","^18","^19","^?","^?","^1:","^1:","^1;","^T","^12","^12","^1<","^1=","^15","^15","^1>","^1>","^X","^X","~$m","^1?","^13","^13","^19","^19","^10","^10","^O","^O","^1@","^1@","^V","^V","^1A","^1@","^1B","^1C","^1D","^1>","^1=","^1=","^1C","^1C","^1?","^1?","^1E","^O"],"~:resource-name","metabase/lib/util.cljc","~:warnings",[],"~:source","(ns metabase.lib.util\n  (:refer-clojure :exclude [format])\n  (:require\n   #?@(:clj\n       ([potemkin :as p]))\n   #?@(:cljs\n       ([\"crc-32\" :as CRC32]\n        [goog.string :as gstring]\n        [goog.string.format :as gstring.format]))\n   [clojure.set :as set]\n   [clojure.string :as str]\n   [medley.core :as m]\n   [metabase.lib.common :as lib.common]\n   [metabase.lib.options :as lib.options]\n   [metabase.lib.schema :as lib.schema]\n   [metabase.lib.schema.common :as lib.schema.common]\n   [metabase.lib.schema.expression :as lib.schema.expression]\n   [metabase.lib.schema.id :as lib.schema.id]\n   [metabase.mbql.util :as mbql.u]\n   [metabase.shared.util.i18n :as i18n]\n   [metabase.util :as u]\n   [metabase.util.malli :as mu]))\n\n#?(:clj\n   (set! *warn-on-reflection* true))\n\n;; The formatting functionality is only loaded if you depend on goog.string.format.\n#?(:cljs (comment gstring.format/keep-me))\n\n;;; For convenience: [[metabase.lib.util/format]] maps to [[clojure.core/format]] in Clj and [[goog.string/format]] in\n;;; Cljs. They both work like [[clojure.core/format]], but since that doesn't exist in Cljs, you can use this instead.\n#?(:clj\n   (p/import-vars [clojure.core format])\n\n   :cljs\n   (def format \"Exactly like [[clojure.core/format]] but ClojureScript-friendly.\" gstring/format))\n\n(defn clause?\n  \"Returns true if this is a clause.\"\n  [clause]\n  (and (vector? clause)\n       (> (count clause) 1)\n       (keyword? (first clause))\n       (map? (second clause))\n       (contains? (second clause) :lib/uuid)))\n\n(defn clause-of-type?\n  \"Returns true if this is a clause.\"\n  [clause clause-type]\n  (and (clause? clause)\n       (= (first clause) clause-type)))\n\n(defn field-clause?\n  \"Returns true if this is a field clause.\"\n  [clause]\n  (clause-of-type? clause :field))\n\n(defn expression-name\n  \"Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause.\"\n  [clause]\n  (when (clause? clause)\n    (get-in clause [1 :lib/expression-name])))\n\n(defn named-expression-clause\n  \"Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value.\"\n  [clause a-name]\n  (assoc-in\n    (if (clause? clause)\n      clause\n      [:value {:lib/uuid (str (random-uuid))\n               :effective-type (lib.schema.expression/type-of clause)}\n       clause])\n    [1 :lib/expression-name] a-name))\n\n(defn replace-clause\n  \"Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens.\"\n  [stage location target-clause new-clause]\n  {:pre [((some-fn clause? #(= (:lib/type %) :mbql/join)) target-clause)]}\n  (let [new-clause (if (= :expressions (first location))\n                     (named-expression-clause new-clause (expression-name target-clause))\n                     new-clause)]\n    (m/update-existing-in\n      stage\n      location\n      (fn [clause-or-clauses]\n        (->> (for [clause clause-or-clauses]\n               (if (= (lib.options/uuid clause) (lib.options/uuid target-clause))\n                 new-clause\n                 clause))\n             vec)))))\n\n(defn remove-clause\n  \"Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage.\"\n  [stage location target-clause]\n  {:pre [(clause? target-clause)]}\n  (if-let [target (get-in stage location)]\n    (let [target-uuid (lib.options/uuid target-clause)\n          [first-loc last-loc] [(first location) (last location)]\n          result (into [] (remove (comp #{target-uuid} lib.options/uuid)) target)\n          result (when-not (and (= location [:fields])\n                                (every? #(clause-of-type? % :expression) result))\n                   result)]\n      (cond\n        (seq result)\n        (assoc-in stage location result)\n\n        (= [:joins :conditions] [first-loc last-loc])\n        (throw (ex-info (i18n/tru \"Cannot remove the final join condition\")\n                        {:conditions (get-in stage location)}))\n\n        (= [:joins :fields] [first-loc last-loc])\n        (update-in stage (pop location) dissoc last-loc)\n\n        :else\n        (m/dissoc-in stage location)))\n    stage))\n\n;;; TODO -- all of this `->pipeline` stuff should probably be merged into [[metabase.lib.convert]] at some point in\n;;; the near future.\n\n(defn- native-query->pipeline\n  \"Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n          ;; readability in the REPL.\n          :stages   [(merge {:lib/type :mbql.stage/native}\n                            (set/rename-keys (:native query) {:query :native}))]}\n         (dissoc query :type :native)))\n\n(declare inner-query->stages)\n\n(defn- update-legacy-boolean-expression->list\n  \"Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`\"\n  [m legacy-key pMBQL-key]\n  (cond-> m\n    (contains? m legacy-key) (update legacy-key #(if (and (vector? %)\n                                                       (= (first %) :and))\n                                                   (vec (drop 1 %))\n                                                   [%]))\n    (contains? m legacy-key) (set/rename-keys {legacy-key pMBQL-key})))\n\n(defn- join->pipeline [join]\n  (let [source (select-keys join [:source-table :source-query])\n        stages (inner-query->stages source)]\n    (-> join\n        (dissoc :source-table :source-query)\n        (update-legacy-boolean-expression->list :condition :conditions)\n        (assoc :lib/type :mbql/join\n               :stages stages)\n        lib.options/ensure-uuid)))\n\n(defn- joins->pipeline [joins]\n  (mapv join->pipeline joins))\n\n(defn ->stage-metadata\n  \"Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]].\"\n  [source-metadata]\n  (when source-metadata\n    (-> (if (seqable? source-metadata)\n          {:columns source-metadata}\n          source-metadata)\n        (update :columns (fn [columns]\n                           (mapv (fn [column]\n                                   (-> column\n                                       (update-keys u/->kebab-case-en)\n                                       (assoc :lib/type :metadata/column)))\n                                 columns)))\n        (assoc :lib/type :metadata/results))))\n\n(defn- inner-query->stages [{:keys [source-query source-metadata], :as inner-query}]\n  (let [previous-stages (if source-query\n                          (inner-query->stages source-query)\n                          [])\n        source-metadata (->stage-metadata source-metadata)\n        previous-stage  (dec (count previous-stages))\n        previous-stages (cond-> previous-stages\n                          (and source-metadata\n                               (not (neg? previous-stage))) (assoc-in [previous-stage :lib/stage-metadata] source-metadata))\n        stage-type      (if (:native inner-query)\n                          :mbql.stage/native\n                          :mbql.stage/mbql)\n        ;; we're using `merge` here instead of threading stuff so the `:lib/` keys are the first part of the map for\n        ;; readability in the REPL.\n        this-stage      (merge {:lib/type stage-type}\n                               (dissoc inner-query :source-query :source-metadata))\n        this-stage      (cond-> this-stage\n                          (seq (:joins this-stage)) (update :joins joins->pipeline)\n                          :always (update-legacy-boolean-expression->list :filter :filters))]\n    (conj previous-stages this-stage)))\n\n(defn- mbql-query->pipeline\n  \"Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information.\"\n  [query]\n  (merge {:lib/type :mbql/query\n          :stages   (inner-query->stages (:query query))}\n         (dissoc query :type :query)))\n\n(def LegacyOrPMBQLQuery\n  \"Schema for a map that is either a legacy query OR a pMBQL query.\"\n  [:or\n   [:map\n    {:error/message \"legacy query\"}\n    [:type [:enum :native :query]]]\n   [:map\n    {:error/message \"pMBQL query\"}\n    [:lib/type [:= :mbql/query]]]])\n\n(mu/defn pipeline\n  \"Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)\"\n  [query :- LegacyOrPMBQLQuery]\n  (if (= (:lib/type query) :mbql/query)\n    query\n    (case (:type query)\n      :native (native-query->pipeline query)\n      :query  (mbql-query->pipeline query))))\n\n(mu/defn canonical-stage-index :- [:int {:min 0}]\n  \"If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc.\"\n  [{:keys [stages], :as _query} :- :map\n   stage-number                 :- :int]\n  (let [stage-number' (if (neg? stage-number)\n                        (+ (count stages) stage-number)\n                        stage-number)]\n    (when (or (>= stage-number' (count stages))\n              (neg? stage-number'))\n      (throw (ex-info (i18n/tru \"Stage {0} does not exist\" stage-number)\n                      {:num-stages (count stages)})))\n    stage-number'))\n\n(mu/defn previous-stage-number :- [:maybe [:int {:min 0}]]\n  \"The index of the previous stage, if there is one. `nil` if there is no previous stage.\"\n  [query        :- :map\n   stage-number :- :int]\n  (let [stage-number (canonical-stage-index query stage-number)]\n    (when (pos? stage-number)\n      (dec stage-number))))\n\n(defn first-stage?\n  \"Whether a `stage-number` is referring to the first stage of a query or not.\"\n  [query stage-number]\n  (not (previous-stage-number query stage-number)))\n\n(defn next-stage-number\n  \"The index of the next stage, if there is one. `nil` if there is no next stage.\"\n  [{:keys [stages], :as _query} stage-number]\n  (let [stage-number (if (neg? stage-number)\n                       (+ (count stages) stage-number)\n                       stage-number)]\n    (when (< (inc stage-number) (count stages))\n      (inc stage-number))))\n\n(mu/defn query-stage :- ::lib.schema/stage\n  \"Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int]\n  (let [{:keys [stages], :as query} (pipeline query)]\n    (get (vec stages) (canonical-stage-index query stage-number))))\n\n(mu/defn previous-stage :- [:maybe ::lib.schema/stage]\n  \"Return the previous stage of the query, if there is one; otherwise return `nil`.\"\n  [query stage-number :- :int]\n  (when-let [stage-num (previous-stage-number query stage-number)]\n    (query-stage query stage-num)))\n\n(mu/defn update-query-stage :- ::lib.schema/query\n  \"Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query.\"\n  [query        :- LegacyOrPMBQLQuery\n   stage-number :- :int\n   f & args]\n  (let [{:keys [stages], :as query} (pipeline query)\n        stage-number'               (canonical-stage-index query stage-number)\n        stages'                     (apply update (vec stages) stage-number' f args)]\n    (assoc query :stages stages')))\n\n(mu/defn ensure-mbql-final-stage :- ::lib.schema/query\n  \"Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one.\"\n  [query]\n  (let [query (pipeline query)]\n    (cond-> query\n      (= (:lib/type (query-stage query -1)) :mbql.stage/native)\n      (update :stages conj {:lib/type :mbql.stage/mbql}))))\n\n(defn join-strings-with-conjunction\n  \"This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \\\"and\\\" [\\\"X\\\" \\\"Y\\\" \\\"Z\\\"])\n  ;; => \\\"X, Y, and Z\\\"\"\n  [conjunction coll]\n  (when (seq coll)\n    (if (= (count coll) 1)\n      (first coll)\n      (let [conjunction (str \\space (str/trim conjunction) \\space)]\n        (if (= (count coll) 2)\n          ;; exactly 2 args: X and Y\n          (str (first coll) conjunction (second coll))\n          ;; > 2 args: X, Y, and Z\n          (str\n           (str/join \", \" (butlast coll))\n           \",\"\n           conjunction\n           (last coll)))))))\n\n(mu/defn ^:private string-byte-count :- [:int {:min 0}]\n  \"Number of bytes in a string using UTF-8 encoding.\"\n  [s :- :string]\n  #?(:clj (count (.getBytes (str s) \"UTF-8\"))\n     :cljs (.. (js/TextEncoder.) (encode s) -length)))\n\n#?(:clj\n   (mu/defn ^:private string-character-at :- [:string {:min 0, :max 1}]\n     [s :- :string\n      i :-[:int {:min 0}]]\n     (str (.charAt ^String s i))))\n\n(mu/defn ^:private truncate-string-to-byte-count :- :string\n  \"Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n  *characters*).\"\n  [s                :- :string\n   max-length-bytes :- [:int {:min 1}]]\n  #?(:clj\n     (loop [i 0, cumulative-byte-count 0]\n       (cond\n         (= cumulative-byte-count max-length-bytes) (subs s 0 i)\n         (> cumulative-byte-count max-length-bytes) (subs s 0 (dec i))\n         (>= i (count s))                           s\n         :else                                      (recur (inc i)\n                                                           (long (+\n                                                                  cumulative-byte-count\n                                                                  (string-byte-count (string-character-at s i)))))))\n\n     :cljs\n     (let [buf (js/Uint8Array. max-length-bytes)\n           result (.encodeInto (js/TextEncoder.) s buf)] ;; JS obj {read: chars_converted, write: bytes_written}\n       (subs s 0 (.-read result)))))\n\n(def ^:private truncate-alias-max-length-bytes\n  \"Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n  reasoning.\"\n  60)\n\n(def ^:private truncated-alias-hash-suffix-length\n  \"Length of the hash suffixed to truncated strings by [[truncate-alias]].\"\n  ;; 8 bytes for the CRC32 plus one for the underscore\n  9)\n\n(mu/defn ^:private crc32-checksum :- [:string {:min 8, :max 8}]\n  \"Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string.\"\n  [s :- :string]\n  (let [s #?(:clj (Long/toHexString (.getValue (doto (java.util.zip.CRC32.)\n                                                 (.update (.getBytes ^String s \"UTF-8\")))))\n             :cljs (-> (CRC32/str s 0)\n                       (unsigned-bit-shift-right 0) ; see https://github.com/SheetJS/js-crc32#signed-integers\n                       (.toString 16)))]\n    ;; pad to 8 characters if needed. Might come out as less than 8 if the first byte is `00` or `0x` or something.\n    (loop [s s]\n      (if (< (count s) 8)\n        (recur (str \\0 s))\n        s))))\n\n(mu/defn truncate-alias :- [:string {:min 1, :max 60}]\n  \"Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \\\"some_really_long_string\\\" 15) ;   -> \\\"some_r_8e0f9bc2\\\"\n    (truncate-alias \\\"some_really_long_string_2\\\" 15) ; -> \\\"some_r_2a3c73eb\\\"\"\n  ([s]\n   (truncate-alias s truncate-alias-max-length-bytes))\n\n  ([s         :- ::lib.schema.common/non-blank-string\n    max-bytes :- [:int {:min 0}]]\n   (if (<= (string-byte-count s) max-bytes)\n     s\n     (let [checksum  (crc32-checksum s)\n           truncated (truncate-string-to-byte-count s (- max-bytes truncated-alias-hash-suffix-length))]\n       (str truncated \\_ checksum)))))\n\n(mu/defn legacy-string-table-id->card-id :- [:maybe ::lib.schema.id/card]\n  \"If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`.\"\n  [table-id]\n  (when (string? table-id)\n    (when-let [[_match card-id-str] (re-find #\"^card__(\\d+)$\" table-id)]\n      (parse-long card-id-str))))\n\n(mu/defn source-table-id :- [:maybe ::lib.schema.id/table]\n  \"If this query has a `:source-table` ID, return it.\"\n  [query]\n  (-> query :stages first :source-table))\n\n(mu/defn source-card-id :- [:maybe ::lib.schema.id/card]\n  \"If this query has a `:source-card` ID, return it.\"\n  [query]\n  (-> query :stages first :source-card))\n\n(mu/defn unique-name-generator :- [:=>\n                                   [:cat ::lib.schema.common/non-blank-string]\n                                   ::lib.schema.common/non-blank-string]\n  \"Create a new function with the signature\n\n    (f str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash).\"\n  []\n  (comp truncate-alias\n        (mbql.u/unique-name-generator\n         ;; unique by lower-case name, e.g. `NAME` and `name` => `NAME` and `name_2`\n         :name-key-fn     u/lower-case-en\n         ;; truncate alias to 60 characters (actually 51 characters plus a hash).\n         :unique-alias-fn (fn [original suffix]\n                            (truncate-alias (str original \\_ suffix))))))\n\n(def ^:private strip-id-regex\n  #?(:cljs (js/RegExp. \" id$\" \"i\")\n     ;; `(?i)` is JVM-specific magic to turn on the `i` case-insensitive flag.\n     :clj  #\"(?i) id$\"))\n\n(mu/defn strip-id :- :string\n  \"Given a display name string like \\\"Product ID\\\", this will drop the trailing \\\"ID\\\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining.\"\n  [display-name :- :string]\n  (-> display-name\n      (str/replace strip-id-regex \"\")\n      str/trim))\n\n(mu/defn add-summary-clause :- ::lib.schema/query\n  \"If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages.\"\n  [query :- ::lib.schema/query\n   stage-number :- :int\n   location :- [:enum :breakout :aggregation]\n   a-summary-clause]\n  (let [query (pipeline query)\n        stage-number (or stage-number -1)\n        stage (query-stage query stage-number)\n        new-summary? (not (or (seq (:aggregation stage)) (seq (:breakout stage))))\n        new-query (update-query-stage\n                    query stage-number\n                    update location\n                    (fn [summary-clauses]\n                      (conj (vec summary-clauses) (lib.common/->op-arg a-summary-clause))))]\n    (if new-summary?\n      (-> new-query\n          (update-query-stage\n            stage-number\n            (fn [stage]\n              (-> stage\n                  (dissoc :order-by :fields)\n                  (m/update-existing :joins (fn [joins] (mapv #(dissoc % :fields) joins))))))\n          ;; subvec holds onto references, so create a new vector\n          (update :stages (comp #(into [] %) subvec) 0 (inc (canonical-stage-index query stage-number))))\n      new-query)))\n\n(defn with-default-effective-type\n  \"Adds a default :effective-type property if it does not exist and\n  :base-type is known.\n\n  This is needed only because we have to convert queries to the Legacy\n  form.\n  The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n  :effective-type property, but it should be present for the frontend\n  to work. It defaults to the :base-type property.\"\n  [clause]\n  (let [options (lib.options/options clause)\n        default-effective-type (when-not (:effective-type options)\n                                 (:base-type options))]\n    (cond-> clause\n      default-effective-type\n      (lib.options/update-options assoc :effective-type default-effective-type))))\n","~:reader-features",["^H",["~:cljs-release","~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["metabase.lib.util/format","goog.string/format","metabase.lib.util/clause?","clause","cljs.core/vector?","cljs.core/count","cljs.core/Keyword","cljs.core/first","cljs.core/map?","cljs.core/second","cljs.core/contains?","metabase.lib.util/clause-of-type?","clause-type","cljs.core._EQ_","metabase.lib.util/field-clause?","metabase.lib.util/expression-name","cljs.core.get_in","metabase.lib.util/named-expression-clause","a-name","cljs.core/assoc-in","cljs.core/random-uuid","metabase.lib.schema.expression/type-of","metabase.lib.util/replace-clause","stage","location","target-clause","new-clause","medley.core/update-existing-in","clause-or-clauses","iter__5523__auto__","s__48391","cljs.core/LazySeq","temp__5804__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__5521__auto__","size__5522__auto__","b__48393","cljs.core/chunk-buffer","i__48392","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__48390","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","metabase.lib.options/uuid","cljs.core/vec","metabase.lib.util/remove-clause","temp__5802__auto__","target","vec__48398","cljs.core.nth","target-uuid","first-loc","last-loc","cljs.core/last","result","cljs.core.into","cljs.core.remove","cljs.core.comp","p1__48397#","cljs.core/every?","cljs.core.ex_info","metabase.shared.util.i18n/js-i18n","cljs.core.update_in","cljs.core/pop","cljs.core/dissoc","medley.core.dissoc_in","metabase.lib.util/native-query->pipeline","query","cljs.core.merge","clojure.set/rename-keys","cljs.core.dissoc","metabase.lib.util/update-legacy-boolean-expression->list","m","legacy-key","pMBQL-key","G__48402","p1__48401#","cljs.core.update","cljs.core.drop","metabase.lib.util/join->pipeline","join","source","cljs.core/select-keys","stages","metabase.lib.util/inner-query->stages","cljs.core.assoc","metabase.lib.options/ensure-uuid","metabase.lib.util/joins->pipeline","joins","cljs.core.mapv","metabase.lib.util/->stage-metadata","source-metadata","cljs.core/seqable?","columns","column","cljs.core/update-keys","metabase.util/->kebab-case-en","p__48403","map__48404","cljs.core/--destructure-map","cljs.core.get","source-query","inner-query","previous-stages","previous-stage","G__48405","and__5043__auto__","stage-type","this-stage","G__48406","cljs.core.conj","metabase.lib.util/mbql-query->pipeline","metabase.lib.util/LegacyOrPMBQLQuery","metabase.lib.util/pipeline","G__48420","js/Error","p__48422","map__48423","metabase.lib.util/canonical-stage-index","_query","stage-number","stage-number'","metabase.shared.util.i18n.js_i18n","metabase.lib.util/previous-stage-number","metabase.lib.util/first-stage?","cljs.core/not","p__48425","map__48426","metabase.lib.util/next-stage-number","metabase.lib.util/query-stage","map__48428","metabase.lib.util/previous-stage","stage-num","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","metabase.lib.util/update-query-stage","seq48433","G__48434","cljs.core/next","G__48435","G__48436","self__5754__auto__","f","args","map__48437","stages'","cljs.core.apply","cljs.core/update","metabase.lib.util/ensure-mbql-final-stage","G__48439","cljs.core/conj","metabase.lib.util/join-strings-with-conjunction","conjunction","coll","clojure.string/trim","clojure.string.join","cljs.core/butlast","metabase.lib.util/string-byte-count","s","js/TextEncoder","metabase.lib.util/truncate-string-to-byte-count","max-length-bytes","buf","js/Uint8Array","cljs.core.subs","metabase.lib.util/truncate-alias-max-length-bytes","metabase.lib.util/truncated-alias-hash-suffix-length","metabase.lib.util/crc32-checksum","js/shadow.js.shim.module$crc_32.str","G__48482","metabase.lib.util/truncate-alias","metabase.lib.util.truncate_alias","max-bytes","checksum","truncated","metabase.lib.util/legacy-string-table-id->card-id","table-id","vec__48497","_match","card-id-str","cljs.core/re-find","cljs.core/parse-long","metabase.lib.util/source-table-id","metabase.lib.util/source-card-id","metabase.lib.util/unique-name-generator","metabase.mbql.util.unique_name_generator","metabase.util/lower-case-en","original","suffix","metabase.lib.util/strip-id-regex","js/RegExp","metabase.lib.util/strip-id","display-name","clojure.string/replace","metabase.lib.util/add-summary-clause","a-summary-clause","or__5045__auto__","new-summary?","new-query","metabase.lib.util.update_query_stage","summary-clauses","metabase.lib.common/->op-arg","medley.core.update_existing","p1__48522#","p1__48523#","cljs.core/subvec","metabase.lib.util/with-default-effective-type","options","metabase.lib.options/options","default-effective-type","G__48525","metabase.lib.options.update_options","cljs.core/assoc","cljs.core/chunk-first"]],"~:used-vars",["^H",["~$metabase.lib.util/legacy-string-table-id->card-id","~$cljs.core/--destructure-map","~$clojure.string/join","~$metabase.lib.util/replace-clause","~$metabase.lib.util/pipeline","~$cljs.core/comp","~$cljs.core/rest","~$metabase.lib.util/string-byte-count","~$metabase.lib.util/join-strings-with-conjunction","~$metabase.lib.util/native-query->pipeline","~$metabase.lib.util/source-table-id","~$metabase.lib.util/ensure-mbql-final-stage","~$metabase.lib.util/next-stage-number","~$js/RegExp","~$metabase.lib.options/options","~$metabase.mbql.util/unique-name-generator","~$metabase.lib.util/unique-name-generator","~$cljs.core/vector?","~$cljs.core/=","~$metabase.util/lower-case-en","~$metabase.lib.util/query-stage","~$cljs.core/IndexedSeq","~$metabase.lib.util/remove-clause","~$cljs.core/update-keys","~$cljs.core/count","~$metabase.lib.options/ensure-uuid","~$cljs.core/seq","~$cljs.core/chunk-first","~$metabase.lib.common/->op-arg","~$cljs.core/apply","~$metabase.lib.options/update-options","~$metabase.lib.util/clause-of-type?","~$cljs.core/Keyword","~$medley.core/dissoc-in","~$goog.string/format","~$metabase.lib.util/canonical-stage-index","~$metabase.lib.util/truncate-string-to-byte-count","~$cljs.core/last","~$cljs.core/chunk","~$cljs.core/mapv","~$metabase.lib.util/truncate-alias","~$js/shadow.js.shim.module$crc_32.str","~$cljs.core/dissoc","~$cljs.core/LazySeq","~$cljs.core/chunk-rest","~$metabase.util/->kebab-case-en","~$metabase.lib.util/join->pipeline","~$metabase.lib.util/named-expression-clause","~$cljs.core/pop","~$metabase.lib.schema.expression/type-of","~$js/TextEncoder","~$js/Uint8Array","~$metabase.lib.util/format","~$metabase.lib.util/update-query-stage","~$cljs.core/contains?","~$cljs.core/into","~$cljs.core/map?","~$cljs.core/conj","~$cljs.core/update","~$medley.core/update-existing","~$cljs.core/get-in","~$metabase.lib.util/clause?","~$clojure.set/rename-keys","~$cljs.core/get","~$metabase.lib.util/field-clause?","~$cljs.core/chunk-append","~$metabase.lib.util/truncated-alias-hash-suffix-length","~$cljs.core/-nth","~$cljs.core/remove","~$metabase.lib.util/LegacyOrPMBQLQuery","~$cljs.core/re-find","~$cljs.core/subvec","~$metabase.lib.util/crc32-checksum","~$metabase.shared.util.i18n/js-i18n","~$medley.core/update-existing-in","~$cljs.core/nth","~$cljs.core/ex-info","~$cljs.core/second","~$clojure.string/replace","~$cljs.core/next","~$cljs.core/vec","~$metabase.lib.util/expression-name","~$cljs.core/select-keys","~$cljs.core/chunk-cons","~$metabase.lib.util/inner-query->stages","~$cljs.core/not","~$metabase.lib.util/previous-stage-number","~$cljs.core/cons","~$cljs.core/assoc","~$cljs.core/assoc-in","~$cljs.core/chunk-buffer","~$cljs.core/seqable?","~$cljs.core/parse-long","~$metabase.lib.util/->stage-metadata","~$clojure.string/trim","~$metabase.lib.util/mbql-query->pipeline","~$metabase.lib.util/strip-id","~$metabase.lib.util/update-legacy-boolean-expression->list","~$cljs.core/first","~$cljs.core/butlast","~$metabase.lib.util/add-summary-clause","~$metabase.lib.util/previous-stage","~$metabase.lib.util/with-default-effective-type","~$metabase.lib.util/joins->pipeline","~$cljs.core/subs","~$cljs.core/merge","~$cljs.core/every?","~$metabase.lib.util/strip-id-regex","~$cljs.core/update-in","~$js/Error","~$cljs.core/random-uuid","~$metabase.lib.util/source-card-id","~$cljs.core/drop","~$metabase.lib.util/first-stage?","~$metabase.lib.options/uuid","~$cljs.core/chunked-seq?","~$metabase.lib.util/truncate-alias-max-length-bytes"]]],"~:cache-keys",["~#cmap",[["^1T","camel_snake_kebab/internals/misc.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^H",[]],"~:deps-syms",["^1:","^?","~$camel-snake-kebab.internals.string-separator","^1C"]]],["^1T","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.dom.HtmlElement"]]],["^1T","metabase/shared/util/i18n.cljs"],["6c3c8615004b349dae9851ed547d516d45e04bd0","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$shadow.js.shim.module$ttag","^1C"]]],["^1T","goog/labs/useragent/platform.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.string.internal","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^1T","metabase/types.cljc"],["00232bf78b259e26a21c218c8f2d746ba7003a15","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^X","~$metabase.types.coercion-hierarchies","^13"]]],["^1T","cljs/spec/gen/alpha.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$goog.Uri"]]],["^1T","metabase/lib/util.cljc"],["11c3262368d876979e323f3e646aab21fbf9b86e","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^O","^Z","^1@","^X","^1C","^1?","^19","^1=","^T","^12","^15","^1>","^16","^10","^13","^V"]]],["^1T","lambdaisland/glogi.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$goog.log","~$goog.debug.Console","~$goog.array","^1C","~$goog.object","~$goog.debug.FancyWindow","~$goog.debug.DivConsole"]]],["^1T","goog/math/math.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.asserts"]]],["^1T","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/string/stringformat.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^Z"]]],["^1T","malli/registry.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^50","^51","^5<","^4[","^52","^53"]]],["^1T","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^4["]]],["^1T","goog/style/style.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","~$goog.dom","~$goog.dom.NodeType","~$goog.dom.TagName","~$goog.dom.safe","~$goog.dom.vendor","~$goog.html.SafeStyleSheet","~$goog.math.Box","~$goog.math.Coordinate","~$goog.math.Rect","~$goog.math.Size","^59","~$goog.reflect","^Z","~$goog.userAgent"]]],["^1T","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<"]]],["~:shadow.build.js-support/require","moment"],["~$shadow.js.shim.module$moment","shadow.js.shim.module$moment.js","require","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^5M","moment-timezone"],["~$shadow.js.shim.module$moment_timezone","shadow.js.shim.module$moment_timezone.js","require","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","metabase/mbql/schema/macros.cljs"],["2af09bd42ffb1e15b66723cf7ba15db7dc75d10b","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","metabase/lib/schema/mbql_clause.cljc"],["e5bdd00c58db706b1219843528fd3cd9dd8ab728","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^12","^15","~$metabase.types","^V","~$metabase.util.malli.registry"]]],["^1T","goog/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.labs.userAgent.browser","~$goog.labs.userAgent.engine","~$goog.labs.userAgent.platform","^50","^5K","^4["]]],["^1T","malli/generator.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^A","^1C","~$clojure.test.check","~$clojure.test.check.generators","~$clojure.test.check.properties","~$clojure.test.check.random","~$clojure.test.check.rose-tree","~$malli.core","~$malli.registry"]]],["^1T","clojure/test/check/properties.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^5V","~$clojure.test.check.results"]]],["^1T","clojure/test/check/generators.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","^5X","^5Y","^Z"]]],["^1T","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","metabase/lib/common.cljc"],["a3bc6343077ef13a3da77612b68f23f9b2a3d890","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$metabase.lib.dispatch","~$metabase.lib.hierarchy","^1=","~$metabase.lib.ref","^12","^V"]]],["^1T","metabase/lib/schema/util.cljc"],["14a9e8a90c56f5e44b4ecd361e962722fd97aecf","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1="]]],["^1T","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","malli/util.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^?","^5Z"]]],["^1T","clojure/test/check/random/doubles.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$clojure.test.check.random.longs"]]],["^1T","net/cgrand/macrovich.cljc"],["abcb26cbfe0f8eef363b25525210c0fe1eb1f693","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","malli/destructure.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$clojure.walk","^5Z","~$malli.impl.util"]]],["^1T","schema/spec/variant.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$schema.utils","~$schema.spec.core"]]],["^1T","goog/structs/circularbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","weavejester/dependency.cljc"],["7fd7f8879313f6a7e295f7447e668bdf492c42c1","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^X"]]],["^1T","metabase/lib/schema/common.cljc"],["3f51a06335a7cb84c835d859c422919499874414","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","^5P","^5Q"]]],["^1T","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^50","^4["]]],["^1T","cljs/pprint.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","^Z","~$goog.string.StringBuffer"]]],["^1T","metabase/lib/schema/template_tag.cljc"],["f1b6289b8e576857fe667aed3da134e4ad1ea26a","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^5Z","^12","^1>","~$metabase.mbql.schema","^5Q"]]],["^1T","metabase/lib/schema/ref.cljc"],["5037a60b3d2f427702cf5cedf23f02bcc394d051","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","^61","^62","^12","^15","^1>","~$metabase.lib.schema.mbql-clause","~$metabase.lib.schema.temporal-bucketing","^5P","^5Q"]]],["^1T","clojure/test/check/rose_tree.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","clojure/test/check/impl.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","camel_snake_kebab/internals/string_separator.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C"]]],["^1T","clojure/test/check/random.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$clojure.test.check.random.doubles","^64"]]],["^1T","metabase/lib/schema/expression/arithmetic.cljc"],["e6936a3e0b11bc3cd40d4e396c708af4622c21cb","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^5Z","^1?","^62","^12","^15","^6;","^6<","^5P","^5Q"]]],["^1T","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","metabase/lib/schema/expression/string.cljc"],["b2d7de575aaaa880fdc88dfc31642c8e002c3669","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^15","^6;"]]],["^1T","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","metabase/lib/schema/filter.cljc"],["0147dea423ebfd097bf1edb97f0325c9e2908a85","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^12","^15","^6;","^6<","^5Q"]]],["^1T","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<"]]],"~:SHADOW-TIMESTAMP",[1689947046000,1689947046000,1689947050000],["^1T","metabase/lib/ref.cljc"],["86a9fbeddec3e58f7bb54e61f5342658b370fb3b","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^61","~$metabase.lib.schema.ref","^V"]]],["^1T","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","^5K"]]],["^1T","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","~$goog.fs.blob","^5=","~$goog.html.SafeScript","~$goog.html.trustedtypes","^5?","^5@"]]],["^1T","schema/spec/leaf.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^68"]]],["^1T","metabase/util/format.cljc"],["875f86a08288cb3ad5a6f15df988897eaf8613af","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^Z"]]],["^1T","goog/math/irect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/math/box.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","^5H"]]],["^1T","metabase/lib/options.cljc"],["1870276153adf026e09a3e9ed1ba8beaad80e1c8","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^12","^10","^13","^V"]]],["^1T","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","clojure/test/check.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^5V","^5X","^60","^5Y","~$clojure.test.check.impl"]]],["^1T","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5?","~$goog.html.SafeUrl","^5@","^5<","^4["]]],["^1T","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^6A","~$goog.html.SafeStyle","^6D","^5>","~$goog.html.uncheckedconversions","^5?","^4["]]],["^1T","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5C","^5<","~$goog.dom.element"]]],["^1T","medley/core.cljc"],["f5117fa4c15ff14c4a0ab7db414b0f102afb0b8a","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","metabase/lib/schema/expression/conditional.cljc"],["226c4623394b90853fcb014e9a95e84ffc8bd6db","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^X","^15","^6;","^5P","^5Q"]]],["^1T","lambdaisland/glogi/console.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$lambdaisland.glogi","~$lambdaisland.glogi.print","^59","^57"]]],["^1T","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5?","^6A","^6I","^5F","^6D","^5C","^5>","^5@","^5<","^5R","^58","^59","^4[","~$goog.dom.tags","^6B"]]],["^1T","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^59"]]],["^1T","goog/math/size.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","malli/error.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","^5Z","~$malli.util"]]],["^1T","metabase/lib/dispatch.cljc"],["914208cd51b78412eff1b402519bbb422845497a","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^13"]]],["^1T","metabase/util/malli.cljc"],["0f9ba23be6bb9fa629617001e985b988d2322b17","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^?","^5Z","~$malli.destructure","~$malli.error","~$malli.generator","^6O","^10","^13"]]],["^1T","goog/labs/useragent/engine.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^58","^4[","^50"]]],["^1T","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","metabase/mbql/schema/helpers.cljc"],["b1f6002b97b59423b504abb666e13c9b0228b768","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","^5P","~$schema.core"]]],["^1T","goog/dom/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^58","^5<","^6E","~$goog.dom.BrowserFeature","^5B","^5C","^5D","^6H","^6J","^5H","^5J","^59","^Z","^5?","~$goog.string.Unicode","^5L"]]],["^1T","borkdude/dynaload.cljc"],["accd696ba364b850b4d92e38f5a34d0e828a0ad1","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","metabase/util/log.cljs"],["7d8a3bf01eb27c2ba7269dc90dc218e46bcc1d3a","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^56","^Z","^1@","^6L","~$lambdaisland.glogi.console"]]],["^1T","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.debug.Error","^5B"]]],["^1T","goog/debug/relativetimeprovider.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","malli/sci.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$borkdude.dynaload"]]],["^1T","metabase/lib/schema/expression.cljc"],["f5c5c3ff3dc0f9a8b407cd7d06a68c6787061991","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^61","^62","^12","^10","^5P","^V","^5Q"]]],["^1T","goog/math/rect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","^5G","^5H","~$goog.math.IRect","^5J"]]],["^1T","flatland/ordered/map.cljs"],["3a9cb9d79e47d77ecd4f4d550371ecf01464c461","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^58","^5<","~$goog.collections.maps","^Z","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1T","metabase/util/malli/registry.cljc"],["921d4f259bbe54cbeb6b88ae56937df492bdfb5e","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^5Z","^5[","^6O"]]],["^1T","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^51"]]],["^1T","metabase/types/coercion_hierarchies.cljc"],["c3d70ef6080e044d61f13ff6bfd76490e2dcd0ac","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^X"]]],["^1T","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/debug/divconsole.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.debug.HtmlFormatter","~$goog.dom.DomHelper","^5C","^5D","^6H","^5F","^56","^5?","~$goog.style"]]],["^1T","schema/spec/collection.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^67","^68"]]],["^1T","malli/impl/util.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","metabase/lib/schema/order_by.cljc"],["3f577f71e4ecba1aa1061f2228f6026ab45312ff","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^15","^6;","^5Q"]]],["^1T","schema/utils.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1@","^59","^Z","^1C"]]],["^1T","metabase/lib/schema/aggregation.cljc"],["ea4a70903cfc3ffeaa60ebdedb5ea00892da4dbe","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^62","^15","^6;","^10","^5Q"]]],["^1T","cljs/core/match.cljs"],["f419c02deee501e9f4b29f81215ba81ffcefe9b6","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","goog/debug/fancywindow.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^58","^5<","~$goog.debug.DebugWindow","^74","^5C","^5D","^6H","^5F","^56","^59","^Z","^5?","^5L"]]],["^1T","goog/debug/formatter.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.debug","~$goog.debug.RelativeTimeProvider","^6H","^6D","^6J","^56","^5?"]]],["^1T","metabase/shared/util/namespaces.cljs"],["00687008abd6eb291bc9d5ff1fff73210e0bbe6e","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","metabase/mbql/util/match/impl.cljc"],["4150e01975339d308f5cfedda77875eda19c030d","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",[]]],["^1T","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^58","^59"]]],["^1T","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^Z","^69"]]],["^1T","metabase/lib/schema/temporal_bucketing.cljc"],["9cb7bba3e46e1de2fbb37d61df332336da6d9f66","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^X","^5Q"]]],["^1T","metabase/util.cljc"],["2eb945a6741f1450ecac08a9087b862ce52b9e3a","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$camel-snake-kebab.internals.macros","~$clojure.data","^C","^X","^1C","^65","~$flatland.ordered.map","^1?","^10","~$metabase.shared.util.namespaces","~$metabase.util.format","~$metabase.util.log","~$net.cgrand.macrovich","~$weavejester.dependency"]]],["^1T","clojure/test/check/random/longs/bit_count_impl.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","malli/impl/regex.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^66"]]],["^1T","camel_snake_kebab/internals/macros.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$camel-snake-kebab.internals.alter-name","~$camel-snake-kebab.internals.misc"]]],["^1T","metabase/lib/schema/expression/temporal.cljc"],["f1f22c1655e7d335b884a22b010f2b8b08ad1e94","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^X","^5Z","^62","^12","^15","~$metabase.lib.schema.literal","^6;","^6<","^5Q","^5N","^5O"]]],["^1T","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5D","^6J","^5?","^4["]]],["^1T","schema/core.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","^67","^68","~$schema.spec.leaf","~$schema.spec.variant","~$schema.spec.collection"]]],["^1T","metabase/mbql/schema.cljc"],["c51bf2a180ecbc12d6a1cd42a4049323f46a0085","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^5N","^5O","^?","^X","~$metabase.mbql.schema.helpers","~$metabase.mbql.schema.macros","^6S"]]],["^1T","metabase/mbql/util/match.cljs"],["d65aaa9fbcb7960b90ba7ca97258b1dc8a40be2b","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^E","~$metabase.mbql.util.match.impl"]]],["^1T","malli/core.cljc"],["514c6f7d69d7e40b56fa75bfd1a49a683ca15982","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^?","~$malli.impl.regex","^66","^5[","~$malli.sci"]]],["^1T","metabase/lib/schema.cljc"],["122fe4013d55087fc7287141eb7dc6f630436424","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$metabase.lib.schema.aggregation","^12","^15","~$metabase.lib.schema.expression.arithmetic","~$metabase.lib.schema.expression.conditional","~$metabase.lib.schema.expression.string","~$metabase.lib.schema.expression.temporal","~$metabase.lib.schema.filter","^1>","~$metabase.lib.schema.join","^7C","~$metabase.lib.schema.order-by","^6?","~$metabase.lib.schema.template-tag","~$metabase.lib.schema.util","~$metabase.mbql.util.match","^5Q"]]],["^1T","clojure/data.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^X"]]],["^1T","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^4[","^53"]]],["^1T","goog/debug/debug.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^58","~$goog.debug.errorcontext"]]],["^1T","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","schema/spec/core.cljc"],["0dacc3066a87f33088c9a332b6c21e8b0560011c","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^67"]]],["^5M","ttag"],["^4Z","shadow.js.shim.module$ttag.js","require","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/math/coordinate.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.math"]]],["^1T","goog/debug/errorcontext.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.flags"]]],["^1T","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5B","^5C"]]],["^1T","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","^6H","^6A","^6I","^5F","^6D","^5>","^5?","^4["]]],["^1T","goog/debug/debugwindow.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^73","^5D","^6H","^5F","^56","^5?","~$goog.structs.CircularBuffer","^5L"]]],["^1T","metabase/mbql/util.cljc"],["2532d5faa94d2a89dd06e529c641d594e298e2aa","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^1C","~$metabase.mbql.predicates","^6:","^7G","^7V","^10","^6S"]]],["^1T","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.math.Long","~$goog.math.Integer","^Z","^59","^58","^55","^69"]]],["^1T","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5?","^5@","^6B","^5<"]]],["^1T","clojure/test/check/random/longs.cljs"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","~$clojure.test.check.random.longs.bit-count-impl","^80","^?"]]],["^1T","goog/log/log.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","^77"]]],["^1T","camel_snake_kebab/internals/alter_name.cljc"],["5ae08f83ceb8959971e6334596bff0214bf6fdf2","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5?","^6I","^5@","^59","^5<","^4["]]],["^1T","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5K"]]],["^1T","goog/debug/console.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","~$goog.debug.TextFormatter","^56"]]],["^1T","lambdaisland/glogi/print.cljs"],["76286836d4172602aa08006b2a754dda736ffe09","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^6L","^59"]]],["^1T","goog/dom/browserfeature.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5L"]]],["^1T","clojure/set.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","^Z"]]],["^1T","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^5<","^5@"]]],["^1T","metabase/lib/schema/id.cljc"],["7cdfc70702a9a9e04b75ca7c9dc898ddf546f99d","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^12","^6:","^5Q"]]],["^1T","goog/dom/vendor.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^Z","^5L"]]],["^1T","metabase/lib/schema/literal.cljc"],["f8f31bfaef820ab25b896b49fd404b937d0df64e","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^5Z","^12","^15","^6;","^5Q"]]],["^1T","metabase/lib/hierarchy.cljc"],["c9d228603522de5c85546fb645c59736d4eb94d2","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^1T","metabase/mbql/predicates.cljc"],["20ab1a5ccd943c35c646c5f7396ea40f9bfa7ac4","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^6:","^6S"]]],["^1T","clojure/test/check/results.cljc"],["f33d988fd57bc9c11af1952db81c10f319c91416","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?"]]],["^5M","crc-32"],["^O","shadow.js.shim.module$crc_32.js","require","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:"]]],["^1T","metabase/lib/schema/join.cljc"],["924e0ca4abbab776fa05357d6d22bafb8a596648","^4T",["^ ","^4U",null,"^4V",["^H",[]],"^4W",["^1:","^?","^12","^15","^10","^5Q"]]]]],"~:clj-info",["^ ","jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/line_col.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/viz.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/parse.cljc",1689946139000,"jar:file:/root/.m2/repository/weavejester/dependency/0.2.1/dependency-0.2.1.jar!/weavejester/dependency.cljc",1689946093000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/transform.clj",1689946146000,"jar:file:/root/.m2/repository/ring/ring-codec/1.2.0/ring-codec-1.2.0.jar!/ring/util/codec.clj",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/hierarchy.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/pprint.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema/helpers.cljc",1692013156305,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/core.cljc",1689946172000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/shared/util/i18n.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1689947050000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/macros.clj",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n/plural.clj",1690286813000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/core.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/util.cljc",1690286813000,"jar:file:/root/.m2/repository/nano-id/nano-id/1.0.0/nano-id-1.0.0.jar!/nano_id/core.cljc",1689946171000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/dispatch.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/common.cljc",1690286812000,"file:/home/gmrworkspace/dashboard/src/metabase/plugins/classloader.clj",1692013156125,"jar:file:/root/.m2/repository/medley/medley/1.4.0/medley-1.4.0.jar!/medley/core.cljc",1689946185000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/random.clj",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/util/format.cljc",1690286813000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1689947050000,"jar:file:/root/.m2/repository/riddley/riddley/0.2.0/riddley-0.2.0.jar!/riddley/walk.clj",1689946160000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/ref.cljc",1690286812000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/reduction.clj",1689946146000,"jar:file:/root/.m2/repository/org/tcrawley/dynapath/1.1.0/dynapath-1.1.0.jar!/dynapath/util.clj",1689946174000,"jar:file:/root/.m2/repository/camel-snake-kebab/camel-snake-kebab/0.4.3/camel-snake-kebab-0.4.3.jar!/camel_snake_kebab/internals/macros.cljc",1689946178000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match/impl.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/auto_flatten_seq.clj",1689946146000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/core.clj",1689946146000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/generator.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/id.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/core.cache/1.0.225/core.cache-1.0.225.jar!/clojure/core/cache.clj",1689946183000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/expression.cljc",1690286812000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/sci.cljc",1689946170000,"jar:file:/root/.m2/repository/potemkin/potemkin/0.4.6/potemkin-0.4.6.jar!/potemkin/types.clj",1689946176000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/properties.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/math.numeric-tower/0.0.5/math.numeric-tower-0.0.5.jar!/clojure/math/numeric_tower.clj",1689946148000,"jar:file:/root/.m2/repository/net/cgrand/macrovich/0.2.1/macrovich-0.2.1.jar!/net/cgrand/macrovich.cljc",1689946165000,"jar:file:/root/.m2/repository/colorize/colorize/0.1.1/colorize-0.1.1.jar!/colorize/core.clj",1689946104000,"jar:file:/root/.m2/repository/borkdude/dynaload/0.3.5/dynaload-0.3.5.jar!/borkdude/dynaload.cljc",1689946165000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/options.cljc",1692013156125,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1689946092000,"jar:file:/root/.m2/repository/potemkin/potemkin/0.4.6/potemkin-0.4.6.jar!/potemkin.clj",1689946176000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/failure.clj",1689946146000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/variant.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1689946092000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n/impl.clj",1692013156125,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/dependency.cljc",1689946139000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/leaf.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check.cljc",1689946177000,"jar:file:/root/.m2/repository/riddley/riddley/0.2.0/riddley-0.2.0.jar!/riddley/compiler.clj",1689946160000,"jar:file:/root/.m2/repository/org/clojure/core.memoize/1.0.257/core.memoize-1.0.257.jar!/clojure/core/memoize.clj",1689946178000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/destructure.cljc",1689946170000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/print.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/track.cljc",1689946139000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/java.classpath/1.0.0/java.classpath-1.0.0.jar!/clojure/java/classpath.clj",1689946162000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1689947050000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/impl/regex.cljc",1689946170000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/factory.clj",1689946173000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1689946174000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/experimental.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/walk.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1689946174000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/common.cljc",1690286812000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/core.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/generators.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1689947050000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/generate.clj",1689946173000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/experimental/time.cljc",1689946170000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1689946174000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema.cljc",1692013156305,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/parse.clj",1689946173000,"file:/home/gmrworkspace/dashboard/src/metabase/util/i18n.clj",1692013156125,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/cfg.clj",1689946146000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/core.clj",1689946173000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/impl/util.cljc",1689946170000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/registry.cljc",1689946170000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/gll.clj",1689946146000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/instrument.clj",1689946170000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/spec/gen/alpha.cljc",1689947050000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/ref.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1689946092000,"jar:file:/root/.m2/repository/nano-id/nano-id/1.0.0/nano-id-1.0.0.jar!/nano_id/random.cljc",1689946171000,"jar:file:/root/.m2/repository/environ/environ/1.2.0/environ-1.2.0.jar!/environ/core.cljc",1689946163000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/spec/collection.cljc",1689946172000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1689947050000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/repeat.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/results.cljc",1689946177000,"jar:file:/root/.m2/repository/com/lambdaisland/glogi/1.2.164/glogi-1.2.164.jar!/lambdaisland/glogi.clj",1689947043000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1689946092000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/shared/util/namespaces.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/file.clj",1689946139000,"jar:file:/root/.m2/repository/org/clojure/core.match/1.0.1/core.match-1.0.1.jar!/cljs/core/match.clj",1689946174000,"jar:file:/root/.m2/repository/org/clojure/spec.alpha/0.3.218/spec.alpha-0.3.218.jar!/clojure/spec/gen/alpha.clj",1689946117000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/error.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/schema/macros.clj",1690286812000,"jar:file:/root/.m2/repository/prismatic/schema/1.4.1/schema-1.4.1.jar!/schema/utils.cljc",1689946172000,"file:/home/gmrworkspace/dashboard/src/metabase/util/malli/registry.cljc",1690286813000,"file:/home/gmrworkspace/dashboard/src/metabase/config.clj",1692013154929,"file:/home/gmrworkspace/dashboard/src/metabase/util/log.clj",1690286813000,"file:/home/gmrworkspace/dashboard/src/metabase/util/malli.cljc",1690286813000,"jar:file:/root/.m2/repository/org/clojure/test.check/1.1.1/test.check-1.1.1.jar!/clojure/test/check/rose_tree.cljc",1689946177000,"jar:file:/root/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1689946174000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/combinators_source.clj",1689946146000,"jar:file:/root/.m2/repository/instaparse/instaparse/1.4.12/instaparse-1.4.12.jar!/instaparse/abnf.clj",1689946146000,"jar:file:/root/.m2/repository/org/clojure/tools.namespace/1.4.4/tools.namespace-1.4.4.jar!/clojure/tools/namespace/find.clj",1689946139000,"jar:file:/root/.m2/repository/org/tcrawley/dynapath/1.1.0/dynapath-1.1.0.jar!/dynapath/dynamic_classpath.clj",1689946174000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/temporal_bucketing.cljc",1690286812000,"jar:file:/root/.m2/repository/cheshire/cheshire/5.11.0/cheshire-5.11.0.jar!/cheshire/generate_seq.clj",1689946173000,"file:/home/gmrworkspace/dashboard/src/metabase/lib/schema/mbql_clause.cljc",1690286812000,"jar:file:/root/.m2/repository/metosin/malli/0.10.2/malli-0.10.2.jar!/malli/util.cljc",1689946170000,"file:/home/gmrworkspace/dashboard/src/metabase/util/jvm.clj",1692013156125],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","metabase/lib/util.cljc","^7",1,"^8",5,"^9",1,"^:",22],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E"],"^F",null,"^G",["^H",["^I"]],"~:shadow/js-access-properties",["^H",["str"]],"^J","^K","^L",["^ "],"^M",["^ ","^N","^O"],"^R",null,"^S",["^ ","^T","^T","^U","^V","^W","^X","^Y","^Z","^[","^10","^11","^12","~$u","^13","^14","^15","^16","^16","^Z","^Z","^17","^16","^18","^19","^?","^?","^1:","^1:","^1;","^T","^12","^12","^1<","^1=","^15","^15","^1>","^1>","^X","^X","~$m","^1?","^13","^13","^19","^19","^10","^10","^O","^O","^1@","^1@","^V","^V","^1A","^1@","^1B","^1C","^1D","^1>","^1=","^1=","^1C","^1C","^1?","^1?","^1E","^O"],"^1F",["^H",["^1G"]],"~:shadow/js-access-global",["^H",["Uint8Array","RegExp","TextEncoder","Error"]],"^1H",null,"~:defs",["^ ","~$query-stage",["^ ","~:schema",["~:=>",["~:cat","~$LegacyOrPMBQLQuery","~:int"],"~:metabase.lib.schema/stage"],"~:validate!","id48427","~:protocol-inline",null,"^5",["^ ","^;@",["^;A",["^;B","^;C","^;D"],"^;E"],"^;F","id48427","^6","metabase/lib/util.cljc","^:",21,"^8",10,"~:raw-arglists",["^1K",["~$quote",["^1K",[["~$query","~:-","^;C","~$stage-number","~:-","^;D"]]]]],"^7",270,"^9",270,"~:arglists",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"~:doc","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int]\n  Return: :metabase.lib.schema/stage\n          \n\n  Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query."],"^J","^2I","^6","metabase/lib/util.cljc","^:",21,"~:method-params",["^1K",[["^;J","^;K"]]],"~:protocol-impl",null,"~:arglists-meta",["^1K",[null,null]],"^8",1,"~:variadic?",false,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^;C","^;K","~:-","^;D"]]]]],"^7",270,"~:ret-tag",["^H",["~$any","~$clj-nil"]],"^9",270,"~:max-fixed-arity",2,"~:fn-var",true,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"^;M","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int]\n  Return: :metabase.lib.schema/stage\n          \n\n  Fetch a specific `stage` of a query. This handles negative indices as well, e.g. `-1` will return the last stage of\n  the query."],"~$string-byte-count",["^ ","^;@",["^;A",["^;B","~:string"],["^;D",["^ ","~:min",0]]],"^;F","id48448","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^;X"],["^;D",["^ ","^;Y",0]]],"^;F","id48448","~:private",true,"^6","metabase/lib/util.cljc","^:",37,"^8",20,"^;H",["^1K",["^;I",["^1K",[["~$s","~:-","^;X"]]]]],"^7",327,"^9",327,"^;L",["^1K",["^;I",["^1K",[["~$s"]]]]],"^;M","Inputs: [s :- :string]\n  Return: [:int {:min 0}]\n          \n\n  Number of bytes in a string using UTF-8 encoding."],"^;Z",true,"^J","^2<","^6","metabase/lib/util.cljc","^:",37,"^;N",["^1K",[["~$s"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["~$s","~:-","^;X"]]]]],"^7",327,"^;R","~$js","^9",327,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["~$s"]]]]],"^;M","Inputs: [s :- :string]\n  Return: [:int {:min 0}]\n          \n\n  Number of bytes in a string using UTF-8 encoding."],"~$source-table-id",["^ ","^;@",["^;A",["^;B","~:any"],["~:maybe","~:metabase.lib.schema.id/table"]],"^;F","id48500","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<1"],["^<2","^<3"]],"^;F","id48500","^6","metabase/lib/util.cljc","^:",25,"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J"]]]]],"^7",413,"^9",413,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/table]\n          \n\n  If this query has a `:source-table` ID, return it."],"^J","^2?","^6","metabase/lib/util.cljc","^:",25,"^;N",["^1K",[["^;J"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^;J"]]]]],"^7",413,"^;R","^;S","^9",413,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/table]\n          \n\n  If this query has a `:source-table` ID, return it."],"~$clause-of-type?",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",47,"^8",7,"^9",47,"^:",22,"^;L",["^1K",["^;I",["^1K",[["~$clause","~$clause-type"]]]]],"^;M","Returns true if this is a clause."],"^J","^2T","^6","metabase/lib/util.cljc","^:",22,"^;N",["^1K",[["^<5","^<6"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",47,"^;R","~$boolean","^9",47,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<5","^<6"]]]]],"^;M","Returns true if this is a clause."],"~$remove-clause",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",94,"^8",7,"^9",94,"^:",20,"^;L",["^1K",["^;I",["^1K",[["~$stage","~$location","~$target-clause"]]]]],"^;M","Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage."],"^J","^2K","^6","metabase/lib/util.cljc","^:",20,"^;N",["^1K",[["^<9","^<:","^<;"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",94,"^;R",["^H",[null,"~$clj","^;S","^;T"]],"^9",94,"^;U",3,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<9","^<:","^<;"]]]]],"^;M","Remove the `target-clause` in `stage` `location`.\n   If a clause has :lib/uuid equal to the `target-clause` it is removed.\n   If `location` contains no clause with `target-clause` no removal happens.\n   If the the location is empty, dissoc it from stage.\n   For the [:fields] location if only expressions remain, dissoc from stage."],"~$legacy-string-table-id->card-id",["^ ","^;@",["^;A",["^;B","^<1"],["^<2","~:metabase.lib.schema.id/card"]],"^;F","id48493","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<1"],["^<2","^<>"]],"^;F","id48493","^6","metabase/lib/util.cljc","^:",41,"^8",10,"^;H",["^1K",["^;I",["^1K",[["~$table-id"]]]]],"^7",404,"^9",404,"^;L",["^1K",["^;I",["^1K",[["^<?"]]]]],"^;M","Inputs: [table-id]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`."],"^J","^25","^6","metabase/lib/util.cljc","^:",41,"^;N",["^1K",[["^<?"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^<?"]]]]],"^7",404,"^;R",["^H",["~$number","^;T"]],"^9",404,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<?"]]]]],"^;M","Inputs: [table-id]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If `table-id` is a legacy `card__<id>`-style string, parse the `<id>` part to an integer Card ID. Only for legacy\n  queries! You don't need to use this in pMBQL since this is converted automatically by [[metabase.lib.convert]] to\n  `:source-card`."],"~$replace-clause",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",75,"^8",7,"^9",75,"^:",21,"^;L",["^1K",["^;I",["^1K",[["^<9","^<:","^<;","~$new-clause"]]]]],"^;M","Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens."],"^J","^28","^6","metabase/lib/util.cljc","^:",21,"^;N",["^1K",[["^<9","^<:","^<;","^<B"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",75,"^;R",["^H",[null,"^<<","^;S"]],"^9",75,"^;U",4,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<9","^<:","^<;","^<B"]]]]],"^;M","Replace the `target-clause` in `stage` `location` with `new-clause`.\n   If a clause has :lib/uuid equal to the `target-clause` it is swapped with `new-clause`.\n   If `location` contains no clause with `target-clause` no replacement happens."],"~$previous-stage-number",["^ ","^;@",["^;A",["^;B","~:map","^;D"],["^<2",["^;D",["^ ","^;Y",0]]]],"^;F","id48424","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<D","^;D"],["^<2",["^;D",["^ ","^;Y",0]]]],"^;F","id48424","^6","metabase/lib/util.cljc","^:",31,"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^<D","^;K","~:-","^;D"]]]]],"^7",248,"^9",248,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"^;M","Inputs: [query :- :map stage-number :- :int]\n  Return: [:maybe [:int {:min 0}]]\n          \n\n  The index of the previous stage, if there is one. `nil` if there is no previous stage."],"^J","^43","^6","metabase/lib/util.cljc","^:",31,"^;N",["^1K",[["^;J","^;K"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^<D","^;K","~:-","^;D"]]]]],"^7",248,"^;R",["^H",["^<@","^;T"]],"^9",248,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"^;M","Inputs: [query :- :map stage-number :- :int]\n  Return: [:maybe [:int {:min 0}]]\n          \n\n  The index of the previous stage, if there is one. `nil` if there is no previous stage."],"~$ensure-mbql-final-stage",["^ ","^;@",["^;A",["^;B","^<1"],"~:metabase.lib.schema/query"],"^;F","id48438","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<1"],"^<F"],"^;F","id48438","^6","metabase/lib/util.cljc","^:",33,"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J"]]]]],"^7",298,"^9",298,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query]\n  Return: :metabase.lib.schema/query\n          \n\n  Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one."],"^J","^2@","^6","metabase/lib/util.cljc","^:",33,"^;N",["^1K",[["^;J"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^;J"]]]]],"^7",298,"^;R",["^H",["^<<","^;S"]],"^9",298,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query]\n  Return: :metabase.lib.schema/query\n          \n\n  Convert query to a pMBQL (pipeline) query, and make sure the final stage is an `:mbql` one."],"~$next-stage-number",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",261,"^8",7,"^9",261,"^:",24,"^;L",["^1K",["^;I",["^1K",[[["^ ","~:keys",["~$stages"],"^1O","~$_query"],"^;K"]]]]],"^;M","The index of the next stage, if there is one. `nil` if there is no next stage."],"^J","^2A","^6","metabase/lib/util.cljc","^:",24,"^;N",["^1K",[["~$p__48425","^;K"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",261,"^;R",["^H",["^<@","^;T"]],"^9",261,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[[["^ ","^<H",["^<I"],"^1O","^<J"],"^;K"]]]]],"^;M","The index of the next stage, if there is one. `nil` if there is no next stage."],"~$native-query->pipeline",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",127,"^8",8,"^9",127,"^:",30,"^;Z",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means."],"^;Z",true,"^J","^2>","^6","metabase/lib/util.cljc","^:",30,"^;N",["^1K",[["^;J"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",127,"^;R",["^H",["^;S","^;T"]],"^9",127,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Convert a `:type` `:native` QP MBQL query to a pMBQL query. See docstring for [[mbql-query->pipeline]] for an\n  explanation of what this means."],"~$named-expression-clause",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",64,"^8",7,"^9",64,"^:",30,"^;L",["^1K",["^;I",["^1K",[["^<5","~$a-name"]]]]],"^;M","Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value."],"^J","^38","^6","metabase/lib/util.cljc","^:",30,"^;N",["^1K",[["^<5","^<N"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",64,"^;R",["^H",["^<<","^;S"]],"^9",64,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<5","^<N"]]]]],"^;M","Top level expressions must be clauses with :lib/expression-name, so if we get a literal, wrap it in :value."],"^I",["^ ","^J","^3=","^6","metabase/lib/util.cljc","^7",36,"^8",4,"^9",36,"^:",15,"^5",["^ ","^6","metabase/lib/util.cljc","^7",36,"^8",9,"^9",36,"^:",15],"^;M","Exactly like [[clojure.core/format]] but ClojureScript-friendly."],"~$truncate-string-to-byte-count",["^ ","^;@",["^;A",["^;B","^;X",["^;D",["^ ","^;Y",1]]],"^;X"],"^;F","id48456","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^;X",["^;D",["^ ","^;Y",1]]],"^;X"],"^;F","id48456","^;Z",true,"^6","metabase/lib/util.cljc","^:",49,"^8",20,"^;H",["^1K",["^;I",["^1K",[["~$s","~:-","^;X","~$max-length-bytes","~:-",["^;D",["^ ","^;Y",1]]]]]]],"^7",339,"^9",339,"^;L",["^1K",["^;I",["^1K",[["~$s","^<P"]]]]],"^;M","Inputs: [s :- :string max-length-bytes :- [:int {:min 1}]]\n  Return: :string\n          \n\n  Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n  *characters*)."],"^;Z",true,"^J","^2Y","^6","metabase/lib/util.cljc","^:",49,"^;N",["^1K",[["~$s","^<P"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["~$s","~:-","^;X","^<P","~:-",["^;D",["^ ","^;Y",1]]]]]]],"^7",339,"^;R","~$string","^9",339,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["~$s","^<P"]]]]],"^;M","Inputs: [s :- :string max-length-bytes :- [:int {:min 1}]]\n  Return: :string\n          \n\n  Truncate string `s` to `max-length-bytes` UTF-8 bytes (as opposed to truncating to some number of\n  *characters*)."],"~$join-strings-with-conjunction",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",306,"^8",7,"^9",306,"^:",36,"^;L",["^1K",["^;I",["^1K",[["~$conjunction","~$coll"]]]]],"^;M","This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \"and\" [\"X\" \"Y\" \"Z\"])\n  ;; => \"X, Y, and Z\""],"^J","^2=","^6","metabase/lib/util.cljc","^:",36,"^;N",["^1K",[["^<S","^<T"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",306,"^;R",["^H",["^;S","^<Q","^;T"]],"^9",306,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<S","^<T"]]]]],"^;M","This is basically [[clojure.string/join]] but uses commas to join everything but the last two args, which are joined\n  by a string `conjunction`. Uses Oxford commas for > 2 args.\n\n  (join-strings-with-conjunction \"and\" [\"X\" \"Y\" \"Z\"])\n  ;; => \"X, Y, and Z\""],"~$join->pipeline",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",150,"^8",8,"^9",150,"^:",22,"^;Z",true,"^;L",["^1K",["^;I",["^1K",[["~$join"]]]]]],"^;Z",true,"^J","^37","^6","metabase/lib/util.cljc","^:",22,"^;N",["^1K",[["^<V"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",150,"^;R",["^H",[null,"^<<","^;S","^;T"]],"^9",150,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<V"]]]]]],"~$pipeline",["^ ","^;@",["^;A",["^;B","^;C"],"^<1"],"^;F","id48419","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^;C"],"^<1"],"^;F","id48419","^6","metabase/lib/util.cljc","^:",18,"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^;C"]]]]],"^7",222,"^9",222,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query :- LegacyOrPMBQLQuery]\n  Return: :any\n          \n\n  Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)"],"^J","^29","^6","metabase/lib/util.cljc","^:",18,"^;N",["^1K",[["^;J"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^;C"]]]]],"^7",222,"^9",222,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query :- LegacyOrPMBQLQuery]\n  Return: :any\n          \n\n  Ensure that a `query` is in the general shape of a pMBQL query. This doesn't walk the query and fix everything! The\n  goal here is just to make sure we have `:stages` in the correct place and the like. See [[metabase.lib.convert]] for\n  functions that actually ensure all parts of the query match the pMBQL schema (they use this function as part of that\n  process.)"],"~$update-query-stage",["^ ","^;@",["^;A",["^;B","^;C","^;D","^<1",["~:*","^<1"]],"^<F"],"^;F","id48432","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^;C","^;D","^<1",["~:*","^<1"]],"^<F"],"^;F","id48432","^6","metabase/lib/util.cljc","^:",28,"~:top-fn",["^ ","^;Q",true,"~:fixed-arity",3,"^;U",3,"^;N",[["^1K",["^;J","^;K","~$f","~$args"]]],"^;L",["^1K",[["^;J","^;K","~$f","~$&","^<["]]],"^;P",["^1K",[null]]],"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^;C","^;K","~:-","^;D","~$f","~$&","^<["]]]]],"^7",284,"^9",284,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K","~$f","~$&","^<["]]]]],"^;M","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int f & args]\n  Return: :metabase.lib.schema/query\n          \n\n  Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query."],"^J","^3>","^6","metabase/lib/util.cljc","^:",28,"^<Y",["^ ","^;Q",true,"^<Z",3,"^;U",3,"^;N",[["^1K",["^;J","^;K","~$f","^<["]]],"^;L",["^1K",[["^;J","^;K","~$f","~$&","^<["]]],"^;P",["^1K",[null]]],"^;N",[["^1K",["^;J","^;K","~$f","^<["]]],"^;O",null,"^<Z",3,"^;P",["^1K",[null]],"^8",1,"^;Q",true,"~:methods",[["^ ","^<Z",3,"^;Q",true,"~:tag",["^H",["^<<","^;S"]]]],"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^;C","^;K","~:-","^;D","~$f","~$&","^<["]]]]],"^7",284,"^;R","^;S","^9",284,"^;U",3,"^;V",true,"^;L",["^1K",[["^;J","^;K","~$f","~$&","^<["]]],"^;M","Inputs: [query :- LegacyOrPMBQLQuery stage-number :- :int f & args]\n  Return: :metabase.lib.schema/query\n          \n\n  Update a specific `stage-number` of a `query` by doing\n\n    (apply f stage args)\n\n  `stage-number` can be a negative index, e.g. `-1` will update the last stage of the query."],"~$crc32-checksum",["^ ","^;@",["^;A",["^;B","^;X"],["^;X",["^ ","^;Y",8,"~:max",8]]],"^;F","id48466","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^;X"],["^;X",["^ ","^;Y",8,"^=3",8]]],"^;F","id48466","^;Z",true,"^6","metabase/lib/util.cljc","^:",34,"^8",20,"^;H",["^1K",["^;I",["^1K",[["~$s","~:-","^;X"]]]]],"^7",370,"^9",370,"^;L",["^1K",["^;I",["^1K",[["~$s"]]]]],"^;M","Inputs: [s :- :string]\n  Return: [:string {:min 8, :max 8}]\n          \n\n  Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string."],"^;Z",true,"^J","^3Q","^6","metabase/lib/util.cljc","^:",34,"^;N",["^1K",[["~$s"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["~$s","~:-","^;X"]]]]],"^7",370,"^;R","^;S","^9",370,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["~$s"]]]]],"^;M","Inputs: [s :- :string]\n  Return: [:string {:min 8, :max 8}]\n          \n\n  Return a 4-byte CRC-32 checksum of string `s`, encoded as an 8-character hex string."],"~$expression-name",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",58,"^8",7,"^9",58,"^:",22,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause."],"^J","^3Z","^6","metabase/lib/util.cljc","^:",22,"^;N",["^1K",[["^<5"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",58,"^;R",["^H",[null,"^;S","^;T"]],"^9",58,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Returns the :lib/expression-name of `clause`. Returns nil if `clause` is not a clause."],"~$joins->pipeline",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",160,"^8",8,"^9",160,"^:",23,"^;Z",true,"^;L",["^1K",["^;I",["^1K",[["~$joins"]]]]]],"^;Z",true,"^J","^4D","^6","metabase/lib/util.cljc","^:",23,"^;N",["^1K",[["^=6"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",160,"^;R","^<<","^9",160,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^=6"]]]]]],"~$update-legacy-boolean-expression->list",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",140,"^8",8,"^9",140,"^:",46,"^;Z",true,"^;L",["^1K",["^;I",["^1K",[["~$m","~$legacy-key","~$pMBQL-key"]]]]],"^;M","Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`"],"^;Z",true,"^J","^4>","^6","metabase/lib/util.cljc","^:",46,"^;N",["^1K",[["~$m","^=8","^=9"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",140,"^;R",["^H",[null,"^<<","^;S"]],"^9",140,"^;U",3,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["~$m","^=8","^=9"]]]]],"^;M","Updates m with a legacy boolean expression at `legacy-key` into a list with an implied and for pMBQL at `pMBQL-key`"],"~$clause?",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",38,"^8",7,"^9",38,"^:",14,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Returns true if this is a clause."],"^J","^3F","^6","metabase/lib/util.cljc","^:",14,"^;N",["^1K",[["^<5"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",38,"^;R","^<7","^9",38,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Returns true if this is a clause."],"~$truncate-alias",["^ ","^;@",["~:function",["^;A",["^;B","^<1"],["^;X",["^ ","^;Y",1,"^=3",60]]],["^;A",["^;B","~:metabase.lib.schema.common/non-blank-string",["^;D",["^ ","^;Y",0]]],["^;X",["^ ","^;Y",1,"^=3",60]]]],"^;F","id48480","^;G",null,"^5",["^ ","^;@",["^=<",["^;A",["^;B","^<1"],["^;X",["^ ","^;Y",1,"^=3",60]]],["^;A",["^;B","^==",["^;D",["^ ","^;Y",0]]],["^;X",["^ ","^;Y",1,"^=3",60]]]],"^;F","id48480","^6","metabase/lib/util.cljc","^:",24,"^<Y",["^ ","^;Q",false,"^<Z",2,"^;U",2,"^;N",[["~$s"],["~$s","~$max-bytes"]],"^;L",["^1K",[["~$s"],["~$s","^=>"]]],"^;P",["^1K",[null,null]]],"^8",10,"^;H",["^1K",["^;I",["^1K",[["~$s"],["~$s","~:-","^==","^=>","~:-",["^;D",["^ ","^;Y",0]]]]]]],"^7",384,"^9",384,"^;L",["^1K",["^;I",["^1K",[["~$s"],["~$s","^=>"]]]]],"^;M","Inputs: ([s]\n           [s :- :metabase.lib.schema.common/non-blank-string max-bytes :- [:int {:min 0}]])\n  Return: [:string {:min 1, :max 60}]\n          \n\n  Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \"some_really_long_string\" 15) ;   -> \"some_r_8e0f9bc2\"\n    (truncate-alias \"some_really_long_string_2\" 15) ; -> \"some_r_2a3c73eb\""],"^J","^31","^6","metabase/lib/util.cljc","^:",24,"^<Y",["^ ","^;Q",false,"^<Z",2,"^;U",2,"^;N",[["~$s"],["~$s","^=>"]],"^;L",["^1K",[["~$s"],["~$s","^=>"]]],"^;P",["^1K",[null,null]]],"^;N",[["~$s"],["~$s","^=>"]],"^;O",null,"^<Z",2,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^=0",[["^ ","^<Z",1,"^;Q",false,"^=1","^;S"],["^ ","^<Z",2,"^;Q",false,"^=1",["^H",[null,"^<Q"]]]],"^;H",["^1K",["^;I",["^1K",[["~$s"],["~$s","~:-","^==","^=>","~:-",["^;D",["^ ","^;Y",0]]]]]]],"^7",384,"^9",384,"^;U",2,"^;V",true,"^;L",["^1K",[["~$s"],["~$s","^=>"]]],"^;M","Inputs: ([s]\n           [s :- :metabase.lib.schema.common/non-blank-string max-bytes :- [:int {:min 0}]])\n  Return: [:string {:min 1, :max 60}]\n          \n\n  Truncate string `s` if it is longer than [[truncate-alias-max-length-bytes]] and append a hex-encoded CRC-32\n  checksum of the original string. Truncated string is truncated to [[truncate-alias-max-length-bytes]]\n  minus [[truncated-alias-hash-suffix-length]] characters so the resulting string is\n  exactly [[truncate-alias-max-length-bytes]]. The goal here is that two really long strings that only differ at the\n  end will still have different resulting values.\n\n    (truncate-alias \"some_really_long_string\" 15) ;   -> \"some_r_8e0f9bc2\"\n    (truncate-alias \"some_really_long_string_2\" 15) ; -> \"some_r_2a3c73eb\""],"~$canonical-stage-index",["^ ","^;@",["^;A",["^;B","^<D","^;D"],["^;D",["^ ","^;Y",0]]],"^;F","id48421","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<D","^;D"],["^;D",["^ ","^;Y",0]]],"^;F","id48421","^6","metabase/lib/util.cljc","^:",31,"^8",10,"^;H",["^1K",["^;I",["^1K",[[["^ ","^<H",["^<I"],"^1O","^<J"],"~:-","^<D","^;K","~:-","^;D"]]]]],"^7",234,"^9",234,"^;L",["^1K",["^;I",["^1K",[[["^ ","^<H",["^<I"],"^1O","^<J"],"^;K"]]]]],"^;M","Inputs: [{:keys [stages], :as _query} :- :map stage-number :- :int]\n  Return: [:int {:min 0}]\n          \n\n  If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc."],"^J","^2X","^6","metabase/lib/util.cljc","^:",31,"^;N",["^1K",[["~$p__48422","^;K"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[[["^ ","^<H",["^<I"],"^1O","^<J"],"~:-","^<D","^;K","~:-","^;D"]]]]],"^7",234,"^;R",["^H",[null,"^<@"]],"^9",234,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[[["^ ","^<H",["^<I"],"^1O","^<J"],"^;K"]]]]],"^;M","Inputs: [{:keys [stages], :as _query} :- :map stage-number :- :int]\n  Return: [:int {:min 0}]\n          \n\n  If `stage-number` index is a negative number e.g. `-1` convert it to a positive index so we can use `nth` on\n  `stages`. `-1` = the last stage, `-2` = the penultimate stage, etc."],"~$field-clause?",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",53,"^8",7,"^9",53,"^:",20,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Returns true if this is a field clause."],"^J","^3I","^6","metabase/lib/util.cljc","^:",20,"^;N",["^1K",[["^<5"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",53,"^;R","^<7","^9",53,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Returns true if this is a field clause."],"~$->stage-metadata",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",163,"^8",7,"^9",163,"^:",23,"^;L",["^1K",["^;I",["^1K",[["~$source-metadata"]]]]],"^;M","Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]]."],"^J","^4:","^6","metabase/lib/util.cljc","^:",23,"^;N",["^1K",[["^=C"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",163,"^;R",["^H",["^<<","^;S","^;T"]],"^9",163,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^=C"]]]]],"^;M","Convert legacy `:source-metadata` to [[metabase.lib.metadata/StageMetadata]]."],"~$with-default-effective-type",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",482,"^8",7,"^9",482,"^:",34,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Adds a default :effective-type property if it does not exist and\n  :base-type is known.\n\n  This is needed only because we have to convert queries to the Legacy\n  form.\n  The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n  :effective-type property, but it should be present for the frontend\n  to work. It defaults to the :base-type property."],"^J","^4C","^6","metabase/lib/util.cljc","^:",34,"^;N",["^1K",[["^<5"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",482,"^;R",["^H",[null,"^<<","^;S","^;T"]],"^9",482,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^<5"]]]]],"^;M","Adds a default :effective-type property if it does not exist and\n  :base-type is known.\n\n  This is needed only because we have to convert queries to the Legacy\n  form.\n  The round trip conversion pMBQL -> legacy MBQL -> pMBQL loses the\n  :effective-type property, but it should be present for the frontend\n  to work. It defaults to the :base-type property."],"~$add-summary-clause",["^ ","^;@",["^;A",["^;B","^<F","^;D",["~:enum","~:breakout","~:aggregation"],"^<1"],"^<F"],"^;F","id48524","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<F","^;D",["^=F","^=G","^=H"],"^<1"],"^<F"],"^;F","id48524","^6","metabase/lib/util.cljc","^:",28,"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^<F","^;K","~:-","^;D","^<:","~:-",["^=F","^=G","^=H"],"~$a-summary-clause"]]]]],"^7",454,"^9",454,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K","^<:","^=I"]]]]],"^;M","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int location :- [:enum :breakout :aggregation] a-summary-clause]\n  Return: :metabase.lib.schema/query\n          \n\n  If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages."],"^J","^4A","^6","metabase/lib/util.cljc","^:",28,"^;N",["^1K",[["^;J","^;K","^<:","^=I"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^;J","~:-","^<F","^;K","~:-","^;D","^<:","~:-",["^=F","^=G","^=H"],"^=I"]]]]],"^7",454,"^;R",["^H",["^<<","^;S"]],"^9",454,"^;U",4,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K","^<:","^=I"]]]]],"^;M","Inputs: [query :- :metabase.lib.schema/query stage-number :- :int location :- [:enum :breakout :aggregation] a-summary-clause]\n  Return: :metabase.lib.schema/query\n          \n\n  If the given stage has no summary, it will drop :fields, :order-by, and :join :fields from it,\n   as well as any subsequent stages."],"~$strip-id",["^ ","^;@",["^;A",["^;B","^;X"],"^;X"],"^;F","id48521","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^;X"],"^;X"],"^;F","id48521","^6","metabase/lib/util.cljc","^:",18,"^8",10,"^;H",["^1K",["^;I",["^1K",[["~$display-name","~:-","^;X"]]]]],"^7",446,"^9",446,"^;L",["^1K",["^;I",["^1K",[["^=K"]]]]],"^;M","Inputs: [display-name :- :string]\n  Return: :string\n          \n\n  Given a display name string like \"Product ID\", this will drop the trailing \"ID\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining."],"^J","^4=","^6","metabase/lib/util.cljc","^:",18,"^;N",["^1K",[["^=K"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^=K","~:-","^;X"]]]]],"^7",446,"^;R","^<Q","^9",446,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^=K"]]]]],"^;M","Inputs: [display-name :- :string]\n  Return: :string\n          \n\n  Given a display name string like \"Product ID\", this will drop the trailing \"ID\" and trim whitespace.\n  Used to turn a FK field's name into a pseudo table name when implicitly joining."],"~$truncate-alias-max-length-bytes",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",360,"^8",16,"^9",360,"^:",47,"^;Z",true],"^;Z",true,"^J","^4Q","^6","metabase/lib/util.cljc","^:",47,"^8",1,"^7",360,"^9",360,"^=1","^<@","^;M","Length to truncate column and table identifiers to. See [[metabase.driver.impl/default-alias-max-length-bytes]] for\n  reasoning."],"~$source-card-id",["^ ","^;@",["^;A",["^;B","^<1"],["^<2","^<>"]],"^;F","id48507","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<1"],["^<2","^<>"]],"^;F","id48507","^6","metabase/lib/util.cljc","^:",24,"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J"]]]]],"^7",418,"^9",418,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If this query has a `:source-card` ID, return it."],"^J","^4L","^6","metabase/lib/util.cljc","^:",24,"^;N",["^1K",[["^;J"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^;J"]]]]],"^7",418,"^;R","^;S","^9",418,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Inputs: [query]\n  Return: [:maybe :metabase.lib.schema.id/card]\n          \n\n  If this query has a `:source-card` ID, return it."],"~$inner-query->stages",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",178,"^8",8,"^9",178,"^:",27,"^;Z",true,"^;L",["^1K",["^;I",["^1K",[[["^ ","^<H",["~$source-query","^=C"],"^1O","~$inner-query"]]]]]]],"^;Z",true,"^J","^41","^6","metabase/lib/util.cljc","^:",27,"^;N",["^1K",[["~$p__48403"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",178,"^;R","^<<","^9",178,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[[["^ ","^<H",["^=O","^=C"],"^1O","^=P"]]]]]]],"~$unique-name-generator",["^ ","^;@",["^;A","^;B",["^;A",["^;B","^=="],"^=="]],"^;F","id48517","^;G",null,"^5",["^ ","^;@",["^;A","^;B",["^;A",["^;B","^=="],"^=="]],"^;F","id48517","^6","metabase/lib/util.cljc","^:",31,"^8",10,"^;H",["^1K",["^;I",["^1K",[[]]]]],"^7",423,"^9",423,"^;L",["^1K",["^;I",["^1K",[[]]]]],"^;M","Inputs: []\n  Return: [:=> [:cat :metabase.lib.schema.common/non-blank-string] :metabase.lib.schema.common/non-blank-string]\n          \n\n  Create a new function with the signature\n\n    (f str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash)."],"^J","^2E","^6","metabase/lib/util.cljc","^:",31,"^;N",["^1K",[[]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[[]]]]],"^7",423,"^;R","~$function","^9",423,"^;U",0,"^;V",true,"^;L",["^1K",["^;I",["^1K",[[]]]]],"^;M","Inputs: []\n  Return: [:=> [:cat :metabase.lib.schema.common/non-blank-string] :metabase.lib.schema.common/non-blank-string]\n          \n\n  Create a new function with the signature\n\n    (f str) => str\n\n  That takes any sort of string identifier (e.g. a column alias or table/join alias) and returns a guaranteed-unique\n  name truncated to 60 characters (actually 51 characters plus a hash)."],"~$mbql-query->pipeline",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",199,"^8",8,"^9",199,"^:",28,"^;Z",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information."],"^;Z",true,"^J","^4<","^6","metabase/lib/util.cljc","^:",28,"^;N",["^1K",[["^;J"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",199,"^;R",["^H",["^;S","^;T"]],"^9",199,"^;U",1,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J"]]]]],"^;M","Convert a `:type` `:query` QP MBQL (i.e., MBQL as currently understood by the Query Processor, or the JS MLv1) to a\n  pMBQL query. The key difference is that instead of having a `:query` with a `:source-query` with a `:source-query`\n  and so forth, you have a vector of `:stages` where each stage serves as the source query for the next stage.\n  Initially this was an implementation detail of a few functions, but it's easier to visualize and manipulate, so now\n  all of MLv2 deals with pMBQL. See this Slack thread\n  https://metaboat.slack.com/archives/C04DN5VRQM6/p1677118410961169?thread_ts=1677112778.742589&cid=C04DN5VRQM6 for\n  more information."],"~$first-stage?",["^ ","^;G",null,"^5",["^ ","^6","metabase/lib/util.cljc","^7",256,"^8",7,"^9",256,"^:",19,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"^;M","Whether a `stage-number` is referring to the first stage of a query or not."],"^J","^4N","^6","metabase/lib/util.cljc","^:",19,"^;N",["^1K",[["^;J","^;K"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^7",256,"^;R","^<7","^9",256,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"^;M","Whether a `stage-number` is referring to the first stage of a query or not."],"~$strip-id-regex",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",441,"^8",16,"^9",441,"^:",30,"^;Z",true],"^;Z",true,"^J","^4H","^6","metabase/lib/util.cljc","^:",30,"^8",1,"^7",441,"^9",441,"^=1","^;["],"^;C",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",212,"^8",6,"^9",212,"^:",24],"^J","^3N","^6","metabase/lib/util.cljc","^:",24,"^8",1,"^7",212,"^9",212,"^=1","~$cljs.core/IVector","^;M","Schema for a map that is either a legacy query OR a pMBQL query."],"~$previous-stage",["^ ","^;@",["^;A",["^;B","^<1","^;D"],["^<2","^;E"]],"^;F","id48430","^;G",null,"^5",["^ ","^;@",["^;A",["^;B","^<1","^;D"],["^<2","^;E"]],"^;F","id48430","^6","metabase/lib/util.cljc","^:",24,"^8",10,"^;H",["^1K",["^;I",["^1K",[["^;J","^;K","~:-","^;D"]]]]],"^7",278,"^9",278,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"^;M","Inputs: [query stage-number :- :int]\n  Return: [:maybe :metabase.lib.schema/stage]\n          \n\n  Return the previous stage of the query, if there is one; otherwise return `nil`."],"^J","^4B","^6","metabase/lib/util.cljc","^:",24,"^;N",["^1K",[["^;J","^;K"]]],"^;O",null,"^;P",["^1K",[null,null]],"^8",1,"^;Q",false,"^;H",["^1K",["^;I",["^1K",[["^;J","^;K","~:-","^;D"]]]]],"^7",278,"^;R",["^H",["^;S","^;T"]],"^9",278,"^;U",2,"^;V",true,"^;L",["^1K",["^;I",["^1K",[["^;J","^;K"]]]]],"^;M","Inputs: [query stage-number :- :int]\n  Return: [:maybe :metabase.lib.schema/stage]\n          \n\n  Return the previous stage of the query, if there is one; otherwise return `nil`."],"~$truncated-alias-hash-suffix-length",["^ ","^5",["^ ","^6","metabase/lib/util.cljc","^7",365,"^8",16,"^9",365,"^:",50,"^;Z",true],"^;Z",true,"^J","^3K","^6","metabase/lib/util.cljc","^:",50,"^8",1,"^7",365,"^9",365,"^=1","^<@","^;M","Length of the hash suffixed to truncated strings by [[truncate-alias]]."]],"^1I",["^ ","^U","^V","^[","^10","~$u","^13","^14","^15","^18","^19","^?","^?","^15","^15","^13","^13","^19","^19","^10","^10","^V","^V"],"~:cljs.analyzer/constants",["^ ","^1F",["^H",["^=F","~:lib/uuid","~:name-key-fn","~:lib/type","~:lib/expression-name","~:metadata/column","~:base-type","~:expression","~:stages","~:else","~:source-query","~:filters","~:columns","~:value","~:or","~:fields","~:mbql/query","~:lib/stage-metadata","~:joins","~:source-metadata","~:field","~:type","~:mbql/join","~:effective-type","~:metadata/results","~:mbql.stage/native","~:filter","~:native","~:conditions","~:condition","~:source-table","~:expressions","^=G","~:error/message","~:order-by","~:mbql.stage/mbql","~:and","^=H","~:source-card","~:query","~:unique-alias-fn","~:=","^<D","~:always","~:num-stages"]],"~:order",["^=[","^>B","^>2","^>;","^>E","^>M","^>=","^>5","^>@","^>J","^>7","^>1","^>6","^>>","^>G","^>I","^>S","^>C","^>Q","^>L","^>8","^>K","^>D","^>:","^>3","^>F","^>A","^>?","^>P","^>U","^>H","^>9","^><","^<D","^>N","^=F","~:=","^>V","^>R","^>0","^>T","^=H","^=G","^>O","^>4"]],"^1P",["^ ","^1G",["^H",[]]],"^1Q",["^ ","^N",["^ ","^1O","^1E"]],"^1R",["^1:","^?","^O","^Z","^1@","^X","^1C","^1?","^19","^1=","^T","^12","^15","^1>","^16","^10","^13","^V"]],"^Q","^K","~:ns-specs",["^ "],"~:ns-spec-vars",["^H",[]],"~:compiler-options",["^4S",[["^>Z","~:static-fns"],true,["^>Z","~:shadow-tweaks"],null,["^>Z","~:source-map-inline"],null,["^>Z","~:elide-asserts"],true,["^>Z","~:optimize-constants"],null,["^>Z","^1W"],null,["^>Z","~:external-config"],null,["^>Z","~:tooling-config"],null,["^>Z","~:emit-constants"],null,["^>Z","~:load-tests"],false,["^>Z","~:form-size-threshold"],null,["^>Z","~:global-goog-object&array"],null,["^>Z","~:data-readers"],null,["^>Z","~:infer-externs"],"~:auto",["^>Z","^1Y"],["^H",["^1Z"]],["~:js-options","~:js-provider"],"^1G",["~:mode"],"~:release",["^>Z","~:fn-invoke-direct"],null,["^>Z","~:source-map"],null]]]