["^ ","~:output",["^ ","~:js","goog.provide('metabase.mbql.util.match');\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","metabase/mbql/util/match.cljs","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",29],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha","~$clojure.pprint","~$cljs.pprint","~$clojure.core.match","~$cljs.core.match"],"~:use-macros",null,"~:excludes",["~#set",["~$replace"]],"~:macros",["^ ","~$match*",["^ ","~:arglists",["~#list",[["~$form","~$patterns-and-results"]]],"~:doc","Internal impl for `match`. Generate a pattern-matching function using `core.match`, and call it with `form`.","^7",88,"^8",1,"^6","metabase/mbql/util/match.clj","~:name","~$metabase.mbql.util.match/match*","~:ns","~$metabase.mbql.util.match","~:macro",true],"~$match",["^ ","^S","^T","^Q","~$metabase.mbql.util.match/match","^6","metabase/mbql/util/match.clj","^8",1,"^7",103,"^U",true,"~:style/indent",1,"^L",["^M",[["~$x","~$&","^O"]]],"^P","Return a sequence of things that match a `pattern` or `patterns` inside `x`, presumably a query, returning `nil` if\n  there are no matches. Recurses through maps and sequences. `pattern` can be one of several things:\n\n  *  Keyword name of an MBQL clause\n  *  Set of keyword names of MBQL clauses. Matches any clauses with those names\n  *  A `core.match` pattern\n  *  A symbol naming a class.\n  *  A symbol naming a predicate function\n  *  `_`, which will match anything\n\n  Examples:\n\n    ;; keyword pattern\n    (match {:fields [[:field 10 nil]]} :field) ; -> [[:field 10 nil]]\n\n    ;; set of keywords\n    (match some-query #{:field :expression}) ; -> [[:field 10 nil], [:expression \"wow\"], ...]\n\n    ;; `core.match` patterns:\n    ;; match any `:field` clause with two args (which should be all of them)\n    (match some-query [:field _ _])\n    ;; match any `:field` clause with integer ID > 100\n    (match some-query [:field (_ :guard (every-pred integer? #(> % 100)))]) ; -> [[:field 200 nil], ...]\n\n    ;; symbol naming a Class\n    ;; match anything that is an instance of that class\n    (match some-query java.util.Date) ; -> [[#inst \"2018-10-08\", ...]\n\n    ;; symbol naming a predicate function\n    ;; match anything that satisfies that predicate\n    (match some-query (every-pred integer? even?)) ; -> [2 4 6 8]\n\n    ;; match anything with `_`\n    (match 100 `_`) ; -> 100\n\n\n  ### Using `core.match` patterns\n\n  See [`core.match` documentation](`https://github.com/clojure/core.clojure.core.match/wiki/Overview`) for more details.\n\n  Pattern-matching works almost exactly the way it does when using `core.match**` directly, with a few\n  differences:\n\n  *  `mbql.util/match` returns a sequence of everything that matches, rather than the first match it finds\n\n  *  patterns are automatically wrapped in vectors for you when appropriate\n\n  *  things like keywords and classes are automatically converted to appropriate patterns for you\n\n  *  this macro automatically recurses through sequences and maps as a final `:else` clause. If you don't want to\n     automatically recurse, use a catch-all pattern (such as `_`). Our macro implementation will optimize out this\n     `:else` clause if the last pattern is `_`\n\n  ### Returing something other than the exact match with result body\n\n  By default, `match` returns whatever matches the pattern you pass in. But what if you only want to return part of\n  the match? You can, using `core.match` binding facilities. Bind relevant things in your pattern and pass in the\n  optional result body. Whatever result body returns will be returned by `match`:\n\n     ;; just return the IDs of Field ID clauses\n     (match some-query [:field (id :guard integer?) _] id) ; -> [1 2 3]\n\n  You can also use result body to filter results; any `nil` values will be skipped:\n\n    (match some-query [:field (id :guard integer?) _]\n      (when (even? id)\n        id))\n    ;; -> [2 4 6 8]\n\n  Of course, it's more efficient to let `core.match` compile an efficient matching function, so prefer using\n  patterns with `:guard` where possible.\n\n  You can also call `recur` inside result bodies, to use the same matching logic against a different value.\n\n  ### `&match` and `&parents` anaphors\n\n  For more advanced matches, like finding a `:field` clauses nested anywhere inside another clause, `match` binds a\n  pair of anaphors inside the result body for your convenience. `&match` is bound to the entire match, regardless of\n  how you may have destructured it; `&parents` is bound to a sequence of keywords naming the parent top-level keys and\n  clauses of the match.\n\n    (mbql.u/match {:filter [:time-interval [:field 1 nil] :current :month]} :field\n      ;; &parents will be [:filter :time-interval]\n      (when (contains? (set &parents) :time-interval)\n        &match))\n    ;; -> [[:field 1 nil]]"],"^I",["^ ","^S","^T","^Q","~$metabase.mbql.util.match/replace","^6","metabase/mbql/util/match.clj","^8",1,"^7",229,"^U",true,"^X",1,"^L",["^M",[["~$x","~$&","^O"]]],"^P","Like `match`, but replace matches in `x` with the results of result body. The same pattern options are supported,\n  and `&parents` and `&match` anaphors are available in the same way. (`&match` is particularly useful here if you\n  want to use keywords or sets of keywords as patterns.)"],"~$replace*",["^ ","^L",["^M",[["^N","^O"]]],"^P","Internal implementation for `replace`. Generate a pattern-matching function with `core.match`, and use it to replace\n  matching values in `form`.","^7",216,"^8",1,"^6","metabase/mbql/util/match.clj","^Q","~$metabase.mbql.util.match/replace*","^S","^T","^U",true],"~$match-one",["^ ","^S","^T","^Q","~$metabase.mbql.util.match/match-one","^6","metabase/mbql/util/match.clj","^8",1,"^7",197,"^U",true,"^X",1,"^L",["^M",[["~$x","~$&","^O"]]],"^P","Like `match` but returns a single match rather than a sequence of matches."],"~$match**",["^ ","^L",["^M",[["~$&","~$args"]]],"^P","Internal impl for `match` and `replace` macros.","^7",81,"^8",1,"^6","metabase/mbql/util/match.clj","^Q","~$metabase.mbql.util.match/match**","^S","^T","^U",true],"~$replace-in",["^ ","^S","^T","^Q","~$metabase.mbql.util.match/replace-in","^6","metabase/mbql/util/match.clj","^8",1,"^7",239,"^U",true,"^X",2,"^L",["^M",[["~$x","~$ks","~$&","^O"]]],"^P","Like `replace`, but only replaces things in the part of `x` in the keypath `ks` (i.e. the way to `update-in` works.)"]],"^Q","^T","~:reader-aliases",["^ "],"~:op","^S","~:imports",null,"~:requires",["^ ","^D","^E","~$metabase.mbql.util.match.impl","^1<","^?","^?","~$goog","^1=","^E","^E"],"~:seen",["^H",["~:require","~:require-macros"]],"~:uses",null,"^1@",["^ ","^T","^T","^?","^?","^D","^E","^E","^E"],"~:form",["^M",["~$ns","^T",["^M",["~:refer-clojure","~:exclude",["^I"]]],["^M",["^1?",["^D"],["^1<"]]],["^M",["^1@",["^T"]]]]],"~:flags",["^ ","^1?",["^H",[]],"^1@",["^H",[]]],"~:js-deps",["^ "],"~:deps",["^1=","^?","^E","^1<"]],"^S","^T","~:resource-id",["~:shadow.build.classpath/resource","metabase/mbql/util/match.cljs"],"~:compiled-at",1692612526546,"^18",["^ ","^D","^E","^1<","^1<","^?","^?","^1=","^1=","^E","^E","^T","^T"],"~:resource-name","metabase/mbql/util/match.cljs","~:warnings",[],"~:source","(ns metabase.mbql.util.match\n  (:refer-clojure :exclude [replace])\n  (:require\n   [clojure.core.match]\n   [metabase.mbql.util.match.impl])\n  (:require-macros [metabase.mbql.util.match]))\n\n(comment clojure.core.match/keep-me\n         metabase.mbql.util.match/keep-me\n         metabase.mbql.util.match.impl/keep-me)\n","~:reader-features",["^H",["~:cljs-release","~:cljs"]],"~:cljc",false,"~:source-map-compact",["^ ","mappings",";AAOA","names",[]],"~:used-vars",["^H",[]]],"~:cache-keys",["~#cmap",[["^1J","goog/dom/tagname.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^H",[]],"~:deps-syms",["^1=","~$goog.dom.HtmlElement"]]],["^1J","goog/html/trustedtypes.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/labs/useragent/browser.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.asserts","~$goog.string.internal","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^1J","goog/html/safeurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^25"]]],["^1J","goog/array/array.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24"]]],["^1J","goog/debug/error.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/flags/flags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/dom/nodetype.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/labs/useragent/highentropy/highentropyvalue.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^22","^25"]]],["^1J","goog/string/typedstring.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/object/object.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/dom/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24"]]],"~:SHADOW-TIMESTAMP",[1689947046000,1689947046000,1689947050000],["^1J","goog/math/long.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24","~$goog.reflect"]]],["^1J","goog/html/trustedresourceurl.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24","~$goog.fs.blob","^28","~$goog.html.SafeScript","~$goog.html.trustedtypes","^2:","^2;"]]],["^1J","goog/string/internal.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/functions/functions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/html/safestyle.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2:","~$goog.html.SafeUrl","^2;","^24","^25"]]],["^1J","goog/dom/safe.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^2?","~$goog.html.SafeStyle","^2A","^29","~$goog.html.uncheckedconversions","^2:","^25"]]],["^1J","goog/asserts/dom.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","~$goog.dom.TagName","^24","~$goog.dom.element"]]],["^1J","goog/html/safehtml.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2:","^2?","^2F","~$goog.html.SafeStyleSheet","^2A","^2H","^29","^2;","^24","~$goog.labs.userAgent.browser","~$goog.array","~$goog.object","^25","~$goog.dom.tags","^2@"]]],["^1J","goog/dom/tags.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2M"]]],["^1J","goog/fs/blob.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/asserts/asserts.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1J","goog/uri/uri.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2L","^24","~$goog.collections.maps","~$goog.string","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1J","goog/labs/useragent/highentropy/highentropydata.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^23"]]],["^1J","goog/collections/maps.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","cljs/core/match.cljs"],["f419c02deee501e9f4b29f81215ba81ffcefe9b6","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^?"]]],["^1J","metabase/mbql/util/match/impl.cljc"],["4150e01975339d308f5cfedda77875eda19c030d","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^?"]]],["^1J","goog/fs/url.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/base.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",[]]],["^1J","goog/structs/structs.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2L","^2M"]]],["^1J","goog/string/string.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","~$goog.dom.safe","^2G","^2:","^25"]]],["^1J","metabase/mbql/util/match.cljs"],["d65aaa9fbcb7960b90ba7ca97258b1dc8a40be2b","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^?","^E","^1<"]]],["^1J","goog/reflect/reflect.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/labs/useragent/util.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^25","^27"]]],["^1J","goog/string/stringbuffer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","goog/labs/useragent/useragent.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","~$goog.flags"]]],["^1J","goog/dom/element.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2P","^2H"]]],["^1J","goog/html/uncheckedconversions.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24","^2E","^2?","^2F","^2J","^2A","^29","^2:","^25"]]],["^1J","goog/dom/htmlelement.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1="]]],["^1J","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","~$goog.math.Long","~$goog.math.Integer","^2R","^2M","^2L","~$goog.Uri","~$goog.string.StringBuffer"]]],["^1J","goog/html/safescript.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2:","^2;","^2@","^24"]]],["^1J","goog/html/safestylesheet.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2:","^2F","^2;","^2M","^24","^25"]]],["^1J","goog/math/integer.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^2="]]],["^1J","goog/uri/utils.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24","^2R"]]],["^1J","goog/string/const.js"],["533ce2bdbb7925db781449abb6527af1e6c5e782","^1Y",["^ ","^1Z",null,"^1[",["^H",[]],"^20",["^1=","^24","^2;"]]]]],"~:clj-info",["^ ","jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match.clj",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1689947050000,"file:/home/gmrworkspace/dashboard/shared/src/metabase/mbql/util/match/impl.cljc",1690286812000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1689946092000,"jar:file:/root/.m2/repository/net/cgrand/macrovich/0.2.1/macrovich-0.2.1.jar!/net/cgrand/macrovich.cljc",1689946165000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/walk.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1689947050000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1689946092000,"jar:file:/root/.m2/repository/org/clojure/core.match/1.0.1/core.match-1.0.1.jar!/cljs/core/match.clj",1689946174000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","metabase/mbql/util/match.cljs","^7",1,"^8",5,"^9",1,"^:",29],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E"],"^F",null,"^G",["^H",["^I"]],"^J",["^ ","^K",["^ ","^L",["^M",[["^N","^O"]]],"^P","Internal impl for `match`. Generate a pattern-matching function using `core.match`, and call it with `form`.","^7",88,"^8",1,"^6","metabase/mbql/util/match.clj","^Q","^R","^S","^T","^U",true],"^V",["^ ","^S","^T","^Q","^W","^6","metabase/mbql/util/match.clj","^8",1,"^7",103,"^U",true,"^X",1,"^L",["^M",[["~$x","~$&","^O"]]],"^P","Return a sequence of things that match a `pattern` or `patterns` inside `x`, presumably a query, returning `nil` if\n  there are no matches. Recurses through maps and sequences. `pattern` can be one of several things:\n\n  *  Keyword name of an MBQL clause\n  *  Set of keyword names of MBQL clauses. Matches any clauses with those names\n  *  A `core.match` pattern\n  *  A symbol naming a class.\n  *  A symbol naming a predicate function\n  *  `_`, which will match anything\n\n  Examples:\n\n    ;; keyword pattern\n    (match {:fields [[:field 10 nil]]} :field) ; -> [[:field 10 nil]]\n\n    ;; set of keywords\n    (match some-query #{:field :expression}) ; -> [[:field 10 nil], [:expression \"wow\"], ...]\n\n    ;; `core.match` patterns:\n    ;; match any `:field` clause with two args (which should be all of them)\n    (match some-query [:field _ _])\n    ;; match any `:field` clause with integer ID > 100\n    (match some-query [:field (_ :guard (every-pred integer? #(> % 100)))]) ; -> [[:field 200 nil], ...]\n\n    ;; symbol naming a Class\n    ;; match anything that is an instance of that class\n    (match some-query java.util.Date) ; -> [[#inst \"2018-10-08\", ...]\n\n    ;; symbol naming a predicate function\n    ;; match anything that satisfies that predicate\n    (match some-query (every-pred integer? even?)) ; -> [2 4 6 8]\n\n    ;; match anything with `_`\n    (match 100 `_`) ; -> 100\n\n\n  ### Using `core.match` patterns\n\n  See [`core.match` documentation](`https://github.com/clojure/core.clojure.core.match/wiki/Overview`) for more details.\n\n  Pattern-matching works almost exactly the way it does when using `core.match**` directly, with a few\n  differences:\n\n  *  `mbql.util/match` returns a sequence of everything that matches, rather than the first match it finds\n\n  *  patterns are automatically wrapped in vectors for you when appropriate\n\n  *  things like keywords and classes are automatically converted to appropriate patterns for you\n\n  *  this macro automatically recurses through sequences and maps as a final `:else` clause. If you don't want to\n     automatically recurse, use a catch-all pattern (such as `_`). Our macro implementation will optimize out this\n     `:else` clause if the last pattern is `_`\n\n  ### Returing something other than the exact match with result body\n\n  By default, `match` returns whatever matches the pattern you pass in. But what if you only want to return part of\n  the match? You can, using `core.match` binding facilities. Bind relevant things in your pattern and pass in the\n  optional result body. Whatever result body returns will be returned by `match`:\n\n     ;; just return the IDs of Field ID clauses\n     (match some-query [:field (id :guard integer?) _] id) ; -> [1 2 3]\n\n  You can also use result body to filter results; any `nil` values will be skipped:\n\n    (match some-query [:field (id :guard integer?) _]\n      (when (even? id)\n        id))\n    ;; -> [2 4 6 8]\n\n  Of course, it's more efficient to let `core.match` compile an efficient matching function, so prefer using\n  patterns with `:guard` where possible.\n\n  You can also call `recur` inside result bodies, to use the same matching logic against a different value.\n\n  ### `&match` and `&parents` anaphors\n\n  For more advanced matches, like finding a `:field` clauses nested anywhere inside another clause, `match` binds a\n  pair of anaphors inside the result body for your convenience. `&match` is bound to the entire match, regardless of\n  how you may have destructured it; `&parents` is bound to a sequence of keywords naming the parent top-level keys and\n  clauses of the match.\n\n    (mbql.u/match {:filter [:time-interval [:field 1 nil] :current :month]} :field\n      ;; &parents will be [:filter :time-interval]\n      (when (contains? (set &parents) :time-interval)\n        &match))\n    ;; -> [[:field 1 nil]]"],"^I",["^ ","^S","^T","^Q","^Y","^6","metabase/mbql/util/match.clj","^8",1,"^7",229,"^U",true,"^X",1,"^L",["^M",[["~$x","~$&","^O"]]],"^P","Like `match`, but replace matches in `x` with the results of result body. The same pattern options are supported,\n  and `&parents` and `&match` anaphors are available in the same way. (`&match` is particularly useful here if you\n  want to use keywords or sets of keywords as patterns.)"],"^Z",["^ ","^L",["^M",[["^N","^O"]]],"^P","Internal implementation for `replace`. Generate a pattern-matching function with `core.match`, and use it to replace\n  matching values in `form`.","^7",216,"^8",1,"^6","metabase/mbql/util/match.clj","^Q","^[","^S","^T","^U",true],"^10",["^ ","^S","^T","^Q","^11","^6","metabase/mbql/util/match.clj","^8",1,"^7",197,"^U",true,"^X",1,"^L",["^M",[["~$x","~$&","^O"]]],"^P","Like `match` but returns a single match rather than a sequence of matches."],"^12",["^ ","^L",["^M",[["~$&","^13"]]],"^P","Internal impl for `match` and `replace` macros.","^7",81,"^8",1,"^6","metabase/mbql/util/match.clj","^Q","^14","^S","^T","^U",true],"^15",["^ ","^S","^T","^Q","^16","^6","metabase/mbql/util/match.clj","^8",1,"^7",239,"^U",true,"^X",2,"^L",["^M",[["~$x","^17","~$&","^O"]]],"^P","Like `replace`, but only replaces things in the part of `x` in the keypath `ks` (i.e. the way to `update-in` works.)"]],"^Q","^T","^18",["^ "],"^1:",null,"^1;",["^ ","^D","^E","^1<","^1<","^?","^?","^1=","^1=","^E","^E"],"^1>",["^H",["^1?","^1@"]],"^1A",null,"^1@",["^ ","^T","^T","^?","^?","^D","^E","^E","^E"],"^1F",["^ ","^1?",["^H",[]],"^1@",["^H",[]]],"^1G",["^ "],"^1H",["^1=","^?","^E","^1<"]],"^S","^T","~:ns-specs",["^ "],"~:ns-spec-vars",["^H",[]],"~:compiler-options",["^1X",[["^3W","~:static-fns"],true,["^3W","~:shadow-tweaks"],null,["^3W","~:source-map-inline"],null,["^3W","~:elide-asserts"],true,["^3W","~:optimize-constants"],null,["^3W","^1M"],null,["^3W","~:external-config"],null,["^3W","~:tooling-config"],null,["^3W","~:emit-constants"],null,["^3W","~:load-tests"],false,["^3W","~:form-size-threshold"],null,["^3W","~:global-goog-object&array"],null,["^3W","~:data-readers"],null,["^3W","~:infer-externs"],"~:auto",["^3W","^1O"],["^H",["^1P"]],["~:js-options","~:js-provider"],"^1?",["~:mode"],"~:release",["^3W","~:fn-invoke-direct"],null,["^3W","~:source-map"],null]]]